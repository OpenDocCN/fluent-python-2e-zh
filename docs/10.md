<link href="Styles/Style00.css" rel="stylesheet" type="text/css"> <link href="Styles/Style01.css" rel="stylesheet" type="text/css"> 

# 第八章。在函数中键入提示

> 还应该强调的是， **Python 将仍然是一种动态类型语言，作者并不想强制使用类型提示，即使是按照惯例。**
> 
> 吉多·范·罗苏姆、朱卡·莱托萨洛和祖卡斯·兰加，人教版 484—类型提示 ^([1](ch08.xhtml#idm46582445964528))

自从 2001 年发布的 Python 2.2 中的类型和类的统一以来，类型提示是 Python 历史上最大的变化。然而，类型提示并不能让所有 Python 用户平等受益。这就是为什么它们应该总是可选的。

[PEP 484—类型提示](https://fpy.li/pep484)为函数参数、返回值和变量中的显式类型声明引入了语法和语义。目标是帮助开发者工具通过静态分析发现 Python 代码库中的错误，也就是说，不需要通过测试实际运行代码。

主要受益者是使用 ide(集成开发环境)和 CI(持续集成)的专业软件工程师。使类型提示对该群体有吸引力的成本收益分析并不适用于 Python 的所有用户。

Python 的用户基础远不止这些。它包括许多领域的科学家、交易员、记者、艺术家、制造商、分析师和学生等。对他们中的大多数人来说，学习类型提示的成本可能会更高——除非他们已经知道一种具有静态类型、子类型和泛型的语言。考虑到他们与 Python 的交互方式，以及他们的代码库和团队(通常是一个人的“团队”)的规模较小，对于这些用户来说，好处会更少。Python 的默认动态类型更简单，在编写探索数据和想法的代码时更有表现力，如在数据科学、创造性计算和学习中，

本章主要关注 Python 在函数签名中的类型提示。[第 15 章](ch15.xhtml#more_types_ch)探讨了类上下文中的类型提示，以及其他`typing`模块特性。

本章中的 主要话题有:

*   使用 Mypy 逐步打字的实践介绍

*   鸭子分型和名词分型的互补视角

*   可以出现在注释中的主要类型的概述——这大约是本章的 60%

*   类型提示可变参数(`*args`，`**kwargs`)

*   类型提示和静态类型的限制和缺点

# 本章的新内容

这 章完全是新的。在我包完第一版 *Fluent Python* 之后，Python 3.5 中出现了类型提示。

鉴于静态类型系统的局限性，PEP 484 的最佳想法是引入一个*渐进类型系统*。让我们从定义这是什么意思开始。

# 关于渐进打字

PEP 484 向 Python 引入了一个*渐变类型系统*。其他具有渐进式类型系统的语言有微软的 TypeScript、Dart(由谷歌创建的 Flutter SDK 的语言)和 Hack(脸书的 HHVM 虚拟机支持的 PHP 方言)。Mypy 类型检查器本身最初是一种语言:一种逐渐类型化的 Python 方言，带有自己的解释器。吉多·范·罗苏姆说服了 Mypy 的创造者 Jukka Lehtosalo，让它成为检查带注释的 Python 代码的工具。

渐进型系统:

Is optional

默认情况下，类型检查器不应对没有类型提示的代码发出警告。相反，当类型检查器不能确定对象的类型时，它采用`Any`类型。`Any`类型被认为与所有其他类型兼容。

Does not catch type errors at runtime

静态类型检查器、linters 和 ide 使用类型提示来引发警告。它们不能防止在运行时将不一致的值传递给函数或赋给变量。

Does not enhance performance

类型注释提供了理论上允许优化生成的字节码的数据，但是据我所知，在 2021 年 7 月的任何 Python 运行时中都没有实现这样的优化。 ^([2](ch08.xhtml#idm46582445928816))

渐进键入的最佳可用性特征是注释总是可选的。

对于静态类型系统，大多数类型约束很容易表达，许多很麻烦，一些很难，还有一些是不可能的。 ^([3](ch08.xhtml#idm46582445926464)) 你很可能编写了一段优秀的 Python 代码，具有良好的测试覆盖率并通过了测试，但仍然无法添加满足类型检查器的类型提示。没关系；只需省去有问题的类型提示，然后发送出去！

类型提示在所有级别都是可选的:您可以拥有不带类型提示的整个包，当您将其中一个包导入到使用类型提示的模块中时，您可以使类型检查器静默，并且您可以添加特殊注释以使类型检查器忽略代码中的特定行。

###### 小费

寻求类型提示的 100%覆盖率可能会在没有适当考虑的情况下刺激类型提示，只是为了满足度量标准。这也将阻止团队充分利用 Python 的强大功能和灵活性。当注释会使 API 变得不那么用户友好，或者使其实现过于复杂时，没有类型提示的代码自然应该被接受。

# 实践中的渐进分型

让我们看看渐进打字在实践中是如何工作的，从一个简单的函数开始，在 Mypy 的指导下，逐渐向它添加类型提示。

###### 注意

有几个 Python 类型的检查器与 PEP 484 兼容，包括谷歌的 [pytype](https://fpy.li/8-4) ，微软的 [Pyright](https://fpy.li/8-5) ，脸书的[Pyre](https://fpy.li/8-6)——除了嵌入在 PyCharm 等 ide 中的类型检查器。我选择了 Mypy 作为例子，因为它是最有名的。然而，其中一个可能更适合某些项目或团队。例如，Pytype 被设计用来处理没有类型提示的代码库，并且仍然提供有用的建议。它比 Mypy 更宽松，还能为你的代码生成注释。

我们将注释一个`show_count`函数，该函数返回一个带有计数和单数或复数单词的字符串，具体取决于计数:

```
>>> show_count(99, 'bird')
'99 birds'
>>> show_count(1, 'bird')
'1 bird'
>>> show_count(0, 'bird')
'no birds'
```

例 8-1 显示的是`show_count`的源代码，没有标注。

##### 例 8-1。 `show_count`发自 *messages.py* 无类型提示

```
def show_count(count, word):
    if count == 1:
        return f'1 {word}'
    count_str = str(count) if count else 'no'
    return f'{count_str} {word}s'
```

## 从 Mypy 开始

为了开始类型检查，我在 *messages.py* 模块上运行`mypy`命令:

```
…/no_hints/ $ pip install mypy
[lots of messages omitted...]
…/no_hints/ $ mypy messages.py
Success: no issues found in 1 source file
```

使用默认设置的 Mypy 发现示例 8-1 没有问题。

###### 警告

我使用的是 Mypy 0.910，这是我在 2021 年 7 月审查这个版本时的最新版本。Mypy [“简介”](https://fpy.li/8-7)警告说它“是正式的测试版软件。偶尔会有打破向后兼容性的变化。”Mypy 至少给了我一份报告，这份报告与我在 2020 年 4 月写这一章时得到的报告不同。当你读到这里的时候，你可能会得到与这里不同的结果。

如果函数签名没有注释，默认情况下 Mypy 会忽略它——除非另行配置。

对于例 8-2 ，我也有`pytest`单元测试。这是 *messages_test.py* 中的代码。

##### 例 8-2。 *messages_test.py* 不带类型提示

```
from pytest import mark

from messages import show_count

@mark.parametrize('qty, expected', [
    (1, '1 part'),
    (2, '2 parts'),
])
def test_show_count(qty, expected):
    got = show_count(qty, 'part')
    assert got == expected

def test_show_count_zero():
    got = show_count(0, 'part')
    assert got == 'no parts'
```

现在让我们在 Mypy 的指导下添加类型提示。

## 使 Mypy 更加严格

命令行选项`--disallow-untyped-defs`让 Mypy 标记任何没有为其所有参数和返回值提供类型提示的函数定义。

在测试文件上使用`--disallow-untyped-defs`会产生三个错误和一个注释:

```
…/no_hints/ $ mypy --disallow-untyped-defs messages_test.py
messages.py:14: error: Function is missing a type annotation
messages_test.py:10: error: Function is missing a type annotation
messages_test.py:15: error: Function is missing a return type annotation
messages_test.py:15: note: Use "-> None" if function does not return a value
Found 3 errors in 2 files (checked 1 source file)
```

对于逐步输入的第一步，我更喜欢使用另一个选项:`--disallow-incomplete-defs`。最初，它什么也没告诉我:

```
…/no_hints/ $ mypy --disallow-incomplete-defs messages_test.py
Success: no issues found in 1 source file
```

现在我可以将返回类型添加到*消息中的`show_count`:*

```
def show_count(count, word) -> str:
```

这足以让我的 py 看它。使用与之前相同的命令行检查 *messages_test.py* 将导致 Mypy 再次查看 *messages.py* :

```
…/no_hints/ $ mypy --disallow-incomplete-defs messages_test.py
messages.py:14: error: Function is missing a type annotation
for one or more arguments
Found 1 error in 1 file (checked 1 source file)
```

现在我可以一个函数一个函数地添加类型提示，而不会得到关于我没有注释的函数的警告。这是一个满足 Mypy 的完全注释的签名:

```
def show_count(count: int, word: str) -> str:
```

###### 小费

您可以按照 [Mypy 配置文件](https://fpy.li/8-8)文档中的描述保存您的收藏夹，而不是键入像`--disallow-incomplete-defs`这样的命令行选项。您可以有全局设置和每个模块的设置。这里有一个简单的 *mypy.ini* 来开始:

```
[mypy]
python_version = 3.9
warn_unused_configs = True
disallow_incomplete_defs = True
```

## 默认参数值

例 8-1 中的`show_count`函数只适用于常规名词。如果复数不能通过添加一个`'s'`来拼写，我们应该让用户提供复数形式，就像这样:

```
>>> show_count(3, 'mouse', 'mice')
'3 mice'
```

让我们做一点“类型驱动开发”首先，我们添加一个使用第三个参数的测试。不要忘记在测试函数中添加返回类型提示，否则 Mypy 不会检查它。

```
def test_irregular() -> None:
    got = show_count(2, 'child', 'children')
    assert got == '2 children'
```

Mypy 检测到错误:

```
…/hints_2/ $ mypy messages_test.py
messages_test.py:22: error: Too many arguments for "show_count"
Found 1 error in 1 file (checked 1 source file)
```

现在我编辑`show_count`，在示例 8-3 中添加可选的`plural`参数。

##### 例 8-3。`showcount`from*hints _ 2/messages . py*带可选参数

```
def show_count(count: int, singular: str, plural: str = '') -> str:
    if count == 1:
        return f'1 {singular}'
    count_str = str(count) if count else 'no'
    if not plural:
        plural = singular + 's'
    return f'{count_str} {plural}'
```

现在，Mypy 报告“成功”

###### 警告

这里有一个 Python 没有发现的输入错误。你能发现它吗？

```
def hex2rgb(color=str) -> tuple[int, int, int]:
```

Mypy 的错误报告不是很有帮助:

```
colors.py:24: error: Function is missing a type
    annotation for one or more arguments
```

`color`参数的类型提示应该是`color: str`。我写的`color=str`，不是注释:它把`color`的默认值设置为`str`。

根据我的经验，这是一个常见的错误，很容易被忽略，尤其是在复杂的类型提示中。

以下详细信息被认为是类型提示的良好样式:

*   参数名和`:`之间没有空格；`:`后一个空格

*   默认参数值前面的`=`两边的空格

另一方面，PEP 8 说如果没有特定参数的类型提示，那么在`=`周围就不应该有空格。

## 使用无作为默认值

在例 8-3 中，参数`plural`注释为`str`，默认值为`''`，因此不存在类型冲突。

我喜欢这个解决方案，但是在其他情况下，`None`是更好的缺省值。如果可选参数需要可变类型，那么`None`是唯一合理的默认值——正如我们在[“可变类型作为参数默认值:坏主意”](ch06.xhtml#mutable_default_parameter_sec)中看到的。

要将`None`作为`plural`参数的默认值，签名应该是这样的:

```
from typing import Optional

def show_count(count: int, singular: str, plural: Optional[str] = None) -> str:
```

让我们打开包装:

*   `Optional[str]`表示`plural`可能是`str`或`None`。

*   您必须明确提供默认值`= None`。

如果没有给`plural`赋一个默认值，Python 运行时会把它当作一个必需的参数。记住:在运行时，类型提示被忽略。

注意，我们需要从`typing`模块导入`Optional`。当导入类型时，最好使用语法`from typing import X`来减少函数签名的长度。

###### 警告

`Optional`并不是一个好名字，因为注释并没有使参数可选。使它可选的是给参数分配一个默认值。`Optional[str]`只是表示:该参数的类型可以是`str`或`NoneType`。在 Haskell 和 Elm 语言中，类似的类型被命名为`Maybe`。

既然我们已经有了渐进打字的第一个实际观点，让我们考虑一下*类型*的概念在实践中意味着什么。

# 类型由支持的操作定义

> 文献中对类型的概念有多种定义。这里我们假设类型是一组值和一组可以应用于这些值的函数。
> 
> PEP 483—类型提示理论

在 实践中，将支持的操作集视为类型的定义特征更有用。 ^([4](ch08.xhtml#idm46582445234336))

例如，从适用操作的角度来看，以下函数中`x`的有效类型有哪些？

```
def double(x):
    return x * 2
```

`x`参数类型可以是数值型(`int`、`complex`、`Fraction`、`numpy.uint32`等)。)但是它也可以是一个序列(`str`、`tuple`、`list`、`array`)、一个 N 维的`numpy.array`，或者任何其他实现或继承接受`int`参数的`__mul__`方法的类型。

然而，考虑一下这个注释`double`。现在请忽略缺少的返回类型，让我们关注参数类型:

```
from collections import abc

def double(x: abc.Sequence):
    return x * 2
```

类型检查器将拒绝该代码。如果你告诉 Mypy】是类型`abc.Sequence`，它将把`x * 2`标记为错误，因为 [`Sequence` ABC](https://fpy.li/8-13) 没有实现或者继承`__mul__`方法。在运行时，代码将使用具体的序列，如`str`、`tuple`、`list`、`array`等。，以及数字，因为在运行时类型提示会被忽略。但是类型检查器只关心显式声明的内容，`abc.Sequence`没有`__mul__`。

这就是为什么本节的标题是“类型由支持的操作定义”Python 运行时接受任何对象作为两个版本的`double`函数的`x`参数。计算`x * 2`可能工作，或者如果`x`不支持该操作，则可能引发`TypeError`。相比之下，Mypy 在分析带注释的`double`源代码时会将`x * 2`声明为错误，因为它是声明类型`x: abc.Sequence`不支持的操作。

在渐进类型系统中，我们有两种不同的类型视图的相互作用:

Duck typing

small talk——面向对象语言的先驱——以及 Python、JavaScript 和 Ruby 采用的观点。对象有类型，但是变量(包括参数)是无类型的。实际上，对象声明的类型是什么并不重要，重要的是它实际支持什么操作。如果我可以调用`birdie.quack()`，那么`birdie`在这个上下文中就是一只鸭子。根据定义，duck typing 只在运行时执行，即试图对对象进行操作时。这比*名义类型*更灵活，代价是在运行时允许更多的错误。 ^([5](ch08.xhtml#idm46582445162944))

Nominal typing

C++、Java 和 C#采用的视图，受带注释的 Python 支持。对象和变量都有类型。但是对象只存在于运行时，类型检查器只关心用类型提示注释了变量(包括参数)的源代码。如果`Duck`是`Bird`的子类，你可以将一个`Duck`实例赋给一个标注为`birdie: Bird`的参数。但是在函数体中，类型检查器认为调用`birdie.quack()`是非法的，因为`birdie`名义上是一个`Bird`，而那个类不提供`.quack()`方法。运行时的实际参数是否是一个`Duck`并不重要，因为名义类型是静态执行的。类型检查器不运行程序的任何部分，它只读取源代码。这比 *duck typing* 更加严格，优点是可以在构建管道中更早地捕捉到一些 bug，甚至可以在 IDE 中键入代码。

例 8-4 是一个比较鸭类型化和名义类型化，以及静态类型检查和运行时行为的傻例子。 ^([6](ch08.xhtml#idm46582445123568))

##### 例 8-4。 *birds.py*

```
classBird:passclassDuck(Bird):![1](Images/1.png)defquack(self):print('Quack!')defalert(birdie):![2](Images/2.png)birdie.quack()defalert_duck(birdie:Duck)->None:![3](Images/3.png)birdie.quack()defalert_bird(birdie:Bird)->None:![4](Images/4.png)birdie.quack()
```

![1](Images/1.png)

`Duck`是`Bird`的子类。

![2](Images/2.png)

`alert`没有类型提示，所以类型检查器忽略它。

![3](Images/3.png)

`alert_duck`接受一个类型为`Duck`的参数。

![4](Images/4.png)

`alert_bird`接受一个`Bird`类型的参数。

类型检查 *birds.py* 用 Mypy，我们看到一个问题:

```
…/birds/ $ mypy birds.py
birds.py:16: error: "Bird" has no attribute "quack"
Found 1 error in 1 file (checked 1 source file)
```

仅仅通过分析源代码，Mypy 就看出`alert_bird`有问题:类型提示用类型`Bird`声明了`birdie`参数，但是函数体调用了`birdie.quack()`——`Bird`类没有这样的方法。

现在我们试着使用 *daffy.py* 中的`birds`模块例 8-5 。

##### 例 8-5。daffy . py

```
frombirdsimport*daffy=Duck()alert(daffy)![1](Images/1.png)alert_duck(daffy)![2](Images/2.png)alert_bird(daffy)![3](Images/3.png)
```

![1](Images/1.png)

有效调用，因为`alert`没有类型提示。

![2](Images/2.png)

有效调用，因为`alert_duck`接受一个`Duck`参数，而`daffy`是一个`Duck`。

![3](Images/3.png)

有效的调用，因为`alert_bird`带有一个`Bird`参数，并且`daffy`也是一个`Bird`—`Duck`的超类。

在 *daffy.py* 上运行 Mypy 会引发与 *birds.py* 中定义的`alert_bird`函数中的`quack`调用相同的错误:

```
…/birds/ $ mypy daffy.py
birds.py:16: error: "Bird" has no attribute "quack"
Found 1 error in 1 file (checked 1 source file)
```

但是 Mypy 认为 *daffy.py* 本身没有问题:三个函数调用都没问题。

现在，如果你运行 *daffy.py* ，你会得到:

```
…/birds/ $ python3 daffy.py
Quack!
Quack!
Quack!
```

一切正常！鸭打字 FTW！

在运行时，Python 不关心声明的类型。它只使用鸭打字。Mypy 在`alert_bird`中标记了一个错误，但是用`daffy`调用它在运行时工作正常。这一开始可能会让很多 python 爱好者感到惊讶:静态类型检查器有时会在我们知道将要执行的程序中发现错误。

然而，如果几个月后你的任务是扩展愚蠢的鸟的例子，你可能会感谢 Mypy。考虑一下示例 8-6 中的这个 *woody.py* 模块，它也使用了`birds`。

##### 例 8-6。 *woody.py*

```
from birds import *

woody = Bird()
alert(woody)
alert_duck(woody)
alert_bird(woody)
```

Mypy 在检查 *woody.py* 时发现两个错误:

```
…/birds/ $ mypy woody.py
birds.py:16: error: "Bird" has no attribute "quack"
woody.py:5: error: Argument 1 to "alert_duck" has incompatible type "Bird";
expected "Duck"
Found 2 errors in 2 files (checked 1 source file)
```

第一个错误在 *birds.py* 中:`alert_bird`中的`birdie.quack()`调用，我们之前见过。第二个错误在 *woody.py* : `woody`是`Bird`的一个实例，所以调用`alert_duck(woody)`无效，因为那个函数需要一个`Duck`。每个`Duck`都是一个`Bird`，但不是每个`Bird`都是一个`Duck`。

在运行时， *woody.py* 中没有一个调用成功。在示例 8-7 中的控制台会话中，连续的故障得到了最好的说明。

##### 例 8-7。运行时错误和 Mypy 的帮助

```
>>>frombirdsimport*>>>woody=Bird()>>>alert(woody)![1](Images/1.png)Traceback(mostrecentcalllast):...AttributeError:'Bird'objecthasnoattribute'quack'>>>>>>alert_duck(woody)![2](Images/2.png)Traceback(mostrecentcalllast):...AttributeError:'Bird'objecthasnoattribute'quack'>>>>>>alert_bird(woody)![3](Images/3.png)Traceback(mostrecentcalllast):...AttributeError:'Bird'objecthasnoattribute'quack'
```

![1](Images/1.png)

Mypy 无法检测到这个错误，因为在`alert`中没有类型提示。

![2](Images/2.png)

Mypy 报错:`Argument 1 to "alert_duck" has incompatible type "Bird"; expected "Duck"`。

![3](Images/3.png)

Mypy 从例 8-4 开始就一直告诉我们`alert_bird`函数的体是错的:`"Bird" has no attribute "quack"`。

这个小实验表明，duck typing 更容易上手，也更灵活，但允许不支持的操作在运行时导致错误。名义类型在运行前检测错误，但有时会拒绝实际运行的代码——比如示例 8-5 中的调用`alert_bird(daffy)`。即使它有时能工作，但`alert_bird`函数名不副实:它的主体确实需要一个支持`.quack()`方法的对象，而`Bird`没有。

在这个愚蠢的例子中，函数是一行程序。但是在实际代码中，它们可能会更长；他们可以将`birdie`参数传递给更多的函数，而`birdie`参数的来源可能是许多函数调用，这使得很难查明运行时错误的原因。类型检查器防止了许多这样的错误在运行时发生。

###### 注意

在适合一本书的小例子中，类型提示的价值是值得怀疑的。好处随着代码库的扩大而增加。这就是为什么拥有数百万行 Python 代码的公司——如 Dropbox、谷歌和脸书——投资团队和工具来支持在公司范围内采用类型提示，并在其 CI 管道中检查其 Python 代码库类型的重要且不断增加的部分。

在这一节中，我们探索了 duck 类型化和 nominal 类型化中类型和操作的关系，从简单的`double()`函数开始——我们没有给出适当的类型提示。现在我们将浏览用于注释函数的最重要的类型。当我们到达“静态协议”时，我们将会看到一个很好的方法来给`double()`添加类型提示。但在此之前，我们还需要了解更多的基本类型。

# 注释中可用的类型

任何 Python 类型都可以在类型提示中使用，但是有一些限制和建议。此外， `typing`模块引入了特殊的构造，其语义有时令人惊讶。

本节涵盖了可以用于注释的所有主要类型:

*   `typing.Any`

*   简单类型和类

*   `typing.Optional`和`typing.Union`

*   一般集合，包括元组和映射

*   抽象基类

*   通用可重复项

*   参数化泛型和`TypeVar`

*   `typing.Protocols`—*静鸭打字的关键*

*   `typing.Callable`

*   `typing.NoReturn`—结束这份清单的好方法

我们将依次讨论每一种类型，从一种奇怪的、显然无用但却至关重要的类型开始。

## 任何类型

任何渐变型系统的 梯形都是`Any`型，也称为*动态型*。当类型检查器看到这样的非类型化函数时:

```
def double(x):
    return x * 2
```

它假设:

```
def double(x: Any) -> Any:
    return x * 2
```

这意味着`x`参数和返回值可以是任何类型，包括不同的类型。`Any`假设支持每一种可能的操作。

对比`Any`和`object`。考虑这个签名:

```
def double(x: object) -> object:
```

这个函数也接受所有类型的参数，因为所有类型都是的*子类型。*

但是，类型检查器将拒绝此功能:

```
def double(x: object) -> object:
    return x * 2
```

问题是`object`不支持`__mul__`操作。这是 Mypy 的报告:

```
…/birds/ $ mypy double_object.py
double_object.py:2: error: Unsupported operand types for * ("object" and "int")
Found 1 error in 1 file (checked 1 source file)
```

更通用的类型具有更窄的接口，即它们支持更少的操作。`object`类实现的操作比`abc.Sequence`少，后者实现的操作比`abc.MutableSequence`少，后者实现的操作比`list`少。

但是`Any`是一个神奇的类型，位于类型层次结构的顶部和底部。它同时是最通用的类型——因此参数`n: Any`接受所有类型的值——也是最专业的类型，支持所有可能的操作。至少，类型检查器是这么理解`Any`的。

当然，没有一种类型能够支持所有可能的操作，所以使用`Any`会阻止类型检查器完成其核心任务:在程序因运行时异常而崩溃之前检测潜在的非法操作。

### 子类型-of 对一致性-with

传统的 面向对象的名义类型系统依赖的是*的子类型——对*的关系。给定一个类`T1`和一个子类`T2`，那么`T2`就是的*子类`T1`。*

考虑以下代码:

```
class T1:
    ...

class T2(T1):
    ...

def f1(p: T1) -> None:
    ...

o2 = T2()

f1(o2)  # OK
```

调用`f1(o2)`是 Liskov 替代原理——LSP 的应用。芭芭拉·利斯科夫 ^([7](ch08.xhtml#idm46582444453504)) 实际定义的*是*的子类型——就支持的操作而言:如果一个`T2`类型的对象替换了一个`T1`类型的对象，并且程序仍然正确运行，那么`T2`就是*子类型——属于* `T1`。

继续前面的代码，这显示了违反 LSP 的情况:

```
def f2(p: T2) -> None:
    ...

o1 = T1()

f2(o1)  # type error
```

从支持的操作的角度来看，这非常有意义:作为一个子类，`T2`继承并且必须支持`T1`所做的所有操作。因此,`T2`的实例可以用在任何需要`T1`实例的地方。但是反过来就不一定了:`T2`可能会实现额外的方法，所以`T1`的实例可能不会用在所有需要`T2`实例的地方。这个对支持操作的关注反映在名称 [*行为子类型*](https://fpy.li/8-15) 中，也用于指代 LSP。

在渐变类型系统中，还有另一种关系:*与*一致，适用于的*子类型，对`Any`类型有特殊规定。*

*与*一致的规则是:

1.  给定`T1`和一个子类型`T2`，那么`T2`就是*一致——与* `T1`(利斯科夫替换)。

2.  每种类型都是*一致的——与* `Any`一致:你可以将每种类型的对象传递给一个声明为类型`Any`的参数。

3.  `Any`是否与每种类型一致:在需要另一种类型的参数的地方，你总是可以传递一个类型为`Any`的对象。

考虑到先前对对象`o1`和`o2`的定义，以下是有效代码的示例，说明规则#2 和#3:

```
def f3(p: Any) -> None:
    ...

o0 = object()
o1 = T1()
o2 = T2()

f3(o0)  #
f3(o1)  #  all OK: rule #2
f3(o2)  #

def f4():  # implicit return type: `Any`
    ...

o4 = f4()  # inferred type: `Any`

f1(o4)  #
f2(o4)  #  all OK: rule #3
f3(o4)  #
```

每个渐变类型系统都需要一个像`Any`这样的通配符类型。

###### 小费

动词“推断”是“猜测”的同义词，用于类型分析的上下文中。Python 和其他语言中的现代类型检查器不需要到处都有类型注释，因为它们可以推断许多表达式的类型。例如，如果我写`x = len(s) * 10`，类型检查器不需要显式的本地声明就能知道`x`是一个`int`，只要它能找到`len`内置的类型提示。

现在我们可以探索注释中使用的其他类型。

## 简单类型和类

简单类型如`int`、`float`、`str`和`bytes`可以直接用在类型提示中。来自标准库、外部包或用户定义的具体类— `FrenchDeck`、`Vector2d`和`Duck`—也可以在类型提示中使用。

抽象基类在类型提示中也很有用。我们将在学习集合类型时回到它们，在“抽象基类”中。

在类中，*与*一致的定义类似于的*子类型:一个子类与*的所有超类一致。

然而，“实用性胜过纯粹性”，所以有一个重要的例外，我将在下面的技巧中讨论。

# int 与 complex 一致

内置类型`int`、`float`、`complex`之间没有名义上的子类型关系:它们是`object`的直接子类。但是 PEP 484 [声明](https://fpy.li/cardxvi)`int`与*一致——与* `float`一致，`float`与 `complex`一致。这在实践中是有意义的:`int`实现了`float`所做的所有操作，并且`int`也实现了额外的操作——像`&`、`|`、`<<`等位运算。最终结果是:`int`与*一致——与* `complex`一致。对于`i = 3`，`i.real`为`3`，`i.imag`为`0`。

## 可选和联合类型

我们 看到了【使用无作为默认】中的`Optional`特殊类型。它解决了将`None`作为默认值的问题，如该节中的示例所示:

```
from typing import Optional

def show_count(count: int, singular: str, plural: Optional[str] = None) -> str:
```

构造`Optional[str]`实际上是`Union[str, None]`的快捷方式，意味着`plural`的类型可能是`str`或`None`。

# Python 3.10 中可选和联合的更好语法

从 Python 3.10 开始我们可以写`str | bytes`而不是`Union[str, bytes]`。少了打字，也不用从`typing`导入`Optional`或者`Union`。对比`show_count`的`plural`参数的类型提示的新旧语法:

```
plural: Optional[str] = None    # before
plural: str | None = None       # after
```

`|`操作符还与`isinstance`和`issubclass`一起构建第二个参数:`isinstance(x, int | str)`。更多信息，请参见[PEP 604-Union[]的补充语法](https://fpy.li/pep604)。

`ord`内置函数的签名是`Union`的一个简单例子——它接受`str`或`bytes`，并返回一个`int` : ^([8](ch08.xhtml#idm46582444129504))

```
def ord(c: Union[str, bytes]) -> int: ...
```

下面是一个函数的例子，它接受一个`str`，但可能返回一个`str`或一个`float`:

```
from typing import Union

def parse_token(token: str) -> Union[str, float]:
    try:
        return float(token)
    except ValueError:
        return token
```

如果可能的话，避免创建返回`Union`类型的函数，因为它们给用户增加了额外的负担——迫使他们在运行时检查返回值的类型，以知道如何处理它。但是前面代码中的`parse_token`在简单表达式求值器的上下文中是一个合理的用例。

###### 小费

在“双模式 str 和 bytes API”](ch04.xhtml#dual_mode_api_sec)中，我们看到了接受`str`或`bytes`参数的函数，但是如果参数是`str`则返回`str`，如果参数是`bytes`则返回`bytes`。在那些情况下，返回类型由输入类型决定，所以`Union`不是一个准确的解决方案。为了正确地注释这样的函数，我们需要一个类型变量——在[“参数化泛型和类型变量”中给出——或者重载，我们将在[“重载签名”](ch15.xhtml#overload_sec)中看到。

`Union[]`至少需要两种类型。嵌套的`Union`类型与展平的`Union`类型具有相同的效果。所以这个类型提示:

```
Union[A, B, Union[C, D, E]]
```

与以下内容相同:

```
Union[A, B, C, D, E]
```

`Union`对于类型之间不一致的情况更有用。比如:`Union[int, float]`是多余的，因为`int`与*一致——与* `float`一致。如果您只是使用`float`来注释参数，它也将接受`int`值。

## 通用集合

大多数 Python 集合都是异构的。例如，您可以将不同类型的任意混合物放入一个`list`。然而，在实践中这不是很有用:如果你把对象放在一个集合中，你很可能想要在以后对它们进行操作，通常这意味着它们必须共享至少一个公共方法。 ^([9](ch08.xhtml#idm46582443927296))

泛型类型可以用类型参数来声明，以指定它们可以处理的项的类型。

例如，一个`list`可以被参数化以约束其中元素的类型，正如你在示例 8-8 中看到的。

##### 例 8-8。 `tokenize`带有 Python ≥ 3.9 的类型提示

```
def tokenize(text: str) -> list[str]:
    return text.upper().split()
```

在 Python ≥ 3.9 中，这意味着`tokenize`返回一个`list`，其中每一项都是类型`str`。

注释`stuff: list`和`stuff: list[Any]`的意思是一样的:`stuff`是任何类型的对象列表。

###### 小费

如果您使用的是 Python 3.8 或更早版本，概念是相同的，但是您需要更多的代码来使其工作——如可选框“遗留支持和不推荐的集合类型】中所解释的。

[PEP 585—标准集合中的类型提示泛型](https://fpy.li/8-16)列出了标准库中接受泛型类型提示的集合。下面的列表只显示那些使用最简单形式的泛型类型提示的集合， `container[item]` :

```
list        collections.deque        abc.Sequence   abc.MutableSequence
set         abc.Container            abc.Set        abc.MutableSet
frozenset   abc.Collection
```

`tuple`和映射类型支持更复杂的类型提示，我们将在它们各自的章节中看到。

截至 Python 3.10，考虑到`typecode`构造函数参数决定数组中存储的是整数还是浮点数，还没有很好的方法来注释`array.array`。一个更难的问题是，在运行时向数组添加元素时，如何键入检查整数范围以防止`OverflowError`。比如带`typecode='B'`的`array`只能保存从 0 到 255 的`int`值。目前，Python 的静态类型系统还不能应对这一挑战。

现在让我们看看如何注释泛型元组。

## 元组类型

有三种方式来注释元组类型:

*   元组作为记录

*   元组作为带有命名字段的记录

*   作为不可变序列的元组

### 元组作为记录

如果使用`tuple`作为记录，使用内置的`tuple`并在`[]`中声明字段的类型。

例如，类型提示应该是`tuple[str, float, str]`来接受一个包含城市名、人口和国家的元组:`('Shanghai', 24.28, 'China')`。

考虑一个采用一对地理坐标并返回一个 [Geohash](https://fpy.li/8-18) 的函数，用法如下:

```
>>> shanghai = 31.2304, 121.4737
>>> geohash(shanghai)
'wtw3sjq6q'
```

示例 8-11 展示了如何使用 PyPI 的`geolib`包定义`geohash`。

##### 例 8-11。 *坐标. py* 带`geohash`功能

```
fromgeolibimportgeohashasgh# type: ignore ![1](Images/1.png)PRECISION=9defgeohash(lat_lon:tuple[float,float])->str:![2](Images/2.png)returngh.encode(*lat_lon,PRECISION)
```

![1](Images/1.png)

这个注释阻止了 Mypy 报告`geolib`包没有类型提示。

![2](Images/2.png)

`lat_lon`参数标注为带有两个`float`字段的`tuple`。

###### 小费

对于 Python < 3.9，在类型提示中导入并使用`typing.Tuple`。它已被弃用，但将至少在 2024 年之前保留在标准库中。

### 元组作为带有命名字段的记录

要注释一个有很多字段的元组，或者你的代码在很多地方使用的特定类型的元组，我强烈推荐使用`typing.NamedTuple`，如第 5 章](ch05.xhtml#data_class_ch)所示。[实施例 8-12 是对实施例 8-11 的变型`NamedTuple`。

##### 例 8-12。 *带`NamedTuple` `Coordinates`和`geohash`功能的坐标 _ 命名. py*

```
from typing import NamedTuple

from geolib import geohash as gh  # type: ignore

PRECISION = 9

class Coordinate(NamedTuple):
    lat: float
    lon: float

def geohash(lat_lon: Coordinate) -> str:
    return gh.encode(*lat_lon, PRECISION)
```

正如在[“数据类构建器概述”](ch05.xhtml#data_class_overview_sec)中所解释的那样，`typing.NamedTuple`是`tuple`子类的工厂，因此`Coordinate`与*一致——与* `tuple[float, float]`一致，但反过来就不一样了——毕竟`Coordinate`有`NamedTuple`添加的额外方法，就像`._asdict()`一样，也可以有用户定义的方法。

实际上，这意味着将一个`Coordinate`实例传递给下面定义的`display`函数是类型安全的:

```
def display(lat_lon: tuple[float, float]) -> str:
    lat, lon = lat_lon
    ns = 'N' if lat >= 0 else 'S'
    ew = 'E' if lon >= 0 else 'W'
    return f'{abs(lat):0.1f}°{ns}, {abs(lon):0.1f}°{ew}'
```

### 作为不可变序列的元组

要注释用作不可变列表的未指定长度的元组，必须指定单一类型，后跟一个逗号和`...`(那是 Python 的省略号标记，由三个句点组成，不是 Unicode `U+2026` — `HORIZONTAL ELLIPSIS`)。

例如，`tuple[int, ...]`是一个包含`int`项的元组。

省略号表示> = 1 的任何数量的元素都是可接受的。没有办法为任意长度的元组指定不同类型的字段。

注释`stuff: tuple[Any, ...]`和`stuff: tuple`的意思是一样的:`stuff`是一个不确定长度的元组，包含任何类型的对象。

下面是一个`columnize`函数，它将一个序列转换成一个包含行和单元格的表格，表格的形式是一个不确定长度的元组列表。这对于在列中显示项目很有用，如下所示:

```
>>> animals = 'drake fawn heron ibex koala lynx tahr xerus yak zapus'.split()
>>> table = columnize(animals)
>>> table
[('drake', 'koala', 'yak'), ('fawn', 'lynx', 'zapus'), ('heron', 'tahr'),
 ('ibex', 'xerus')]
>>> for row in table:
...     print(''.join(f'{word:10}' for word in row))
...
drake     koala     yak
fawn      lynx      zapus
heron     tahr
ibex      xerus
```

例 8-13 展示了`columnize`的实现。注意返回和类型:

```
list[tuple[str, ...]]
```

##### 例 8-13。 *columnize.py* 返回字符串元组列表

```
from collections.abc import Sequence

def columnize(
    sequence: Sequence[str], num_columns: int = 0
) -> list[tuple[str, ...]]:
    if num_columns == 0:
        num_columns = round(len(sequence) ** 0.5)
    num_rows, reminder = divmod(len(sequence), num_columns)
    num_rows += bool(reminder)
    return [tuple(sequence[i::num_rows]) for i in range(num_rows)]
```

## 通用映射

通用映射类型 标注为`MappingTypeKeyType, ValueType]`。在 Python ≥ 3.9 中，内置的`dict`和`collections`和`collections.abc`中的映射类型接受该符号。对于早期版本，您必须使用`typing`模块中的`typing.Dict`和其他映射类型，如[“遗留支持和不推荐的集合类型”中所述。

示例 8-14 展示了一个函数的实际使用，该函数返回一个[倒排索引](https://fpy.li/8-19)来按名称搜索 Unicode 字符——示例 4-21 的一个变型，更适合于服务器端代码，我们将在第 21 章中研究。

给定起始和结束 Unicode 字符代码，`name_index`返回一个`dict[str, set[str]]`，这是一个倒排索引，将每个单词映射到名称中包含该单词的一组字符。例如，在将 ASCII 字符从 32 索引到 64 之后，下面是映射到单词`'SIGN'`和`'DIGIT'`的字符集，以及如何找到名为`'DIGIT EIGHT'`的字符:

```
>>> index = name_index(32, 65)
>>> index['SIGN']
{'$', '>', '=', '+', '<', '%', '#'}
>>> index['DIGIT']
{'8', '5', '6', '2', '3', '0', '1', '4', '7', '9'}
>>> index['DIGIT'] & index['EIGHT']
{'8'}
```

示例 8-14 显示了带有`name_index`功能的 *charindex.py* 的源代码。除了一个`dict[]`类型的提示，这个例子还有三个在书中首次出现的特性。

##### 例 8-14。 *charindex.py*

```
importsysimportreimportunicodedatafromcollections.abcimportIteratorRE_WORD=re.compile(r'\w+')STOP_CODE=sys.maxunicode+1deftokenize(text:str)->Iterator[str]:![1](Images/1.png)"""return iterable of uppercased words"""formatchinRE_WORD.finditer(text):yieldmatch.group().upper()defname_index(start:int=32,end:int=STOP_CODE)->dict[str,set[str]]:index:dict[str,set[str]]={}![2](Images/2.png)forcharin(chr(i)foriinrange(start,end)):ifname:=unicodedata.name(char,''):![3](Images/3.png)forwordintokenize(name):index.setdefault(word,set()).add(char)returnindex
```

![1](Images/1.png)

`tokenize`是生成器功能。[第十七章](ch17.xhtml#iterables2generators)是关于发电机的。

![2](Images/2.png)

局部变量`index`被注释。没有提示，Mypy 说:`Need type annotation for 'index' (hint: "index: dict[<type>, <type>] = ...")`。

![3](Images/3.png)

我在`if`条件中使用了 walrus 操作符`:=`。它将`unicodedata.name()`调用的结果赋给`name`，整个表达式计算出该结果。当结果是`''`时，那就是 falsy，`index`不更新。 ^([11](ch08.xhtml#idm46582442856960))

###### 注意

当使用`dict`作为记录时，通常所有键都是`str`类型，根据键的不同，值的类型也不同。这包括在[“类型识别”](ch15.xhtml#typeddict_sec)中。

## 抽象基类

> 发送的东西要保守，接受的东西要开明。
> 
> 波斯特尔定律又名稳健性原理

表 8-1 列出了`collections.abc`的几个抽象类 。理想情况下，函数应该接受这些抽象类型的参数——或者 Python 3.9 之前的`typing`等价类型——而不是具体类型。这给了呼叫者更多的灵活性。

考虑这个函数签名:

```
from collections.abc import Mapping

def name2hex(name: str, color_map: Mapping[str, int]) -> str:
```

使用`abc.Mapping`允许调用者提供一个`dict`、`defaultdict`、`ChainMap`、一个`UserDict`子类或者任何其他类型的实例，这些类型是 `Mapping`的*子类型。*

相比之下，考虑这个签名:

```
def name2hex(name: str, color_map: dict[str, int]) -> str:
```

现在`color_map`一定是`dict`或者它的一个子类型，比如`defaultDict`或者 `OrderedDict` 。特别是，`collections.UserDict`的子类不会通过对`color_map`的类型检查，尽管这是创建用户定义的映射的推荐方式，正如我们在[“子类化用户字典而不是字典”](ch03.xhtml#sublcassing_userdict_sec)中看到的。Mypy 会拒绝一个`UserDict`或者从它派生的类的实例，因为`UserDict` 不是的子类；他们是兄弟姐妹。两者都是 `abc.MutableMapping` 的子类。 ^([12](ch08.xhtml#idm46582442746032))

因此，通常最好在参数类型提示中使用`abc.Mapping`或`abc.MutableMapping`，而不是`dict`(或遗留代码中的`typing.Dict`)。如果`name2hex`函数不需要对给定的`color_map`进行变异，那么`color_map`最准确的类型提示就是`abc.Mapping`。这样，调用者不需要提供一个对象来实现像`setdefault`、`pop`和`update`这样的方法，它们是`MutableMapping`接口的一部分，而不是`Mapping`的一部分。这与波斯特尔定律的第二部分有关:“对你所接受的东西要开明。”

波斯特定律也告诉我们在发送邮件时要保守。函数的返回值总是一个具体的对象，所以返回类型提示应该是一个具体的类型，就像“泛型集合”中的例子一样——它使用了`list[str]`:

```
def tokenize(text: str) -> list[str]:
    return text.upper().split()
```

在 [`typing.List`](https://fpy.li/8-20) 的条目下，Python 文档中说:

> 通用版本的`list`。用于注释返回类型。要注释参数，最好使用抽象集合类型，如`Sequence`或`Iterable`。

类似的注释出现在 [`typing.Dict`](https://fpy.li/8-21) 和 [`typing.Set`](https://fpy.li/8-22) 的条目中。

请记住，从 Python 3.9 开始，`collections.abc`中的大多数 ABC 和`collections`中的其他具体类以及内置集合都支持类似于`collections.deque[str]`的泛型类型提示符号。对应的`typing`集合只需要支持用 Python 3.8 或更早版本编写的代码。成为泛型的类的完整列表出现在[PEP 585-标准集合中的类型提示泛型](https://fpy.li/pep585)的[“实现”](https://fpy.li/8-16)部分。

为了总结我们对类型提示中 ABC 的讨论，我们需要谈谈`numbers`ABC。

### 数字塔的倒塌

[`numbers`](https://fpy.li/8-24) 包定义了 [PEP 3141 中描述的所谓的*数字塔*—数字](https://fpy.li/pep3141)的一种类型层次结构。该塔是 ABC 的线性层级，顶部是`Number`:

*   `Number`

*   `Complex`

*   `Real`

*   `Rational`

*   `Integral`

这些 ABC 非常适合运行时类型检查，但是它们不支持静态类型检查。PEP 484 的【数字塔】](https://fpy.li/cardxvi)部分拒绝`numbers` ABCs，并规定内置类型`complex`、`float`和`int`应作为特例对待，如[“int Is Consistent-With complex”中所述。

我们将在[“数字 ABC 和数字协议”](ch13.xhtml#numbers_abc_proto_sec)、[第 13 章](ch13.xhtml#ifaces_prot_abc)中回到这个问题，该章专门讨论协议和 ABC 的对比。

实际上，如果您想为静态类型检查注释数值参数，您有几个选择:

1.  使用 PEP 488 推荐的混凝土类型`int`、`float`或`complex`。

2.  声明一个类似`Union[float, Decimal, Fraction]`的联合类型。

3.  如果你想避免硬编码具体类型，使用类似`SupportsFloat`的数字协议，在[“运行时可检查静态协议”](ch13.xhtml#runtime_checkable_proto_sec)中有介绍。

下一节“静态协议”是理解数字协议的先决条件。

同时，让我们来看看类型提示最有用的 ABC 之一:`Iterable`。

## 可迭代的

我刚刚引用的 [`typing.List`](https://fpy.li/8-20) 文档推荐使用`Sequence`和`Iterable`进行函数参数类型提示。

`Iterable`参数的一个例子出现在标准库中的`math.fsum`函数中:

```
def fsum(__seq: Iterable[float]) -> float:
```

# 存根文件和类型化项目

作为 Python 3.10 的，标准库没有标注，只有 Mypy、PyCharm 等。可以在[类型化的](https://fpy.li/8-26)项目中找到必要的类型提示，形式为*存根文件*:带*的特殊源文件。pyi* 扩展，有带注释的函数和方法签名，没有实现——很像 c 中的头文件。

`math.fsum`的签名在*/stdlib/2 and 3/math . pyi*](https://fpy.li/8-27)中。`__seq`中的前导下划线是 PEP 484 仅位置参数的约定，在[“仅注释位置和变量参数”中有解释。

示例 8-15 是另一个使用`Iterable`参数产生`tuple[str, str]`项目的示例。下面是该函数的使用方法:

```
>>> l33t = [('a', '4'), ('e', '3'), ('i', '1'), ('o', '0')]
>>> text = 'mad skilled noob powned leet'
>>> from replacer import zip_replace
>>> zip_replace(text, l33t)
'm4d sk1ll3d n00b p0wn3d l33t'
```

示例 8-15 展示了它是如何实现的。

##### 例 8-15。 *replacer.py*

```
fromcollections.abcimportIterableFromTo=tuple[str,str]![1](Images/1.png)defzip_replace(text:str,changes:Iterable[FromTo])->str:![2](Images/2.png)forfrom_,toinchanges:text=text.replace(from_,to)returntext
```

![1](Images/1.png)

`FromTo`是*类型别名*:我把`tuple[str, str]`赋给`FromTo`，是为了让`zip_replace`的签名更易读。

![2](Images/2.png)

`changes`需要是一个`Iterable[FromTo]`；那和`Iterable[tuple[str, str]]`一样，但是更短更易读。

# Python 3.10 中的显式 TypeAlias

[PEP 613—显式类型别名](https://fpy.li/pep613)引入了一个特殊的类型`TypeAlias`，使得创建类型别名的赋值更加可见，也更容易进行类型检查。从 Python 3.10 开始，这是创建类型别名的首选方式:

```
from typing import TypeAlias

FromTo: TypeAlias = tuple[str, str]
```

### abc。Iterable 对 abc。顺序

`math.fsum`和`replacer.zip_replace`都必须迭代整个`Iterable`参数以返回结果。给定一个无止境的 iterable，比如作为输入的`itertools.cycle`生成器，这些函数将消耗所有内存并使 Python 进程崩溃。尽管存在这种潜在的危险，但在现代 Python 中，提供接受`Iterable`输入的函数是相当常见的，即使它们必须完全处理输入才能返回结果。这使得调用者可以选择将输入数据作为生成器而不是预构建的序列来提供，如果输入项的数量很大，这可能会节省大量内存。

另一方面，来自示例 8-13 的`columnize`函数需要一个`Sequence`参数，而不是一个`Iterable`，因为它必须获得输入的`len()`来预先计算行数。

和`Sequence`一样，`Iterable`最好用作参数类型。作为返回类型太模糊了。一个函数应该更精确地描述它返回的具体类型。

与`Iterable`密切相关的是`Iterator`类型，在例 8-14 中用作返回类型。我们将在第 17 章回到这个话题，这是关于生成器和经典迭代器的。

## 参数化泛型和类型变量

一个 参数化泛型是一个泛型类型，写成`list[T]`，其中`T`是一个类型变量，每次使用都会绑定到一个特定的类型。这允许参数类型反映在结果类型上。

例 8-16 定义了`sample`，一个带两个参数的函数:一个`T`类型元素的`Sequence`，一个`int`。它返回从第一个参数中随机选取的相同类型`T`的`list`元素。

例 8-16 展示了实施过程。

##### 例 8-16。 *sample.py*

```
from collections.abc import Sequence
from random import shuffle
from typing import TypeVar

T = TypeVar('T')

def sample(population: Sequence[T], size: int) -> list[T]:
    if size < 1:
        raise ValueError('size must be >= 1')
    result = list(population)
    shuffle(result)
    return result[:size]
```

下面是我为什么在`sample`中使用类型变量的两个例子:

*   如果用一个类型为`tuple[int, ...]`的元组调用——这个元组的*与* `Sequence[int]`一致——那么类型参数就是`int`，所以返回类型就是`list[int]`。

*   如果用`str`——与 `Sequence[str]`一致的*——调用，那么类型参数为`str`，那么返回类型为`list[str]`。*

# 为什么需要 TypeVar？

PEP 484 的作者希望通过添加`typing`模块引入类型提示，而不改变语言中的任何其他内容。通过巧妙的元编程，他们可以让`[]`操作符在类似`Sequence[T]`的类上工作。但是括号内的`T`变量的名称必须在某个地方定义——否则 Python 解释器将需要更深层次的改变来支持作为`[]`特殊用法的泛型类型符号。这就是为什么需要`typing.TypeVar`构造函数的原因:在当前名称空间中引入变量名。Java、C#和 TypeScript 等语言不需要事先声明类型变量的名称，因此它们没有 Python 的`TypeVar`类的对等物。

另一个例子是标准库中的`statistics.mode`函数，它返回序列中最常见的数据点。

以下是来自[文档](https://fpy.li/8-28)的一个使用示例:

```
>>> mode([1, 1, 2, 3, 3, 3, 3, 4])
3
```

不使用`TypeVar`，`mode`可以有例 8-17 所示的签名。

##### 例 8-17。*mode _ float . py*:`mode`作用于`float`和子类型 ^([13](ch08.xhtml#idm46582442199104))

```
from collections import Counter
from collections.abc import Iterable

def mode(data: Iterable[float]) -> float:
    pairs = Counter(data).most_common(1)
    if len(pairs) == 0:
        raise ValueError('no mode for empty data')
    return pairs[0][0]
```

`mode`的很多用法都涉及到`int`或`float`值，但是 Python 还有其他数值类型，返回类型最好遵循给定`Iterable`的元素类型。我们可以使用`TypeVar`来改进这个签名。让我们从一个简单但错误的参数化签名开始:

```
from collections.abc import Iterable
from typing import TypeVar

T = TypeVar('T')

def mode(data: Iterable[T]) -> T:
```

当类型参数`T`第一次出现在签名中时，它可以是任何类型。第二次出现时，将表示与第一次相同的类型。

因此，每个可迭代对象都是*一致的——与* `Iterable[T]`一致，包括`collections.Counter`不能处理的不可迭代类型。我们需要限制分配给`T`的可能类型。在接下来的两节中，我们将看到两种方法。

### 受限类型变量

`TypeVar`接受额外的位置参数来限制类型参数。我们可以改进`mode`的签名以接受特定的数字类型，就像这样:

```
from collections.abc import Iterable
from decimal import Decimal
from fractions import Fraction
from typing import TypeVar

NumberT = TypeVar('NumberT', float, Decimal, Fraction)

def mode(data: Iterable[NumberT]) -> NumberT:
```

这比以前好多了，而且是 2020 年 5 月 25 日`typeshed`上[*statistics . pyi*](https://fpy.li/8-30)存根文件中`mode`的签名。

然而， [`statistics.mode`](https://fpy.li/8-28) 文档中包含了这个例子:

```
>>> mode(["red", "blue", "blue", "red", "green", "red", "red"])
'red'
```

很快，我们可以将`str`添加到`NumberT`的定义中:

```
NumberT = TypeVar('NumberT', float, Decimal, Fraction, str)
```

这当然行得通，但是如果接受了`str`，`NumberT`就名不副实了。更重要的是，我们不能永远列出类型，因为我们意识到`mode`可以处理它们。我们可以用接下来介绍的`TypeVar`的另一个特性做得更好。

### 有界类型变量

查看示例 8-17 中`mode`的主体，我们看到`Counter`类是用于排名的。计数器基于`dict`，因此`data` iterable 的元素类型必须是可散列的。

起初，这个签名可能看起来有用:

```
from collections.abc import Iterable, Hashable

def mode(data: Iterable[Hashable]) -> Hashable:
```

现在的问题是返回项的类型是`Hashable`:一个只实现了`__hash__`方法的 ABC。所以类型检查器不允许我们对返回值做任何事情，除了对它调用`hash()`。不是很有用。

解决方法是`TypeVar`的另一个可选参数:`bound`关键字参数。它为可接受的类型设置了一个上限。在例 8-18 中，我们有`bound=Hashable`，这意味着类型参数可能是`Hashable`或的任何*子类型。 ^([14](ch08.xhtml#idm46582441836224))*

##### 例 8-18。*mode _ has shable . py*:同例 8-17 ，签名更灵活

```
from collections import Counter
from collections.abc import Iterable, Hashable
from typing import TypeVar

HashableT = TypeVar('HashableT', bound=Hashable)

def mode(data: Iterable[HashableT]) -> HashableT:
    pairs = Counter(data).most_common(1)
    if len(pairs) == 0:
        raise ValueError('no mode for empty data')
    return pairs[0][0]
```

总结一下:

*   受限类型变量将被设置为`TypeVar`声明中命名的类型之一。

*   有界类型变量将被设置为表达式的推断类型——只要推断类型与`TypeVar`的`bound=`关键字参数中声明的边界*一致。*

###### 注意

不幸的是，声明有界的`TypeVar`的关键字参数被命名为`bound=`，因为动词“绑定”通常用于表示设置变量的值，这在 Python 的参考语义中最好描述为将名称绑定到值。如果关键字参数被命名为`boundary=`，就不会那么混乱了。

`typing.TypeVar`构造器还有其他可选参数——`covariant`和`contravariant`——我们将在[第 15 章](ch15.xhtml#more_types_ch)、[“方差”](ch15.xhtml#variance_sec)中介绍。

让我们以`AnyStr`来结束这个对`TypeVar`的介绍。

### AnyStr 预定义类型变量

`typing`模块包含一个名为`AnyStr`的预定义`TypeVar`。它是这样定义的:

```
AnyStr = TypeVar('AnyStr', bytes, str)
```

`AnyStr`用于许多接受`bytes`或`str`的函数中，并返回给定类型的值。

现在，我们来看一下`typing.Protocol`，这是 Python 3.8 的一个新特性，可以支持更多 Python 式的类型提示。

## 静态协议

###### 注意

在 面向对象编程中，作为非正式接口的“协议”的概念和 Smalltalk 一样古老，从一开始就是 Python 必不可少的一部分。然而，在类型提示的上下文中，协议是一个`typing.Protocol`子类，它定义了类型检查器可以验证的接口。两种协议都包含在第 13 章中。这只是在函数注释的上下文中的简单介绍。

`Protocol`类型，如[PEP 544-Protocols:Structural subtyping(static duck typing)](https://fpy.li/pep544)中所示，类似于 Go 中的接口:通过指定一个或多个方法来定义协议类型，类型检查器验证这些方法是否在需要该协议类型的地方实现。

在 Python 中，协议定义被写成一个`typing.Protocol`子类。然而，*实现* a 协议的类不需要继承、注册或声明与*定义*该协议的类的任何关系。由类型检查器来发现可用的协议类型并强制使用它们。

这里有一个问题可以借助`Protocol`和`TypeVar`解决。假设您想要创建一个函数`top(it, n)`，它返回可迭代`it`的最大`n`元素:

```
>>> top([4, 1, 5, 2, 6, 7, 3], 3)
[7, 6, 5]
>>> l = 'mango pear apple kiwi banana'.split()
>>> top(l, 3)
['pear', 'mango', 'kiwi']
>>>
>>> l2 = [(len(s), s) for s in l]
>>> l2
[(5, 'mango'), (4, 'pear'), (5, 'apple'), (4, 'kiwi'), (6, 'banana')]
>>> top(l2, 3)
[(6, 'banana'), (5, 'mango'), (5, 'apple')]
```

一个参数化的泛型`top`看起来会像示例 8-19 中所示的那样。

##### 例 8-19。 `top`函数带有未定义的`T`类型参数

```
def top(series: Iterable[T], length: int) -> list[T]:
    ordered = sorted(series, reverse=True)
    return ordered[:length]
```

问题是如何约束`T`？不能是`Any`或者`object`，因为`series`必须和`sorted`配合工作。内置的`sorted`实际上接受了`Iterable[Any]`，但那是因为可选参数`key`接受了一个函数，该函数从每个元素中计算任意的排序关键字。如果给了`sorted`一个普通对象的列表，但没有提供`key`参数，会发生什么？让我们试试:

```
>>> l = [object() for _ in range(4)]
>>> l
[<object object at 0x10fc2fca0>, <object object at 0x10fc2fbb0>,
<object object at 0x10fc2fbc0>, <object object at 0x10fc2fbd0>]
>>> sorted(l)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '<' not supported between instances of 'object' and 'object'
```

错误消息显示`sorted`在 iterable 的元素上使用了`<`操作符。这就够了吗？我们再做一个快速实验: ^([15](ch08.xhtml#idm46582441439040))

```
>>> class Spam:
...     def __init__(self, n): self.n = n
...     def __lt__(self, other): return self.n < other.n
...     def __repr__(self): return f'Spam({self.n})'
...
>>> l = [Spam(n) for n in range(5, 0, -1)]
>>> l
[Spam(5), Spam(4), Spam(3), Spam(2), Spam(1)]
>>> sorted(l)
[Spam(1), Spam(2), Spam(3), Spam(4), Spam(5)]
```

这证实了:我可以`sort`一个`Spam`列表，因为`Spam`实现了`__lt__`——支持`<`操作符的特殊方法。

所以例 8-19 中的`T`类型参数应该仅限于实现`__lt__`的类型。在示例 8-18 中，我们需要一个实现`__hash__`的类型参数，所以我们能够使用`typing.Hashable`作为类型参数的上限。但是现在在`typing`或`abc`中没有合适的类型可以使用，所以我们需要创建它。

例 8-20 为新型`SupportsLessThan`a`Protocol`。

##### 例 8-20。 *comparable.py* :一个`SupportsLessThan` `Protocol`类型的定义

```
fromtypingimportProtocol,AnyclassSupportsLessThan(Protocol):![1](Images/1.png)def__lt__(self,other:Any)->bool:...![2](Images/2.png)
```

![1](Images/1.png)

协议是`typing.Protocol`的子类。

![2](Images/2.png)

协议的主体有一个或多个方法定义，在它们的主体中有`...`。

类型`T`是*一致的——如果`T`实现了`P`中定义的所有方法，并且具有匹配的类型签名，那么协议`P`与类型*一致。

给定`SupportsLessThan`，我们现在可以在示例 8-21 中定义`top`的工作版本。

##### 例 8-21。 *top.py* :使用`TypeVar`和`bound=SupportsLessThan`定义`top`功能

```
from collections.abc import Iterable
from typing import TypeVar

from comparable import SupportsLessThan

LT = TypeVar('LT', bound=SupportsLessThan)

def top(series: Iterable[LT], length: int) -> list[LT]:
    ordered = sorted(series, reverse=True)
    return ordered[:length]
```

让我们试驾一下`top`。示例 8-22 显示了与`pytest`一起使用的测试套件的一部分。它尝试首先用一个生成`tuple[int, str]`的生成器表达式调用`top`，然后用一个`object`列表。有了`object`的列表，我们期望得到一个`TypeError`异常。

##### 例 8-22。 *top_test.py* :部分`top`的测试套件列表

```
fromcollections.abcimportIteratorfromtypingimportTYPE_CHECKING![1](Images/1.png)importpytestfromtopimporttop# several lines omitteddeftest_top_tuples()->None:fruit='mango pear apple kiwi banana'.split()series:Iterator[tuple[int,str]]=(![2](Images/2.png)(len(s),s)forsinfruit)length=3expected=[(6,'banana'),(5,'mango'),(5,'apple')]result=top(series,length)ifTYPE_CHECKING:![3](Images/3.png)reveal_type(series)![4](Images/4.png)reveal_type(expected)reveal_type(result)assertresult==expected# intentional type errordeftest_top_objects_error()->None:series=[object()for_inrange(4)]ifTYPE_CHECKING:reveal_type(series)withpytest.raises(TypeError)asexcinfo:top(series,3)![5](Images/5.png)assert"'<' not supported"instr(excinfo.value)
```

![1](Images/1.png)

`typing.TYPE_CHECKING`常量在运行时总是`False`，但是类型检查器在进行类型检查时会假装它是`True`。

![2](Images/2.png)

`series`变量的显式类型声明，使 Mypy 输出更容易阅读。 ^([16](ch08.xhtml#idm46582440867904))

![3](Images/3.png)

这个`if`在测试运行时阻止接下来的三行代码的执行。

![4](Images/4.png)

`reveal_type()`不能在运行时调用，因为它不是一个常规函数，而是一个 Mypy 调试工具——这就是为什么它没有`import`。Mypy 将为每个`reveal_type()`伪函数调用输出一条调试消息，显示参数的推断类型。

![5](Images/5.png)

这一行将被 Mypy 标记为错误。

前面的测试通过了——但是不管有没有 *top.py* 中的类型提示，它们都会通过。更重要的是，如果我用 Mypy 检查测试文件，我会看到`TypeVar`正在按预期工作。参见例 8-23 中的`mypy`命令输出。

###### 警告

从 Mypy 0.910(2021 年 7 月)开始，`reveal_type`的输出在某些情况下不能精确显示我声明的类型，而是显示兼容的类型。比如我没有用`typing.Iterator`而是用了`abc.Iterator`。请忽略这个细节。Mypy 输出仍然有用。在讨论输出时，我将假装 Mypy 的这个问题已经解决。

##### 例 8-23。输出 *mypy top_test.py* (为了可读性，行被分割)

```
…/comparable/ $ mypy top_test.py
top_test.py:32: note:
    Revealed type is "typing.Iterator[Tuple[builtins.int, builtins.str]]" ![1](Images/1.png)
top_test.py:33: note:
    Revealed type is "builtins.list[Tuple[builtins.int, builtins.str]]"
top_test.py:34: note:
    Revealed type is "builtins.list[Tuple[builtins.int, builtins.str]]" ![2](Images/2.png)
top_test.py:41: note:
    Revealed type is "builtins.list[builtins.object*]" ![3](Images/3.png)
top_test.py:43: error:
    Value of type variable "LT" of "top" cannot be "object"  ![4](Images/4.png)
Found 1 error in 1 file (checked 1 source file)
```

![1](Images/1.png)

在`test_top_tuples`中，`reveal_type(series)`显示它是一个`Iterator[tuple[int, str]]`——我已经明确声明了。

![2](Images/2.png)

`reveal_type(result)`确认`top`调用返回的类型是我想要的:给定`series`的类型，`result`就是`list[tuple[int, str]]`。

![3](Images/3.png)

在`test_top_objects_error`中，`reveal_type(series)`显示它是`list[object*]`。Mypy 在任何被推断的类型后加上一个`*`:在这个测试中我没有注释`series`的类型。

![4](Images/4.png)

Mypy 标记了这个测试有意触发的错误:`Iterable` `series`的元素类型不能是`object`(它必须是类型`SupportsLessThan`)。

协议类型相对于 ABCs 的一个关键优势是，一个类型不需要任何特殊的声明来与协议类型保持*一致。这允许利用预先存在的类型或者在我们不控制的代码中实现的类型来创建协议。我不需要派生或者注册`str`、`tuple`、`float`、`set`等。用`SupportsLessThan`在需要`SupportsLessThan`参数的地方使用它们。他们只需要实现`__lt__`。类型检查器仍然能够完成它的工作，因为`SupportsLessThan`被显式定义为`Protocol`——与 duck 类型化常见的隐式协议形成对比，后者对于类型检查器是不可见的。*

特殊的`Protocol`类是在PEP 544—协议:结构子类型(静态鸭类型)](https://fpy.li/pep544)中引入的。[示例 8-21 演示了为什么这个特性被称为*静态鸭类型化*:注释`top`的`series`参数的解决方案是说“只要实现了`__lt__`方法，`series`的名义类型并不重要。”Python 的鸭子类型总是允许我们隐式地这么说，让静态类型检查器无所适从。类型检查器无法读取 C 中的 CPython 源代码，或者执行控制台实验来发现`sorted`只要求元素支持`<`。

现在我们可以为静态类型检查器显式设置 duck 类型。这也是为什么说`typing.Protocol`给我们*静态鸭分型*是有道理的。 ^([17](ch08.xhtml#idm46582440752416))

关于`typing.Protocol`还有更多可以看的。我们将在第四部分回到这个话题，第 13 章对比了结构化类型、duck 类型和 ABCs——另一种形式化协议的方法。另外，[“重载签名”](ch15.xhtml#overload_sec) ( [第 15 章](ch15.xhtml#more_types_ch))解释了如何用`@typing.overload`声明重载函数签名，并包含了一个使用`typing.Protocol`和有界`TypeVar`的扩展示例。

###### 注意

`typing.Protocol`可以对“类型由支持的操作定义”中的`double`函数进行注释，而不会失去功能。关键是用`__mul__`方法定义一个协议类。我邀请你这样做作为练习。解决方法出现在[“类型化双功能”](ch13.xhtml#typed_double_sec) ( [第 13 章](ch13.xhtml#ifaces_prot_abc))。

## 请求即付的

为了 注释回调参数或者高阶函数返回的可调用对象，`collections.abc`模块提供了`Callable`类型，对于还没有使用 Python 3.9 的人，可以在`typing`模块中使用。一个`Callable`类型是这样参数化的:

```
Callable[[ParamType1, ParamType2], ReturnType]
```

参数列表—`[ParamType1, ParamType2]`—可以有零个或多个类型。

下面是一个`repl`函数的例子，它是我们将在[“lis . py 中的模式匹配:案例研究”](ch18.xhtml#pattern_matching_case_study_sec) : ^([18](ch08.xhtml#idm46582440727296)) 中看到的简单交互式解释器的一部分

```
def repl(input_fn: Callable[[Any], str] = input]) -> None:
```

在正常使用过程中，`repl`函数使用 Python 的`input`内置来读取用户的表达式。然而，为了自动化测试或者与其他输入源集成，`repl`接受一个可选的`input_fn`参数:一个与`input`具有相同参数和返回类型的`Callable`。

内置`input`在 typeshed 上有这样的签名:

```
def input(__prompt: Any = ...) -> str: ...
```

`input`签名与*一致——与*本`Callable`类型提示一致:

```
Callable[[Any], str]
```

没有注释可选或关键字参数类型的语法。`typing.Callable`的[文档](https://fpy.li/8-34)说“这样的函数类型很少用作回调类型。”如果您需要类型提示来匹配具有灵活签名的函数，请用`...`替换整个参数列表—如下所示:

```
Callable[..., ReturnType]
```

泛型类型参数与类型层次结构的交互引入了一个新的类型概念:方差。

### 可调用类型的差异

想象一个具有简单`update`功能的温度控制系统，如示例 8-24 所示。`update`函数调用`probe`函数获取当前温度，调用`display`将温度显示给用户。出于教导的原因，`probe`和`display`都被作为参数传递给`update`。该示例的目标是对比两个`Callable`注释:一个具有返回类型，另一个具有参数类型。

##### 例 8-24。举例说明方差。

```
fromcollections.abcimportCallabledefupdate(![1](Images/1.png)probe:Callable[[],float],![2](Images/2.png)display:Callable[[float],None]![3](Images/3.png))->None:temperature=probe()# imagine lots of control code heredisplay(temperature)defprobe_ok()->int:![4](Images/4.png)return42defdisplay_wrong(temperature:int)->None:![5](Images/5.png)print(hex(temperature))update(probe_ok,display_wrong)# type error ![6](Images/6.png)defdisplay_ok(temperature:complex)->None:![7](Images/7.png)print(temperature)update(probe_ok,display_ok)# OK ![8](Images/8.png)
```

![1](Images/1.png)

`update`接受两个调用作为参数。

![2](Images/2.png)

`probe`必须是不接受参数并返回`float`的可调用函数。

![3](Images/3.png)

`display`接受一个`float`参数并返回`None`。

![4](Images/4.png)

`probe_ok`是否与 `Callable[[], float]`一致，因为返回一个`int`不会破坏期望一个`float`的代码。

![5](Images/5.png)

`display_wrong`与*不一致——与*和`Callable[[float], None]`不一致，因为不能保证一个期待`int`的函数能够处理一个`float`；例如，Python 的`hex`函数接受一个`int`，但拒绝一个`float`。

![6](Images/6.png)

Mypy 标记这一行，因为`display_wrong`与`update`的`display`参数中的类型提示不兼容。

![7](Images/7.png)

`display_ok`与*一致——与* `Callable[[float], None]`一致，因为接受`complex`的函数也可以处理`float`参数。

![8](Images/8.png)

Mypy 对这条线很满意。

总而言之，当代码期望回调返回`float`时，提供一个返回`int`的回调是可以的，因为在期望`float`的地方总是可以使用`int`值。

形式上，我们说`Callable[[], int]`是 `Callable[[], float]`的*子类型——正如`int`是* `float`的*子类型一样。这意味着`Callable`在返回类型上是*协变的*，因为类型`int`和`float`的*关系的*子类型与使用它们作为返回类型的`Callable`类型的关系方向相同。*

另一方面，当需要处理`float`的回调时，提供采用`int`参数的回调是一种类型错误。

形式上，`Callable[[int], None]`不是*的子类型——属于*的`Callable[[float], None]`。虽然`int`是*子类型-属于*T3，但是在参数化的`Callable`类型中，关系是相反的:`Callable[[float], None]`是的*子类型-属于`Callable[[int], None]`。因此我们说`Callable`在声明的参数类型上是*逆变*。*

[](ch15.xhtml#variance_sec)[第 15 章](ch15.xhtml#more_types_ch)中的【方差】用不变、协变和逆变类型的更多细节和例子解释了方差。

###### 小费

现在，请放心，大多数参数化的泛型类型都是*不变的*，因此更简单。例如，如果我声明了`scores: list[float]`，这就告诉了我可以给`scores`赋值什么。我不能分配声明为`list[int]`或`list[complex]`的对象:

*   一个`list[int]`对象是不可接受的，因为它不能保存我的代码可能需要放入`scores`的`float`值。

*   一个`list[complex]`对象是不可接受的，因为我的代码可能需要对`scores`进行排序以找到中间值，但是`complex`没有提供`__lt__`，因此`list[complex]`是不可排序的。

现在我们来看本章将要讨论的最后一种特殊类型。

## 无回报

这个 是一个特殊的类型，只用来注释从不返回的函数的返回类型。通常，它们的存在是为了引发异常。标准库中有几十个这样的函数。

例如，`sys.exit()`引发`SystemExit`来终止 Python 进程。

它在`typeshed`中的签名是:

```
def exit(__status: object = ...) -> NoReturn: ...
```

`__status`参数只是位置性的，它有一个默认值。存根文件不拼写默认值，而是使用`...`。`__status`的类型是`object`，这意味着它也可能是`None`，因此标注`Optional[object]`是多余的。

在[第 24 章](ch24.xhtml#class_metaprog)中，[例 24-6](ch24.xhtml#checked_class_bottom_ex) 使用了`__flag_unknown_attrs`中的`NoReturn`，这种方法旨在产生一个用户友好且全面的错误信息，然后引发`AttributeError`。

这一章的最后一节是关于位置和变量参数的。

# 仅注释位置参数和变量参数

从[例 7-9](ch07.xhtml#tagger_ex) 中回忆 的`tag`功能。我们最后一次看到它的签名是在[“仅位置参数”](ch07.xhtml#positional_only_params):

```
def tag(name, /, *content, class_=None, **attrs):
```

下面是`tag`，完整的注释，写在几行中——长签名的常见约定，换行方式是 [*蓝色*](https://fpy.li/8-10) 格式化程序会做的:

```
from typing import Optional

def tag(
    name: str,
    /,
    *content: str,
    class_: Optional[str] = None,
    **attrs: str,
) -> str:
```

注意任意位置参数的类型提示`*content: str`；这意味着所有这些参数都必须是类型`str`。函数体中的`content`局部变量的类型将是`tuple[str, ...]`。

在这个例子中，任意关键字参数的类型提示是`**attrs: str`，因此函数中`attrs`的类型将是`dict[str, str]`。对于类似`**attrs: float`的类型提示，函数中`attrs`的类型将是 `dict[str, float]`。’

如果`attrs`参数必须接受不同类型的值，您需要使用`Union[]`或`Any` : `**attrs: Any`。

仅位置参数的`/`符号仅在 Python 3.8 版本中可用。在 Python 3.7 或更早版本中，这是一个语法错误。PEP 484 惯例是在每个只有位置的参数名前加两个下划线。这里是`tag`签名，现在是两行，使用 PEP 484 约定:

```
from typing import Optional

def tag(__name: str, *content: str, class_: Optional[str] = None,
        **attrs: str) -> str:
```

Mypy 理解并实施声明仅位置参数的两种方式。

为了结束这一章，让我们简要地考虑一下类型提示的限制和它们支持的静态类型系统。

# 不完善的打字和强测试

大型公司代码库的维护者 报告说，许多错误是由静态类型检查器发现的，并且比在代码在生产中运行后才被发现要便宜得多。然而，重要的是要注意，在我所知道的公司引入静态类型之前，自动化测试是标准的实践并被广泛采用。

即使在它们最有益的环境中，静态类型也不能作为正确性的最终仲裁者。不难发现:

False positives

工具报告正确代码的类型错误。

False negatives

工具不会报告不正确代码的类型错误。

此外，如果我们被迫对所有内容进行类型检查，我们就会失去 Python 的一些表达能力:

*   有些得心应手的功能无法进行静态检查；比如像`config(**settings)`这样的参数解包。

*   对于类型检查器来说，像属性、描述符、元类和元编程这样的高级特性通常得不到很好的支持或者难以理解。

*   类型检查器落后于 Python 版本，在分析具有新语言特性的代码时会拒绝甚至崩溃——在某些情况下超过一年。

常见的数据约束不能在类型系统中表达——即使是简单的数据约束。例如，类型提示无法确保“数量必须是大于 0 的整数”或“标签必须是由 6 到 12 个 ASCII 字母组成的字符串”通常，类型提示对于捕捉业务逻辑中的错误没有帮助。

鉴于这些警告，类型提示不能成为软件质量的支柱，毫无例外地强制使用它们会放大缺点。

将静态类型检查器视为现代 CI 管道中的工具之一，还有测试运行器、linters 等。CI 管道的目的是减少软件故障，自动化测试可以捕捉到许多类型提示无法捕捉到的错误。任何可以用 Python 编写的代码，都可以用 Python 测试——有或没有类型提示。

###### 注意

本节的标题和结论受到了布鲁斯·埃凯尔的文章[“强类型与强测试”](https://fpy.li/8-37)的启发，该文章也发表在由乔尔·斯波尔斯基(Apress)编辑的选集 [*《最佳软件写作 I*](https://fpy.li/8-38) 》中。Bruce 是 Python 的粉丝，也是关于 C++、Java、Scala 和 Kotlin 的书籍的作者。在那篇文章中，他讲述了在学习 Python 之前，他是一个静态类型的倡导者，并总结道:“如果 Python 程序有足够的单元测试，它就可以像有足够单元测试的 C++、Java 或 C#程序一样健壮(尽管用 Python 编写测试会更快)。”

这就结束了我们对 Python 类型提示的讨论。它们也是第 15 章的主要焦点，其中涵盖了泛型类、方差、重载签名、类型转换等等。同时，类型提示将在整本书的几个例子中客串出现。

# 章节摘要

我们 从简单介绍渐进打字的概念开始，然后切换到动手操作的方法。如果没有一个真正读取类型提示的工具，很难看出渐进键入是如何工作的，所以我们开发了一个由 Mypy 错误报告指导的带注释的函数。

回到逐步类型化的想法，我们探索了它是如何混合 Python 的传统 duck 类型化和 Java、C++和其他静态类型化语言的用户更熟悉的名义类型化的。

这一章的大部分时间都在介绍注释中使用的主要类型组。我们讨论的许多类型都与我们熟悉的 Python 对象类型有关，比如集合、元组和可调用对象——它们被扩展以支持像`Sequence[float]`这样的通用符号。在 Python 3.9 中标准类型被更改为支持泛型之前，这些类型中的许多都是在`typing`模块中实现的临时代理。

有些类型是特殊的实体。`Any`、`Optional`、`Union`、`NoReturn`与内存中的实际对象无关，只存在于类型系统的抽象域中。

我们研究了参数化泛型和类型变量，它们给类型提示带来了更多的灵活性，而没有牺牲类型安全性。

随着`Protocol`的使用，参数化泛型变得更有表现力。因为它只出现在 Python 3.8 中，`Protocol`还没有被广泛使用——但是它非常重要。`Protocol`支持静态 duck 类型:Python 的 duck 类型核心和允许静态类型检查器捕捉 bug 的名义类型之间的重要桥梁。

在介绍其中一些类型时，我们用 Mypy 进行了实验，在 Mypy 的神奇的`reveal_type()`函数的帮助下，查看类型检查错误和推断类型。

最后一节讲述了如何注释仅位置参数和可变参数。

类型提示是一个复杂且不断发展的话题。幸运的是，它们是可选的功能。让我们让尽可能多的用户能够访问 Python，不要再鼓吹所有的 Python 代码都应该有类型提示——就像我在公开布道中看到的那样，键入布道者。

我们的 BDFL ^([19](ch08.xhtml#idm46582440036816)) 退休领导了这种对 Python 中类型提示的推动，所以这一章以他的话开始和结束才是公平的:

> 我不喜欢在 Python 的某个版本中，我在道德上有义务一直添加类型提示。我真的认为类型提示有它的位置，但也有很多时候不值得，它是如此美妙，你可以选择使用它们。 ^([20](ch08.xhtml#idm46582440034576))
> 
> 吉多·范·罗苏姆

# 进一步阅读

Bernát Gábor 在他的优秀帖子[“Python 中类型提示的状态”](https://fpy.li/8-41)中写了 :

> 只要单元测试值得编写，就应该使用类型提示。

我是测试的忠实粉丝，但我也做很多探索性的编码。当我在探索的时候，测试和类型提示是没有帮助的。他们是个累赘。

Gábor 的帖子是我发现的对 Python 的类型提示的最好介绍之一，还有 Geir Arne Hjelle 的[“Python 类型检查(指南)》](https://fpy.li/8-42)。Claudio Jolowicz 的“Hypermodern Python 第 4 章:类型化”是一个更简短的介绍，它也涵盖了运行时类型检查验证。

对于更深入的报道， [Mypy 文档](https://fpy.li/8-44)是最好的来源。不管您使用什么类型检查器，它都是有价值的，因为它有关于 Python 类型的一般教程和参考页面，而不仅仅是关于 Mypy 工具本身。在那里你还会找到一个方便的[备忘单](https://fpy.li/8-45)和一个非常有用的关于[常见问题和解决方案](https://fpy.li/8-46)的页面。

[`typing`](https://fpy.li/typing) 模块文档是一个很好的快速参考，但它并不涉及太多细节。[PEP 483—类型提示理论](https://fpy.li/pep483)包含了关于方差的深度解释，使用`Callable`来说明逆变。最终的参考是与打字相关的 PEP 文档。已经有 20 多个了。pep 的目标受众是 Python 核心开发人员和 Python 指导委员会，因此他们假设了大量的先验知识，并且肯定不是轻松读物。

如上所述，[第 15 章](ch15.xhtml#more_types_ch)涵盖了更多的打字主题，[“进一步阅读”](ch15.xhtml#more_type_hints_further_sec)提供了额外的参考资料，包括[表 15-1](ch15.xhtml#typing_peps_tbl) ，列出了截至 2021 年末已批准或正在讨论的打字 pep。

[“牛逼的 Python 打字”](https://fpy.li/8-47)是一个有价值的工具和参考链接集合。

^([1](ch08.xhtml#idm46582445964528-marker))PEP 484—类型提示，“理与目标”；原文中保留的粗体强调。

PyPy 中的即时编译器比类型提示有更好的数据:它在 Python 程序运行时监视它，检测使用中的具体类型，并为这些具体类型生成优化的机器码。

^([3](ch08.xhtml#idm46582445926464-marker)) 例如，截至 2021 年 7 月不支持递归类型—参见`typing`模块发布 [#182，定义一个 JSON 类型](https://fpy.li/8-2)和 Mypy 发布 [#731，支持递归类型](https://fpy.li/8-3)。

^([4](ch08.xhtml#idm46582445234336-marker)) Python 不提供语法来控制一个类型的可能值集——除了在`Enum`类型中。例如，使用类型提示，您不能将`Quantity`定义为 1 到 1000 之间的整数，或者将`AirportCode`定义为 3 个字母的组合。NumPy 提供了`uint8`、`int16`和其他面向机器的数值类型，但是在 Python 标准库中我们只有非常小的值集合(`NoneType`、`bool`)或者非常大的集合(`float`、`int`、`str`)、所有可能的元组等类型。).

^(5](ch08.xhtml#idm46582445162944-marker)) 鸭类型化是*结构类型化*的隐式形式，Python ≥ 3.8 随着`typing.Protocol`的引入也支持。这将在本章后面的[“静态协议”中介绍，更多的细节在第 13 章的 [中介绍。](ch13.xhtml#ifaces_prot_abc)

^([6](ch08.xhtml#idm46582445123568-marker)) 在现实而简单的例子中，遗传经常被过度使用并且难以证明，所以请接受这个动物例子作为子类型的快速说明。

^([7](ch08.xhtml#idm46582444453504-marker)) 麻省理工学院教授，编程语言设计师，图灵奖获得者。维基百科:[芭芭拉·利斯科夫](https://fpy.li/8-14)。

^([8](ch08.xhtml#idm46582444129504-marker)) 更准确的说，`ord`只接受带`len(s) == 1`的`str`或`bytes`。但是类型系统目前还不能表达这种约束。

在 ABC——对 Python 的最初设计影响最大的语言——中，每个列表都被约束为接受单一类型的值:你放入的第一个条目的类型。

^([10](ch08.xhtml#idm46582443707504-marker)) 我对`typing`模块文档的贡献之一是，在 Guido van Rossum 的监督下，当我将[“模块内容”](https://fpy.li/8-17)下面的条目重新组织成子节时，添加了几十个反对警告。

^([11](ch08.xhtml#idm46582442856960-marker)) 我在几个例子中有意义的时候会用`:=`，但我不会在书中涉及。请参见[PEP 572—赋值表达式](https://fpy.li/pep572)了解所有血淋淋的细节。

^([12](ch08.xhtml#idm46582442746032-marker)) 其实，`dict`是`abc.MutableMapping`的虚子类。虚拟子类的概念在第 13 章中解释。目前，知道`issubclass(dict, abc.MutableMapping)`是`True`，尽管事实上`dict`是在 C 中实现的，并没有从`abc.MutableMapping`继承任何东西，而只是从`object`继承。

^([13](ch08.xhtml#idm46582442199104-marker)) 这里的实现比 Python 标准库 [`statistics`](https://fpy.li/8-29) 模块中的实现简单。

^([14](ch08.xhtml#idm46582441836224-marker)) 我把这个解决方案贡献给了`typeshed`，这就是`mode`在[*statistics . pyi*](https://fpy.li/8-32)上的注解截至 2020 年 5 月 26 日。

^([15](ch08.xhtml#idm46582441439040-marker)) 像我刚刚做的那样，打开一个交互控制台，依靠鸭子打字探索语言特性，是多么美妙的事情。当我使用不支持这种探索的语言时，我非常怀念这种探索。

^([16](ch08.xhtml#idm46582440867904-marker)) 如果没有这种类型提示，Mypy 会将`series`的类型推断为`Generator[Tuple[builtins.int, builtins.str*], None, None]`，这很冗长，但*与* `Iterator[tuple[int, str]]`一致，正如我们将在[“泛型可迭代类型”](ch17.xhtml#generic_iterable_types_sec)中看到的。

^([17](ch08.xhtml#idm46582440752416-marker)) 我不知道是谁发明了这个术语 *static duck typing* ，但它随着 Go 语言变得更加流行，它的接口语义更像 Python 的协议，而不是 Java 的名义接口。

^([18](ch08.xhtml#idm46582440727296-marker)) REPL 代表读取-评估-打印-循环，交互式解释器的基本行为。

^([19](ch08.xhtml#idm46582440036816-marker)) “仁慈的终身独裁者”参见吉多·范·范罗森关于[“BDFL 的起源”](https://fpy.li/bdfl)。

^([20](ch08.xhtml#idm46582440034576-marker)) 来自 YouTube 视频，[《吉多·范·罗苏姆的类型提示(2015 年 3 月)》](https://fpy.li/8-39)。报价从 [13'40"](https://fpy.li/8-40) 开始。为了清晰起见，我做了一些轻微的编辑。

^([21](ch08.xhtml#idm46582439972464-marker)) 来源:[《与艾伦·凯的对话》](https://fpy.li/8-54)。