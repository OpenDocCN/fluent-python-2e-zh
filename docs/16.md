<link href="Styles/Style00.css" rel="stylesheet" type="text/css"> <link href="Styles/Style01.css" rel="stylesheet" type="text/css"> 

# 第十三章。接口、协议和 ABC

> 编程到接口，而不是实现。
> 
> 伽马、赫尔姆、约翰逊、Vlissides、面向对象设计的第一原理^(T5 1)

面向对象的编程都是关于接口的。理解 Python 中的类型的最好方法是了解它提供的方法——它的接口——正如在“类型由支持的操作定义” ( 第 8 章)中所讨论的。

根据编程语言的不同，我们有一种或多种定义和使用接口的方法。从 Python 3.8 开始，我们有四种方式。在 *分型图* ( 图 13-1 )中有描述。我们可以这样总结它们:

Duck typing

Python 的默认从头开始输入。从《T21》第一章开始，我们就一直在学习鸭子打字。

Goose typing

从 Python 2.6 开始，抽象基类(ABCs)支持方法，它依赖于针对 ABCs 的对象运行时检查。*鹅分型*是本章的一大主题。

Static typing

静态类型语言的传统方法，如 C 和 Java 从 Python 3.5 开始由`typing`模块支持，并由符合PEP 484—类型提示](https://fpy.li/pep484)的外部类型检查器强制执行。这不是本章的主题。大部分[第 8 章和即将到来的第 15 章都是关于静态打字的。

Static duck typing

Go 语言流行的一种方法；由`typing.Protocol`的子类支持 Python 3.8 中的新特性——也由外部类型检查器执行。我们首先在《静态协议》 ( 第八章)中看到了这一点。

# 打字地图

图 13-1 中描绘的四种打字方法是互补的:它们各有利弊。不考虑他们中的任何一个都没有意义。

![Four approaches to type checking](Images/flpy_1301.png)

###### 图 13-1。上半部分描述了仅使用 Python 解释器的运行时类型检查方法；底层需要一个外部静态类型检查器，比如 MyPy，或者一个 IDE，比如 PyCharm。左边象限包括基于对象结构的类型——即，由对象提供的方法，不管它的类或超类的名称；右象限依赖于具有显式命名类型的对象:对象的类名或其超类名。

这四种方法中的每一种都依赖于接口来工作，但是静态类型可以完成——很差——只使用具体类型而不是接口抽象，如协议和抽象基类。这一章是关于 duck 类型化、goose 类型化和 static duck 类型化——围绕接口的类型化规则。

本章 分为四个主要部分，分别针对打字图中四个象限中的三个(图 13-1 ):

*   “两种协议”将两种形式的结构分型与协议进行比较——即分型图的左侧。

*   “编程鸭子”深入探讨 Python 通常的鸭子类型，包括如何在保留其主要优势:灵活性的同时使其更加安全。

*   “Goose Typing”解释了使用 ABCs 进行更严格的运行时类型检查。这是最长的一节，不是因为它更重要，而是因为在本书的其他地方有更多关于 duck 类型、静态 duck 类型和静态类型的章节。

*   “静态协议”涵盖了`typing.Protocol`子类的使用、实现和设计——对静态和运行时类型检查有用。

# 本章的新内容

这一章 经过了大量编辑，比第一版 *Fluent Python* 中相应的第 11 章长了约 24%。虽然有些部分和许多段落是相同的，但有很多新的内容。以下是亮点:

*   章节介绍和打字图(图 13-1 )是新的。这是本章中大多数新内容的关键——以及所有其他与 Python ≥ 3.8 中的类型相关的章节。

*   “两种协议”解释动态和静态协议的异同。

*   “防御性编程和‘快速失败’”大部分复制了第一版的内容，但进行了更新，现在有了一个部分标题来突出其重要性。

*   “静态协议”都是新的。它建立在“静态协议” ( 第 8 章)的最初介绍的基础上。

*   更新了图 13-2 、 13-3 和 13-4 中的`collections.abc`类图，以包括来自 Python 3.6 的`Collection` ABC。

第一版的 *Fluent Python* 有一节鼓励使用`numbers`ABC 进行 goose 打字。在“数字 ABC 和数字协议”中，我解释了如果您计划使用静态类型检查器以及 goose 类型的运行时检查，为什么您应该使用来自`typing`模块的数字静态协议。

# 两种协议

字*协议*在计算机科学中根据上下文有不同的含义。HTTP 等网络协议规定了客户端可以发送给服务器的命令，如`GET`、`PUT`和`HEAD`。我们在“协议和鸭子类型”中看到，对象协议指定了对象必须提供的方法来完成角色。第 1 章中的`FrenchDeck`示例演示了一个对象协议，即序列协议:允许 Python 对象表现为序列的方法。

实现一个完整的协议可能需要几种方法，但通常只实现一部分就可以了。考虑示例 13-1 中的`Vowels`类。

##### 示例 13-1。部分序列协议实现同`__getitem__`

```
>>> class Vowels:
...     def __getitem__(self, i):
...         return 'AEIOU'[i]
...
>>> v = Vowels()
>>> v[0]
'A'
>>> v[-1]
'U'
>>> for c in v: print(c)
...
A
E
I
O
U
>>> 'E' in v
True
>>> 'Z' in v
False
```

实现`__getitem__`就足以允许通过索引检索条目，并且还支持迭代和`in`操作符。这个`__getitem__`特殊方法确实是序列协议的关键。看看这个来自 [*Python/C API 参考手册*](https://fpy.li/13-1) 、[“序列协议”章节](https://fpy.li/13-2)的条目:

`int PySequence_Check(PyObject *o)`

如果对象提供序列协议，返回`1`，否则返回`0`。注意，它使用`__getitem__()`方法为 Python 类返回`1`，除非它们是`dict`子类[…]。

我们希望通过实现`__len__`，序列也能支持`len()`。`Vowels`没有`__len__`方法，但是在某些上下文中它仍然表现为一个序列。这对我们的目的来说可能就足够了。这就是为什么我喜欢说协议是一个“非正式接口”这也是 Smalltalk 理解协议的方式，small talk 是第一个使用这个术语的面向对象编程环境。

除了在关于网络编程的页面中，Python 文档中“协议”一词的大多数用法都是指这些非正式接口。

现在，随着PEP 544—协议:结构化子类型化(静态鸭类型化)](https://fpy.li/pep544)在 Python 3.8 中的采用，“协议”一词在 Python 中有了另一种含义—密切相关，但又有所不同。正如我们在[“静态协议” ( 第 8 章)中看到的，PEP 544 允许我们创建`typing.Protocol`的子类来定义一个类必须实现(或继承)以满足静态类型检查器的一个或多个方法。

当我需要具体说明时，我会采用这些术语:

Dynamic protocol

Python 一直拥有的非正式协议。动态协议是隐式的，由约定定义，并在文档中描述。Python 最重要的动态协议由解释器本身支持，并记录在《Python 语言参考资料*的[“数据模型】章节](https://fpy.li/dtmodel)中。*

Static protocol

一个由 [PEP 544 定义的协议——协议:结构化子类型(静态鸭类型)](https://fpy.li/pep544)，从 Python 3.8 开始。静态协议有明确的定义:一个`typing.Protocol`子类。

它们之间有两个主要区别:

*   一个对象可能只实现动态协议的一部分，但仍然有用；但是为了实现静态协议，对象必须提供协议类中声明的每一个方法，即使你的程序并不需要它们。

*   静态协议可以通过静态类型检查器来验证，但动态协议不能。

这两种协议都有一个基本的特征，即一个类从来不需要声明它通过名字，即通过继承来支持一个协议。

除了静态协议，Python 还提供了另一种在代码中定义显式接口的方式:抽象基类(ABC)。

本章的其余部分包括动态和静态协议，以及基础知识。

# 编程鸭子

让我们从 Python 中最重要的两个协议开始讨论动态协议:序列和可迭代协议。解释器不遗余力地处理提供这些协议的最小实现的对象，下一节将对此进行解释。

## Python 挖掘序列

Python 数据模型的哲学是尽可能地与基本的动态协议合作。当涉及到序列时，Python 努力尝试使用最简单的实现。

图 13-2 显示了如何将`Sequence`接口形式化为一个 ABC。Python 解释器和内置序列，如`list`、`str`等。，完全不要依赖 ABC。我只是用它来描述一个成熟的`Sequence`应该支持什么。

![UML class diagram for `Sequence`](Images/flpy_1302.png)

###### 图 13-2。来自`collections.abc`的`Sequence` ABC 和相关抽象类的 UML 类图。继承箭头从子类指向它的超类。斜体的名称是抽象方法。Python 3.6 之前没有`Collection` ABC— `Sequence`是`Container`、`Iterable`、`Sized`的直接子类。

###### 小费

`collections.abc`模块中的大多数 ABC 都是为了形式化接口而存在的，这些接口由内置对象实现，并由解释器隐式支持——这两者都早于 ABC 本身。ABC 是新类的起点，支持运行时的显式类型检查(又名 *goose typing* )以及静态类型检查器的类型提示。

研究图 13-2 ，我们看到一个正确的`Sequence`子类必须实现`__getitem__`和`__len__`(来自`Sized`)。`Sequence`中的所有其他方法都是具体的，所以子类可以继承它们的实现——或者提供更好的实现。

现在，回忆一下示例 13-1 中的`Vowels`类。它不从`abc.Sequence`继承，只实现`__getitem__`。

没有`__iter__`方法，但是`Vowels`实例是可迭代的，因为——作为后备——如果 Python 找到了一个`__getitem__`方法，它会通过调用带有从`0`开始的整数索引的方法来尝试迭代对象。因为 Python 足够聪明，可以迭代`Vowels`实例，所以即使在`__contains__`方法丢失的情况下，它也可以让`in`操作符工作:它执行顺序扫描来检查一个项目是否存在。

总之，考虑到类似序列的数据结构的重要性，Python 通过在`__iter__`和`__contains__`不可用时调用`__getitem__`来实现迭代和`in`操作符。

第一章中最初的`FrenchDeck`也没有子类`abc.Sequence`，但是它实现了序列协议的两个方法:`__getitem__`和`__len__`。参见](ch01.xhtml#data_model)[示例 13-2 。

##### 示例 13-2。一副牌作为一系列牌(与示例 1-1 相同)

```
import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                                        for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
```

第 1 章中的几个例子之所以有效，是因为 Python 对任何模糊地类似于序列的东西进行了特殊处理。Python 中的 iterable 协议代表了鸭子类型的一种极端形式:解释器尝试两种不同的方法来迭代对象。

为了清楚起见，我在本节中描述的行为是在解释器本身中实现的，大部分是用 c 实现的。它们不依赖于来自`Sequence` ABC 的方法。例如，`Sequence`类中的具体方法`__iter__`和`__contains__`模拟了 Python 解释器的内置行为。如果你很好奇，可以查看[*Lib/_ collections _ ABC . py*](https://fpy.li/13-3)中这些方法的源代码。

现在让我们研究另一个强调协议动态性的例子——以及为什么静态类型检查器没有机会处理它们。

## 猴子补丁:在运行时实现协议

Monkey patching 是在运行时动态改变一个模块、类或函数，以添加特性或修复 bug。例如，gevent networking library monkey 修补了 Python 标准库的部分内容，以允许在没有线程或`async` / `await`的情况下实现轻量级并发。 ^(2)

来自示例 13-2 的`FrenchDeck`类缺少一个基本特征:它不能被混洗。几年前，当我第一次编写`FrenchDeck`示例时，我确实实现了一个`shuffle`方法。后来我有了一个 Pythonic 式的见解:如果一个`FrenchDeck`的行为像一个序列，那么它不需要自己的`shuffle`方法，因为已经有了`random.shuffle` , [将](https://fpy.li/13-6)记录为“将序列 *x* 混洗到位”

标准`random.shuffle`功能是这样使用的:

```
>>> from random import shuffle
>>> l = list(range(10))
>>> shuffle(l)
>>> l
[5, 2, 9, 7, 8, 3, 1, 4, 0, 6]
```

###### 小费

当您遵循已建立的协议时，由于 duck typing，您增加了利用现有标准库和第三方代码的机会。

然而，如果我们试图混洗一个`FrenchDeck`实例，我们会得到一个异常，如示例 13-3 所示。

##### 示例 13-3。 `random.shuffle`无法处理`FrenchDeck`

```
>>> from random import shuffle
>>> from frenchdeck import FrenchDeck
>>> deck = FrenchDeck()
>>> shuffle(deck)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File ".../random.py", line 265, in shuffle
    x[i], x[j] = x[j], x[i]
TypeError: 'FrenchDeck' object does not support item assignment
```

错误信息很清楚:`'FrenchDeck' object does not support item assignment`。问题是`shuffle`在处操作*，通过交换集合内的项目，而`FrenchDeck`只实现了*不可变的*序列协议。可变序列也必须提供一个`__setitem__`方法。*

因为 Python 是动态的，所以我们可以在运行时解决这个问题，甚至在交互式控制台上。示例 13-4 展示了如何做。

##### 示例 13-4。猴子打补丁`FrenchDeck`使其可变并兼容`random.shuffle`(上接示例 13-3 )

```
>>> defset_card(deck,position,card):①... deck._cards[position]=card...>>> FrenchDeck.__setitem__=set_card②>>> shuffle(deck)③>>> deck[:5][Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4', suit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')]
```

① 创建一个以`deck`、`position`和`card`为参数的函数。

② 将该函数分配给`FrenchDeck`类中名为`__setitem__`的属性。

③ `deck`现在可以洗牌了，因为我添加了可变序列协议的必要方法。

`__setitem__`特殊方法的签名在[3 . 3 . 6 中的*Python 语言参考*中定义。](https://fpy.li/13-7)仿效集装箱类型。在这里，我将参数命名为`deck, position, card`——而不是《语言参考》中的`self, key, value`——以表明每个 Python 方法都是以普通函数的形式开始的，而将第一个参数命名为`self`只是一种约定。这在控制台会话中是可以的，但是在 Python 源文件中，使用`self`、`key`和`value`作为记录的要好得多。

诀窍在于`set_card`知道`deck`对象有一个名为`_cards`的属性，`_cards`必须是一个可变序列。然后将`set_card`函数作为`__setitem__`特殊方法附加到`FrenchDeck`类。这是一个*猴子打补丁*的例子:在运行时改变一个类或模块，而不触及源代码。Monkey 补丁功能强大，但是实际打补丁的代码与要打补丁的程序紧密耦合，通常处理私有的和未记录的属性。

除了作为猴子打补丁的一个例子，示例 13-4 突出了动态鸭类型中协议的动态本质:`random.shuffle`不关心参数的类，它只需要对象实现可变序列协议的方法。甚至不管这个物体是“天生”就有必要的方法，还是后来以某种方式获得的。

Duck typing 不需要非常不安全或者难以调试。下一节将展示一些有用的代码模式来检测动态协议，而不需要进行显式检查。

## 防御性编程和“快速失败”

防御性编程 就像防御性驾驶:一套即使面对粗心的程序员或司机也能增强安全性的实践。

许多 bug 除了在运行时不能被捕获，即使在主流静态类型语言中也是如此。在动态类型语言中，“快速失败”是对更安全、更易于维护的程序的极好建议。快速失败意味着尽快引发运行时错误，例如，在函数体的开头拒绝无效的参数。

这里有一个例子:当你写代码接受一系列项目作为一个`list`在内部处理时，不要通过类型检查强制一个`list`参数。取而代之的是，接受这个论点，并立即从中构建一个`list`。这种代码模式的一个例子是本章后面的示例 13-10 中的`__init__`方法:

```
    def __init__(self, iterable):
        self._balls = list(iterable)
```

这样可以让你的代码更加灵活，因为`list()`构造函数处理任何适合内存的 iterable。如果参数不可迭代，调用将很快失败，并在对象初始化时出现一个非常明显的`TypeError`异常。如果你想更明确，你可以用`try/except`包装`list()`调用来定制错误消息——但是我只在外部 API 上使用额外的代码，因为代码库的维护者很容易发现这个问题。无论哪种方式，违规调用都将出现在回溯的末尾，这使得修复变得非常简单。如果您没有捕捉到类构造函数中的无效参数，当该类的某个其他方法需要在`self._balls`上操作而它不是`list`时，程序将会崩溃。那么根本原因就更难找到了。

当然，如果数据不应该被复制，调用参数上的`list()`将是不好的，要么是因为数据太大，要么是因为函数根据设计需要为了调用者的利益而改变数据，就像`random.shuffle`所做的那样。在这种情况下，像`isinstance(x, abc.MutableSequence)`这样的运行时检查是可行的。

如果你害怕得到一个无限生成器——这不是一个常见的问题——你可以通过调用参数上的`len()`开始。这将拒绝迭代器，同时安全地处理元组、数组和其他完全实现`Sequence`接口的现有或未来的类。调用`len()`通常非常便宜，无效的参数会立即引发错误。

另一方面，如果任何 iterable 都是可接受的，那么尽快调用`iter(x)`来获得一个迭代器，我们将在“为什么序列是 Iterable:ITER 函数”中看到。同样，如果`x`不可迭代，这将很快失败，并出现一个易于调试的异常。

在我刚刚描述的例子中，类型提示可以更早地发现一些问题，但不是所有的问题。回想一下，类型`Any`与*一致——与其他类型*一致。类型推断可能导致变量被标记为`Any`类型。当这种情况发生时，类型检查器一无所知。此外，在运行时不强制类型提示。快速失败是最后一道防线。

利用 duck 类型的防御性代码也可以包含处理不同类型的逻辑，而不需要使用`isinstance()`或`hasattr()`测试。

一个例子是我们如何模拟在 [`collections.namedtuple`](https://fpy.li/13-8) : `field_names`中对`field_names`参数的处理，接受一个带有由空格或逗号分隔的标识符的单个字符串，或者一系列标识符。示例 13-5 展示了我如何使用 duck 类型化来做这件事。

##### 示例 13-5。鸭子打字处理一个字符串或一个可重复的字符串

```
try:①field_names=field_names.replace(',','').split()②exceptAttributeError:③pass④field_names=tuple(field_names)⑤ifnotall(s.isidentifier()forsinfield_names):⑥raiseValueError('field_names must all be valid identifiers')
```

① 假设它是一个字符串(EAFP =请求原谅比请求允许容易)。

② 将逗号转换为空格，并将结果拆分为一个名称列表。

③ 不好意思，`field_names`不像`str`一样呱呱:它没有`.replace`，或者它返回我们不能`.split`的东西。

④ 如果`AttributeError`被引发，那么`field_names`不是一个`str`，我们假设它已经是一个可迭代的名字。

⑤ 为了确保它是可迭代的并保留我们自己的副本，用我们现有的创建一个元组。A `tuple`比`list`更紧凑，也防止我的代码误改名字。

⑥ 使用`str.isidentifier`确保每个名称都有效。

示例 13-5 显示了一种情况，鸭子类型比静态类型提示更有表现力。无法拼写出“`field_names`必须是由空格或逗号分隔的标识符字符串”的类型提示这是 typeshed 上`namedtuple`签名的相关部分(完整源代码见[*stdlib/3/collections/_ _ init _ _)。pyi*):](https://fpy.li/13-9)

```
    def namedtuple(
        typename: str,
        field_names: Union[str, Iterable[str]],
        *,
        # rest of signature omitted
```

如你所见，`field_names`被注释为`Union[str, Iterable[str]]`，就其本身而言还可以，但不足以抓住所有可能的问题。

在回顾了动态协议之后，我们转向一种更明确的运行时类型检查形式:goose 类型。

# 鹅打字

> 抽象类代表一个接口。
> 
> 比雅尼·斯特劳斯特鲁普，C++ ^(的创造者4)

Python 没有`interface`关键字。我们使用抽象基类(ABCs)来定义运行时显式类型检查的接口，静态类型检查器也支持这种接口。

[抽象基类](https://fpy.li/13-10)的 *Python 词汇表*条目很好地解释了它们给鸭子类型语言带来的价值:

> 抽象基类通过提供一种定义接口的方法来补充 duck typing，而像`hasattr()`这样的其他技术可能会很笨拙或有细微的错误(例如，使用魔法方法)。ABC 引入了虚子类，虚子类是不从一个类继承，但仍然被`isinstance()`和`issubclass()`识别的类；参见`abc`模块文档。 ^(5)

Goose 类型是一种利用 ABC 的运行时类型检查方法。我会让亚历克斯·马尔泰利在《水鸟与 ABC》中解释。

###### 注意

我非常感谢我的朋友亚历克斯·马尔泰利和安娜·拉文斯克罗夫特。在 2013 年 OSCON 上，我向他们展示了流畅 Python 的第一份大纲，他们鼓励我与 O'Reilly 一起提交并发表。两人后来都参与了全面的技术审查。亚历克斯已经是这本书被引用最多的人了，然后他主动提出写这篇文章。把它拿走，亚历克斯！

概括来说，*鹅分型*需要:

*   从 ABCs 中派生出子类，以明确你正在实现一个先前定义的接口。

*   运行时类型检查使用 ABCs 而不是具体的类作为`isinstance`和`issubclass`的第二个参数。

Alex 指出，从 ABC 继承不仅仅是实现所需的方法:这也是开发人员明确的意图声明。这种意图也可以通过注册一个虚拟子类来明确表达。

###### 注意

使用`register`的细节将在本章后面的“一个 ABC 的虚拟子类”中介绍。现在，这里有一个简单的例子:给定了`FrenchDeck`类，如果我想让它通过类似于`issubclass(FrenchDeck, Sequence)`的检查，我可以用下面的代码行让它成为`Sequence` ABC 的的*虚拟子类:*

```
from collections.abc import Sequence
Sequence.register(FrenchDeck)
```

如果你检查的是 ABC 而不是具体的类，那么使用`isinstance`和`issubclass`会更容易被接受。如果与具体的类一起使用，类型检查会限制多态性——面向对象编程的一个基本特性。但是有了 ABC，这些测试更加灵活。毕竟，如果一个组件没有通过子类化实现一个 ABC 但是实现了所需的方法——它总是可以在事后被注册，所以它通过了那些显式的类型检查。

然而，即使有了 ABC，你也应该小心过度使用`isinstance`检查可能是一种 *代码气味*——糟糕的 OO 设计的一种症状。

通常*不能*让一系列`if/elif/elif`和`isinstance`检查根据对象的类型执行不同的动作:你应该使用多态性——也就是说，设计你的类以便解释器分派调用到适当的方法，而不是你在`if/elif/elif`块中硬编码分派逻辑。

另一方面，如果你必须执行一个 API 契约，对一个 ABC 执行一个`isinstance`检查是可以的:“伙计，如果你想打电话给我，你必须实现它，”正如技术评论家 Lennart Regebro 所说。这在具有插件架构的系统中特别有用。在框架之外，duck 类型化通常比类型检查更简单、更灵活。

最后，在他的文章中，亚历克斯不止一次地强调了在创造 ABC 时需要克制。过度使用 ABC 会在一种因实用而流行的语言中强加仪式。在*流畅 Python* 评审过程中，Alex 在一封电子邮件中写道:

> ABC 旨在封装由框架引入的非常一般的概念、抽象——比如“一个序列”和“一个精确的数字”[读者]很可能不需要编写任何新的 ABC，只需正确使用现有的 ABC，即可获得 99.9%的收益，而不会有严重的错误设计风险。

现在让我们看看鹅打字练习。

## 细分 ABC

遵循 马尔泰利的建议，我们将利用现有的 ABC，`collections.MutableSequence`，然后才敢发明自己的。在示例 13-6 中，`FrenchDeck2`被明确声明为`collections.MutableSequence`的子类。

##### 示例 13-6。 frenchdeck2.py: `FrenchDeck2`，`collections.MutableSequence`的子类

```
fromcollectionsimportnamedtuple,abcCard=namedtuple('Card',['rank','suit'])classFrenchDeck2(abc.MutableSequence):ranks=[str(n)forninrange(2,11)]+list('JQKA')suits='spades diamonds clubs hearts'.split()def__init__(self):self._cards=[Card(rank,suit)forsuitinself.suitsforrankinself.ranks]def__len__(self):returnlen(self._cards)def__getitem__(self,position):returnself._cards[position]def__setitem__(self,position,value):①self._cards[position]=valuedef__delitem__(self,position):②delself._cards[position]definsert(self,position,value):③self._cards.insert(position,value)
```

① `__setitem__`这就是我们实现洗牌所需的一切…

② …但是子类化`MutableSequence`迫使我们实现`__delitem__`，一个 ABC 的抽象方法。

③ 我们还需要实现 `MutableSequence` 的第三个抽象方法`insert`。

Python 在导入时不检查抽象方法的实现(当 *frenchdeck2.py* 模块被加载和编译时)，而是在运行时当我们实际尝试实例化`FrenchDeck2`时才检查。然后，如果我们未能实现抽象方法中的任何，我们将得到一个`TypeError`异常，并显示一条消息，如 `"Can't instantiate` ` abstract class FrenchDeck2 with abstract methods __delitem__, insert"`。这就是为什么我们必须实现`__delitem__`和`insert`，即使我们的`FrenchDeck2`例子不需要那些行为:ABC 要求它们。

如图 图 13-3 所示，并不是所有的`Sequence`和`MutableSequence`ABC 的方法都是抽象的。

![UML class diagram for `Sequence` and `MutableSequence`](Images/flpy_1303.png)

###### 图 13-3。`MutableSequence`ABC 及其来自`collections.abc`的超类的 UML 类图(继承箭头从子类指向祖先；斜体的名称是抽象类和抽象方法)。

要将`FrenchDeck2`写成`MutableSequence`的子类，我必须付出实现`__delitem__`和`insert`的代价，而我的例子并不需要这样做。作为回报，`FrenchDeck2`继承了`Sequence`的五个具体方法:`__contains__`、`__iter__`、`__reversed__`、`index`和`count`。从`MutableSequence`得到另外六个方法:`append`、`reverse`、`extend`、`pop`、`remove`和`__iadd__`——支持`+=`操作符进行就地连接。

每个 ABC 中的具体方法都是根据类的公共接口实现的，所以它们不需要任何实例内部结构的知识。

###### 小费

作为一个具体子类的编码者，你可以用更有效的实现来覆盖从 ABCs 继承的方法。例如，`__contains__`通过对序列进行顺序扫描来工作，但是如果您的具体序列保持其项目排序，您可以编写一个更快的`__contains__`，使用标准库中的 [`bisect`](https://fpy.li/13-13) 函数来执行二分搜索法。参见[](https://fpy.li/bisect)[*fluentpython.com*](http://fluentpython.com)中的了解更多信息。

为了很好地使用 ABC，你需要知道什么是可用的。接下来我们将回顾一下`collections`ABC。

## 标准库中的 ABC

从 Python 2.6 开始，标准库提供了几个 ABC。大多数是在`collections.abc`模块中定义的，但是还有其他的。例如，你可以在`io`和`numbers`包中找到 ABC。但是最广泛使用的是在`collections.abc`。

###### 小费

标准库中有两个名为`abc`的模块。这里说的是`collections.abc`。为了减少加载时间，由于 Python 3.4 中该模块是在`collections`包之外实现的——在[*Lib/_ collections _ ABC . py*](https://fpy.li/13-14)中——所以它是从`collections`中单独导入的。其他`abc`模块就是定义`abc.ABC`类的`abc`(即 [*Lib/abc.py*](https://fpy.li/13-15) )。每个 ABC 都依赖于`abc`模块，但是除了创建一个全新的 ABC，我们不需要自己导入。

图 13-4 是在`collections.abc`中定义的 17 个 ABC 的概要 UML 类图(没有属性名)。`collections.abc`的文档有一个漂亮的表格](https://fpy.li/13-16)，总结了 ABC、它们的关系以及它们的抽象和具体方法(称为“mixin 方法”)。在图 13-4 中有大量的多重继承。我们将把《T42》第 14 章的大部分时间用于多重继承，但是现在可以说，当涉及到 ABC 时，这通常不是问题。 ^([7)

![UML for collections.abc](Images/flpy_1304.png)

###### 图 13-4。用于`collections.abc`中 ABC 的 UML 类图。

让我们回顾一下图 13-4 中的集群:

`Iterable`, `Container`, `Sized`

每个集合要么继承这些 ABC，要么实现兼容的协议。`Iterable`支持用`__iter__`迭代，`Container`支持用`__contains__`迭代`in`算子，`Sized`支持用`__len__`迭代`len()`。

`Collection`

这个 ABC 没有自己的方法，但在 Python 3.6 中被添加，以便更容易从`Iterable`、`Container`和`Sized`派生出子类。

`Sequence`, `Mapping`, `Set`

这些是主要的不可变集合类型，每个都有一个可变子类。`MutableSequence`的详细示意图见图 13-3；`MutableMapping`和`MutableSet`参见第 3 章中的图 3-1 和 3-2 。

`MappingView`

在 Python 3 中，从映射方法`.items()`、`.keys()`和`.values()`返回的对象分别实现了在`ItemsView`、`KeysView`和`ValuesView`中定义的接口。前两个也实现了`Set`的丰富接口，带有我们在“集合操作”中看到的所有操作符。

`Iterator`

注意迭代器子类`Iterable`。我们将在第 17 章中进一步讨论这个问题。

`Callable`, `Hashable`

这些不是集合，但是`collections.abc`是第一个在标准库中定义 ABC 的包，这两个被认为足够重要以至于被包含在内。它们支持类型检查对象，这些对象必须是可调用的或者可散列的。

对于可调用检测，`callable(obj)`内置函数比`insinstance(obj, Callable)`更方便。

如果`insinstance(obj, Hashable)`返回`False`，可以确定`obj`不可散列。但如果返回的是`True`，就有可能是误报。下一个方框解释了。

在查看了一些现有的 ABC 之后，让我们从头开始实现一个 ABC 并将其投入使用，来练习 goose typing。这里的目标不是鼓励每个人开始创建 ABC，而是学习如何阅读在标准库和其他包中找到的 ABC 的源代码。

## 定义和使用 ABC

此 警告出现在 *Fluent Python* 第一版的“接口”章节中:

> ABC 就像描述符和元类一样，是构建框架的工具。因此，只有一小部分 Python 开发人员可以创建 ABC，而不会给其他程序员强加不合理的限制和不必要的工作。

现在，ABC 在类型提示中有更多潜在的用例来支持静态类型。正如在“抽象基类”中所讨论的，在函数参数类型提示中使用 ABCs 而不是具体类型给了调用者更多的灵活性。

为了证明创建 ABC 的合理性，我们需要提出一个将它用作框架中的扩展点的上下文。这就是我们的背景:想象一下，你需要在一个网站或一个移动应用程序上以随机的顺序显示广告，但在显示完整的广告清单之前，不需要重复显示一个广告。现在让我们假设我们正在构建一个名为`ADAM`的广告管理框架。它的要求之一是支持用户提供的非重复随机选择类。 ^(8) 为了让`ADAM`用户清楚什么是“非重复随机选择”组件，我们将定义一个 ABC。

在关于数据结构的文献中，“栈”和“队列”根据对象的物理排列来描述抽象接口。我会照着做，用一个真实世界的比喻来命名我们的 ABC:宾果笼子和彩票机是设计来从有限的集合中随机挑选物品的机器，没有重复，直到集合用尽。

ABC 将被命名为`Tombola`，以意大利语宾果和混合数字的翻滚容器命名。

`Tombola` ABC 有四种方法。这两个抽象方法是:

`.load(…)`

将物品放入容器。

`.pick()`

从容器中随机取出一件物品，并归还。

具体方法是:

`.loaded()`

如果容器中至少有一个项目，则返回`True`。

`.inspect()`

返回一个从当前容器中的项目构建的`tuple`，不改变其内容(不保留内部顺序)。

图 13-5 显示了`Tombola` ABC 和三个具体实现。

![UML for Tombola](Images/flpy_1305.png)

###### 图 13-5。一个 ABC 和三个子类的 UML 图。根据 UML 约定，`Tombola` ABC 的名称及其抽象方法用*斜体*书写。虚线箭头用于接口实现——这里我用它来表明`TomboList`不仅实现了`Tombola`接口，还注册为`Tombola`的*虚拟子类*——我们将在本章后面看到。 ^(9)

示例 13-7 显示了`Tombola` ABC 的定义。

##### 示例 13-7。 tombola.py: `Tombola`是一个 ABC，有两个抽象方法和两个具体方法

```
importabcclassTombola(abc.ABC):①@abc.abstractmethoddefload(self,iterable):②"""Add items from an iterable."""@abc.abstractmethoddefpick(self):③"""Remove item at random, returning it.

        This method should raise `LookupError` when the instance is empty.
        """defloaded(self):④"""Return `True` if there's at least 1 item, `False` otherwise."""returnbool(self.inspect())⑤definspect(self):"""Return a sorted tuple with the items currently inside."""items=[]whileTrue:⑥try:items.append(self.pick())exceptLookupError:breakself.load(items)⑦returntuple(items)
```

① 定义一个 ABC，子类`abc.ABC`。

② 抽象方法用`@abstractmethod` decorator 标记，通常它的主体是空的，除了 docstring。 ^(10)

③ docstring 指示实现者如果没有要挑选的项目，就引发`LookupError`。

④ ABC 可能包括具体的方法。

⑤ ABC 中的具体方法必须仅依赖于 ABC 定义的接口(即 ABC 的其他具体或抽象方法或属性)。

⑥ 我们不知道具体的子类将如何存储条目，但是我们可以通过连续调用`.pick()`清空`Tombola`来构建`inspect`结果…

⑦ …然后使用`.load(…)`将所有东西放回原位。

###### 小费

抽象方法实际上可以有一个实现。即使使用了，子类仍将被迫覆盖它，但是它们将能够使用`super()`调用抽象方法，向其添加功能，而不是从头开始实现。关于`@abstractmethod`的用法，请参见[模块文档](https://fpy.li/13-18)。

示例 13-7 中的`.inspect()`方法的代码很傻，但它表明我们可以依靠`.pick()`和`.load(…)`来检查`Tombola`中的内容，方法是选取所有的项目并将其加载回去——而不知道这些项目实际上是如何存储的。这个例子的重点是强调在 ABCs 中提供具体的方法是可以的，只要它们只依赖于接口中的其他方法。意识到它们的内部数据结构，`Tombola`的具体子类可能总是用一个更智能的实现来覆盖`.inspect()`，但是他们不必这样做。

示例 13-7 中的`.loaded()`方法只有一行代码，但代价很高:它调用`.inspect()`来构建`tuple`只是为了在上面应用`bool()`。这是可行的，但是具体的子类可以做得更好，我们将会看到。

注意，我们对`.inspect()`的迂回实现要求我们捕捉由`self.pick()`抛出的`LookupError`。事实上，`self.pick()`可能会引发`LookupError`也是其接口的一部分，但是除了在文档中，没有办法在 Python 中明确这一点(参见示例 13-7 中抽象`pick`方法的 docstring)。

我选择了`LookupError`异常，因为它在 Python 异常层次结构中的位置与`IndexError`和`KeyError`相关，最有可能由用于实现具体`Tombola`的数据结构引发的异常。因此，实现可以提升`LookupError`、`IndexError`、`KeyError`或`LookupError`的一个自定义子类来符合。参见图 13-6 。

![Upside-down tree diagram with BaseException at the top, and 4 main branches including Exception.](Images/flpy_1306.png)

###### 图 13-6。类层次结构的一部分。 ^(11)

① `LookupError`是我们在`Tombola.inspect`中处理的异常。

② 当我们试图从一个序列中获取一个索引超过最后一个位置的项目时，会引发`IndexError`子类吗？

③ 当我们使用一个不存在的键从一个映射中获取一个项目时，就会引发。

我们现在有了自己的 ABC。为了见证 ABC 执行的接口检查，让我们试着用示例 13-8 中有缺陷的实现来愚弄`Tombola`。

##### 示例 13-8。假的不会不被发现

```
>>> fromtombolaimportTombola>>> classFake(Tombola):①... defpick(self):... return13...>>> Fake②<class '__main__.Fake'> >>> f=Fake()③Traceback (most recent call last):
 File "<stdin>", line 1, in <module>TypeError: Can't instantiate abstract class Fake with abstract method load
```

① 将`Fake`声明为`Tombola`的子类。

② 该类已创建，到目前为止没有错误。

③ 当我们试图实例化`Fake`时，`TypeError`被引发。消息非常清楚:`Fake`被认为是抽象的，因为它没有实现`load`，这是在`Tombola` ABC 中声明的抽象方法之一。

所以我们定义了第一个 ABC，我们用它来验证一个类。我们将很快对`Tombola` ABC 进行子类化，但首先我们必须涵盖一些 ABC 编码规则。

## ABC 语法详细信息

声明一个 ABC 的标准方式是子类化`abc.ABC`或任何其他 ABC。

除了`ABC`基类和`@abstractmethod`装饰器之外，`abc`模块还定义了`@abstractclassmethod`、`@abstractstaticmethod`和`@abstractproperty`装饰器。然而，在 Python 3.3 中，当可以在`@abstractmethod`之上堆叠 decorators，使得其他的成为多余的时候，后三个就被弃用了。例如，声明抽象类方法的首选方式是:

```
class MyABC(abc.ABC):
    @classmethod
    @abc.abstractmethod
    def an_abstract_classmethod(cls, ...):
        pass
```

###### 警告

堆叠函数装饰符的顺序很重要，在`@abstractmethod`的情况下，文档是明确的:

> 当 abstractmethod()与其他方法描述符一起应用时，它应该作为最里面的装饰器应用… ^(12)

换句话说，在`@abstractmethod`和`def`语句之间不能出现其他修饰符。

现在我们已经讨论了这些 ABC 语法问题，让我们通过实现它的两个具体后代来使用`Tombola`。

## 细分 ABC

给定 这个`Tombola` ABC，我们现在将开发两个满足其接口的具体子类。这些类在图 13-5 中有描述，虚拟子类将在下一节讨论。

示例 13-9 中的`BingoCage`类是示例 7-8 的变体，使用了更好的随机发生器。这个`BingoCage`实现了所需的抽象方法`load`和`pick`。

##### 示例 13-9。 bingo.py: `BingoCage`是`Tombola`的具体子类

```
importrandomfromtombolaimportTombolaclassBingoCage(Tombola):①def__init__(self,items):self._randomizer=random.SystemRandom()②self._items=[]self.load(items)③defload(self,items):self._items.extend(items)self._randomizer.shuffle(self._items)④defpick(self):⑤try:returnself._items.pop()exceptIndexError:raiseLookupError('pick from empty BingoCage')def__call__(self):⑥self.pick()
```

① 这个`BingoCage`类显式扩展了`Tombola`。

② 假设我们会用这个玩在线游戏。`random.SystemRandom`在`os.urandom(…)`函数之上实现`random` API，根据 [`os`模块文档](https://fpy.li/13-21)提供“适合加密使用”的随机字节。

③ 将初始加载委托给`.load(…)`方法。

④ 我们使用`SystemRandom`实例的`.shuffle()`方法，而不是普通的`random.shuffle()`函数。

⑤ `pick`同示例 7-8 。

⑥ `__call__`也来源于示例 7-8 。不需要满足`Tombola`接口，但是增加额外的方法也无妨。

`BingoCage`继承了`Tombola`昂贵的`loaded`和愚蠢的`inspect`方法。两者都可以被更快的一行程序覆盖，如示例 13-10 。关键是:我们可以偷懒，从 ABC 继承次优的具体方法。从`Tombola`继承的方法没有为`BingoCage`继承的方法快，但是它们为任何正确实现`pick`和`load`的`Tombola`子类提供了正确的结果。

示例 13-10 显示了`Tombola`接口的一个非常不同但同样有效的实现。`LottoBlower`不是洗牌并弹出最后一个球，而是从随机位置弹出。

##### 示例 13-10。 lotto.py: `LottoBlower`是一个具体的子类，它覆盖了`Tombola`中的`inspect`和`loaded`方法

```
importrandomfromtombolaimportTombolaclassLottoBlower(Tombola):def__init__(self,iterable):self._balls=list(iterable)①defload(self,iterable):self._balls.extend(iterable)defpick(self):try:position=random.randrange(len(self._balls))②exceptValueError:raiseLookupError('pick from empty LottoBlower')returnself._balls.pop(position)③defloaded(self):④returnbool(self._balls)definspect(self):⑤returntuple(self._balls)
```

① 初始化器接受任何 iterable:参数被用来建立一个列表。

② 如果范围为空，`random.randrange(…)`函数会引发`ValueError`，因此我们捕捉它并抛出`LookupError`，以与`Tombola`兼容。

③ 否则从`self._balls`弹出随机选择的项目。

④ 覆盖`loaded`以避免调用`inspect`(如`Tombola.loaded`在示例 13-7 中所做的)。我们可以通过直接与`self._balls`合作来加快速度——不需要建立一个全新的`tuple`。

⑤ 用一行程序覆盖`inspect`。

示例 13-10 展示了一个值得一提的习语:在`__init__`中，`self._balls`存储`list(iterable)`，而不仅仅是对`iterable`的引用(也就是说，我们不仅仅是赋值`self._balls = iterable`，混淆了参数)。正如在“防御性编程和‘快速失败’”中提到的，这使得我们的`LottoBlower`更加灵活，因为`iterable`参数可以是任何可迭代类型。同时，我们确保将它的条目存储在一个`list`中，这样我们就可以`pop`条目。即使我们总是以参数`iterable`的形式获得列表，`list(iterable)`也会产生一个参数的副本，这是一个很好的实践，因为我们将从参数中移除条目，而客户端可能并不期望所提供的列表会被更改。 ^(13)

我们现在来看 goose 类型的关键动态特性:用`register`方法声明虚子类。T31

## ABC 的虚拟子类

goose 类型化的一个基本特征——也是它应该有一个水禽名字的一个原因——是能够将一个类注册为一个 ABC 的虚拟子类(*、T38 】,即使它没有继承它。在这样做的时候，我们保证这个类忠实地实现了 ABC 中定义的接口 Python 会相信我们而不进行检查。如果我们撒谎，我们会被常见的运行时异常所捕获。*

这是通过调用 ABC 上的`register`类方法来完成的。然后，注册的类成为 ABC 的虚拟子类，并将被`issubclass`识别，但它不会从 ABC 继承任何方法或属性。

###### 警告

虚拟子类不从它们注册的 ABC 继承，并且在任何时候都不检查是否符合 ABC 接口，甚至在实例化时也不检查。此外，静态类型检查器此时不能处理虚子类。详见 [Mypy 问题 2922—ABCMeta.register 支持](https://fpy.li/13-22)。

`register`方法通常作为普通函数调用(参见“寄存器的实际使用”)，但它也可以作为装饰器使用。在 示例 13-11 中，我们使用了装饰语法并实现了`TomboList`，一个`Tombola`的虚拟子类，如图图 13-7 所示。

![UML for TomboList](Images/flpy_1307.png)

###### 图 13-7。`TomboList`的 UML 类图，`list`的真实子类和`Tombola`的虚拟子类。

##### 示例 13-11。tombolist.py: class `TomboList`是`Tombola`的虚拟子类

```
fromrandomimportrandrangefromtombolaimportTombola@Tombola.register①classTomboList(list):②defpick(self):ifself:③position=randrange(len(self))returnself.pop(position)④else:raiseLookupError('pop from empty TomboList')load=list.extend⑤defloaded(self):returnbool(self)⑥definspect(self):returntuple(self)# Tombola.register(TomboList) ⑦
```

① `Tombolist`注册为`Tombola`的虚拟子类。

② `Tombolist`延伸`list`。

③ `Tombolist`继承了`list`的布尔行为，如果列表不为空，则返回`True`。

④ 我们的`pick`调用`self.pop`，继承自`list`，传递一个随机的项目索引。

⑤ `Tombolist.load`与`list.extend`相同。

⑥ `loaded`去`bool`的代表们。 ^(14)

⑦ 以这种方式调用`register`总是可能的，当你需要注册一个你不维护的类，但是它实现了接口时，这样做是有用的。

注意，由于注册的原因，函数`issubclass`和`isinstance`的作用就像`TomboList`是`Tombola`的子类一样:

```
>>> from tombola import Tombola
>>> from tombolist import TomboList
>>> issubclass(TomboList, Tombola)
True
>>> t = TomboList(range(100))
>>> isinstance(t, Tombola)
True
```

然而，继承是由一个名为`__mro__`的特殊类属性引导的——方法解析顺序。它基本上按照 Python 搜索方法的顺序列出了类及其超类。 ^(15) 如果你检查`TomboList`的`__mro__`，你会看到它只列出了“真正的”超类——`list`和`object`:

```
>>> TomboList.__mro__
(<class 'tombolist.TomboList'>, <class 'list'>, <class 'object'>)
```

`Tombola`不在`Tombolist.__mro__`中，所以`Tombolist`不从`Tombola`继承任何方法。

我们的`Tombola` ABC 案例研究到此结束。在下一节中，我们将讨论如何在野外使用`register` ABC 函数。

## 语域在实践中的使用

在示例 13-11 中，我们 使用`Tombola.register`作为类装饰器。在 Python 3.3 之前，`register`不能这样使用——它必须在类定义之后作为普通函数调用，正如示例 13-11 末尾的注释所建议的。然而，即使是现在，它作为一个函数被更广泛地部署来注册在其他地方定义的类。例如，在`collections.abc`模块的[源代码](https://fpy.li/13-24)中，内置类型`tuple`、`str`、`range`和`memoryview`被注册为`Sequence`的虚拟子类，如下所示:

```
Sequence.register(tuple)
Sequence.register(str)
Sequence.register(range)
Sequence.register(memoryview)
```

其他几个内置类型注册到 abc 的 *_collections_abc.py* 中。这些注册只有在模块被导入时才会发生，这是可以的，因为无论如何您都必须导入它才能获得 ABC。例如，您需要从`collections.abc`导入`MutableMapping`来执行类似`isinstance(my_dict, MutableMapping)`的检查。

子类化一个 ABC 或者向一个 ABC 注册都是使我们的类通过`issubclass`检查的显式方法——以及`isinstance`检查，后者也依赖于`issubclass`。但是一些 ABC 也支持结构化类型。下一节解释。

## 用 ABC 进行结构分型

ABC多与名义打字连用。当一个类`Sub`显式地从`AnABC`继承，或者用`AnABC`注册时，`AnABC`的名字被链接到`Sub`类——这就是在运行时，`issubclass(AnABC, Sub)`如何返回`True`。

相比之下，结构类型是关于查看一个对象的公共接口的结构来确定它的类型:一个对象是*一致的——如果它实现了类型中定义的方法。 ^(16) 动态和静态鸭分型是结构分型的两种途径。*

原来有些 ABC 也支持结构类型。在他的文章“水鸟和 ABC”中，Alex 表明一个类即使没有注册也可以被识别为 ABC 的子类。这是他的例子，增加了一个使用`issubclass`的测试:

```
>>> class Struggle:
...     def __len__(self): return 23
...
>>> from collections import abc
>>> isinstance(Struggle(), abc.Sized)
True
>>> issubclass(Struggle, abc.Sized)
True
```

因为`abc.Sized`实现了一个名为`__subclasshook__`的特殊类方法，所以`Struggle`被`issubclass`函数认为是`abc.Sized`的子类(因此也被`isinstance`认为是)。

`Sized`的`__subclasshook__`检查类参数是否有一个名为`__len__`的属性。如果是的话，那么它被认为是`Sized`的虚拟子类。参见示例 13-12 。

##### 示例 13-12。来自[Lib/_ collections _ ABC . py](https://fpy.li/13-25)源代码的`Sized`的定义

```
classSized(metaclass=ABCMeta):__slots__=()@abstractmethoddef__len__(self):return0@classmethoddef__subclasshook__(cls,C):ifclsisSized:ifany("__len__"inB.__dict__forBinC.__mro__):①returnTrue②returnNotImplemented③
```

① 如果在`C.__mro__`中列出的任何类的`__dict__`中有一个名为`__len__`的属性(即`C`及其超类)…

② …返回`True`，表示`C`是`Sized`的虚拟子类。

③ 否则返回`NotImplemented`让子类检查继续进行。

###### 注意

如果你对子类 check 的细节感兴趣，请看 Python 3.6 中`ABCMeta.__subclasscheck__`方法的源代码: [*Lib/abc.py*](https://fpy.li/13-26) 。注意:它有很多 if 和两个递归调用。在 Python 3.7 中，伊万·列夫斯基和稻田·直树用 C 语言重写了`abc`模块的大部分逻辑，以获得更好的性能。参见 [Python 问题#31333](https://fpy.li/13-27) 。`ABCMeta.__subclasscheck__`目前的实现简单的调用`_abc_subclasscheck`。相关的 C 源代码在[*cpython/Modules/_ ABC . C # L605*](https://fpy.li/13-28)中。

这就是`__subclasshook__`如何让 ABCs 支持结构化类型。你可以用一个 ABC 来形式化一个接口，你可以对那个 ABC 进行`isinstance`检查，并且仍然有一个完全不相关的类通过`issubclass`检查，因为它实现了一个特定的方法(或者因为它尽一切努力说服一个`__subclasshook__`来担保它)。

在我们自己的 ABC 中实现`__subclasshook__`是个好主意吗？大概不会。我在 Python 源代码中看到的所有`__subclasshook__`的实现都是在像`Sized`这样的 ABC 中，它们只声明一个特殊的方法，并且它们只是检查那个特殊的方法名。考虑到它们的“特殊”状态，您可以非常确定任何名为`__len__`的方法都会如您所愿。但是，即使在特殊方法和基础知识领域，做出这样的假设也是有风险的。例如，映射实现了`__len__`、`__getitem__`和`__iter__`，但是它们不被认为是`Sequence`的子类型，因为不能使用整数偏移量或片来检索项目。这就是为什么 [`abc.Sequence`](https://fpy.li/13-29) 类不实现 `__subclasshook__` 的原因。

对于你我可能会写的 ABC，一个`__subclasshook__`会更不可靠。我不愿意相信任何名为`Spam`的实现或继承了`load`、`pick`、`inspect`和`loaded`的类一定会表现得像`Tombola`。不如通过从`Tombola`子类化`Spam`，或者用`Tombola.register(Spam)`注册，让程序员来肯定。当然，你的`__subclasshook__`也可以检查方法签名和其他特性，但是我认为这不值得。

# 静态协议

###### 注意

静态协议在【静态协议】 ( 第 8 章)中介绍。我考虑过将所有协议的内容推迟到本章，但是决定函数中类型提示的初始表示必须包括协议，因为 duck typing 是 Python 的一个基本部分，没有协议的静态类型检查不能很好地处理 Python API。

我们将用两个简单的例子来说明静态协议，并讨论数字 ABC 和协议，以此来结束本章。让我们从展示静态协议如何使我们第一次在“类型由支持的操作定义”中看到的`double()`函数的注释和类型检查成为可能开始。

## 类型化的双重功能

当 向更习惯静态类型语言的程序员介绍 Python 时，我最喜欢的一个例子就是这个简单的`double`函数:

```
>>> def double(x):
...     return x * 2
...
>>> double(1.5)
3.0
>>> double('A')
'AA'
>>> double([10, 20, 30])
[10, 20, 30, 10, 20, 30]
>>> from fractions import Fraction
>>> double(Fraction(2, 5))
Fraction(4, 5)
```

在引入静态协议之前，没有一种实用的方法可以给`double`添加类型提示而不限制其可能的用途。 ^(17)

多亏了 duck typing，`double`甚至可以处理未来的类型，比如我们将在"标量乘法的重载*"(第 16 章)中看到的增强的`Vector`类:

```
>>> from vector_v7 import Vector
>>> double(Vector([11.0, 12.0, 13.0]))
Vector([22.0, 24.0, 26.0])
```

Python 中类型提示的最初实现是一个名义类型系统:注释中的类型名称必须与实际参数的类型名称相匹配，或者与其超类之一的名称相匹配。因为不可能通过支持所需的操作来命名实现协议的所有类型，所以在 Python 3.8 之前，鸭子类型不能通过类型提示来描述。

现在，通过`typing.Protocol`，我们可以告诉 Mypy】接受一个支持`x * 2`的参数`x`。示例 13-13 展示了如何操作。

##### 示例 13-13。*double _ protocol . py*:使用`Protocol`定义`double`

```
fromtypingimportTypeVar,ProtocolT=TypeVar('T')①classRepeatable(Protocol):def__mul__(self:T,repeat_count:int)->T:...②RT=TypeVar('RT',bound=Repeatable)③defdouble(x:RT)->RT:④returnx*2
```

① 我们将在`__mul__`签名中使用这个`T`。

② `__mul__`是`Repeatable`协议的精髓。`self`参数通常没有注释——它的类型被认为是类。这里我们使用`T`来确保结果类型与`self`的类型相同。另外，请注意在本协议中`repeat_count`仅限于`int`。

③ `RT`类型变量受`Repeatable`协议约束:类型检查器将要求实际类型实现`Repeatable`。

④ 现在，类型检查器能够验证`x`参数是一个可以乘以整数的对象，并且返回值与`x`具有相同的类型。

这个例子说明了为什么 [PEP 544](https://fpy.li/pep544) 被命名为“协议:结构子类型(静态鸭类型)。”给予`double`的实际参数`x`的名义类型是不相关的，只要它嘎嘎叫——也就是说，只要它实现了`__mul__`。

## 运行时可检查的静态协议

在打字图(图 13-1 )中，`typing.Protocol`出现在静态检查区——图的下半部。然而，当定义一个`typing.Protocol`子类时，您可以使用`@runtime_checkable`装饰器使协议支持运行时的`isinstance/issubclass`检查。这是因为`typing.Protocol`是一个 ABC，因此它支持我们在“使用 ABC 的结构化类型化”中看到的`__subclasshook__`。

从 Python 3.9 开始，`typing`模块包含了七个可运行时检查的现成协议。这里有两条，直接引自 [`typing`文档](https://fpy.li/13-30):

`class typing.SupportsComplex`

具有一个抽象方法的 ABC，`__complex__`。

`class typing.SupportsFloat`

一个有一个抽象方法的 ABC，`__float__`。

这些协议被设计用来检查数值类型的“可转换性”:如果一个对象`o`实现了`__complex__`，那么你应该能够通过调用`complex(o)`得到一个`complex`——因为`__complex__`特殊方法的存在是为了支持 `complex()` 内置函数。

示例 13-14 显示了`typing.SupportsComplex`协议的[源代码](https://fpy.li/13-31)。

##### 示例 13-14。 `typing.SupportsComplex`协议源代码

```
@runtime_checkable
class SupportsComplex(Protocol):
    """An ABC with one abstract method __complex__."""
    __slots__ = ()

    @abstractmethod
    def __complex__(self) -> complex:
        pass
```

关键是`__complex__`的抽象方法。 ^(18) 在静态类型检查过程中，如果一个对象实现了一个只接受`self`并返回`complex`的`__complex__`方法，那么它将被认为*与*协议一致。

多亏了应用于`SupportsComplex`的`@runtime_checkable`类装饰器，该协议也可以用于示例 13-15 中的`isinstance`检查。

##### 示例 13-15。运行时使用`SupportsComplex`

```
>>> fromtypingimportSupportsComplex>>> importnumpyasnp>>> c64=np.complex64(3+4j)①>>> isinstance(c64,complex)②False >>> isinstance(c64,SupportsComplex)③True >>> c=complex(c64)④>>> c(3+4j) >>> isinstance(c,SupportsComplex)⑤False >>> complex(c)(3+4j)
```

① `complex64`是 NumPy 提供的五种复数类型之一。

② 没有一个 NumPy 复杂类型继承了内置的`complex`。

③ 但是 NumPy 的复杂类型实现了`__complex__`，所以它们符合`SupportsComplex`协议。

④ 因此，您可以从它们创建内置的`complex`对象。

⑤ 可悲的是，`complex`内置类型并没有实现`__complex__`，尽管如果`c`是`complex`的话 `complex(c)` 也能正常工作。

最后一点的结果是，如果你想测试一个对象`c`是一个`complex`还是`SupportsComplex`，你可以提供一个类型元组作为 `isinstance` 的第二个参数，就像这样:

```
isinstance(c, (complex, SupportsComplex))
```

另一种方法是使用在`numbers`模块中定义的`Complex` ABC。内置的`complex`类型和 NumPy `complex64`和`complex128`类型都注册为`numbers.Complex`的虚拟子类，因此这是有效的:

```
>>> import numbers
>>> isinstance(c, numbers.Complex)
True
>>> isinstance(c64, numbers.Complex)
True
```

我在第一版的 *Fluent Python* 中推荐使用`numbers`ABC，但是现在这不再是一个好建议，因为静态类型检查器无法识别这些 ABC，我们将在“数字 ABC 和数字协议”中看到。

在这一节中，我想演示一个运行时可检查协议与`isinstance`一起工作，但事实证明这是一个例子，而不是`isinstance`的一个特别好的用例，正如侧栏“鸭子打字是你的朋友”解释的那样。

###### 小费

如果您使用外部类型检查器，显式`isinstance`检查有一个优点:当您编写一个条件为`isinstance(o, MyType)`的`if`语句时，Mypy 可以推断出在`if`块内部，`o`对象的类型是*一致的——与* `MyType`一致。

既然我们已经看到了如何在运行时使用静态协议和预先存在的类型，如`complex`和`numpy.complex64`，我们需要讨论运行时可检查协议的限制。

## 运行时协议检查的限制

我们已经看到类型提示在运行时通常会被忽略，这也影响了针对静态协议的`isinstance`或`issubclass`检查。

例如，任何具有`__float__`方法的类在运行时都被认为是`SupportsFloat`的虚拟子类，即使`__float__`方法不返回`float`。

检查此控制台会话:

```
>>> import sys
>>> sys.version
'3.9.5 (v3.9.5:0a7dcbdb13, May  3 2021, 13:17:02) \n[Clang 6.0 (clang-600.0.57)]'
>>> c = 3+4j
>>> c.__float__
<method-wrapper '__float__' of complex object at 0x10a16c590>
>>> c.__float__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't convert complex to float
```

在 Python 3.9 中，`complex`类型确实有一个`__float__`方法，但它的存在只是为了引发一个带有显式错误消息的`TypeError`。如果那个`__float__`方法有注释，那么返回类型将是`NoReturn`——我们在“no return”中看到了。

但是在*类型化的*上的类型提示`complex.__float__`并不能解决这个问题，因为 Python 的运行时通常会忽略类型提示——并且无论如何也不能访问*类型化的*存根文件。

继续之前的 Python 3.9 会话:

```
>>> from typing import SupportsFloat
>>> c = 3+4j
>>> isinstance(c, SupportsFloat)
True
>>> issubclass(complex, SupportsFloat)
True
```

因此我们得到了误导性的结果:运行时对`SupportsFloat`的检查表明您可以将一个`complex`转换成`float`，但事实上这引发了一个类型错误。

###### 警告

在 Python 3.10.0b4 中，`complex`类型的特定问题已修复，删除了`complex.__float__`方法。

但是总的问题仍然存在:`isinstance` / `issubclass`检查只检查方法的存在或不存在，而不检查它们的签名，更不检查它们的类型注释。这种情况不会改变，因为运行时的这种类型检查会有不可接受的性能代价。 ^(19)

现在让我们看看如何在用户定义的类中实现静态协议。

## 支持静态协议

回忆一下我们在第十一章中建造的`Vector2d`级。假设一个`complex`数字和一个`Vector2d`实例都由一对浮点数组成，那么支持从`Vector2d`到`complex`的转换是有意义的。

示例 13-16 显示了`__complex__`方法的实现，以增强我们在示例 11-11 中看到的`Vector2d`的最后版本。为了完整性，我们可以用一个`fromcomplex`类方法支持逆向操作，从一个`complex`构建一个`Vector2d`。

##### 示例 13-16。 *vector2d_v4.py* :与`complex`相互转换的方法

```
def__complex__(self):returncomplex(self.x,self.y)@classmethoddeffromcomplex(cls,datum):returncls(datum.real,datum.imag)①
```

① 这里假设`datum`有`.real`和`.imag`属性。我们将在示例 13-17 中看到一个更好的实现。

给定前面的代码，以及示例 11-11 中`Vector2d`已经有的`__abs__`方法，我们得到这些特征:

```
>>> from typing import SupportsComplex, SupportsAbs
>>> from vector2d_v4 import Vector2d
>>> v = Vector2d(3, 4)
>>> isinstance(v, SupportsComplex)
True
>>> isinstance(v, SupportsAbs)
True
>>> complex(v)
(3+4j)
>>> abs(v)
5.0
>>> Vector2d.fromcomplex(3+4j)
Vector2d(3.0, 4.0)
```

对于运行时类型检查，示例 13-16 很好，但是为了更好的静态覆盖和使用 Mypy 的错误报告，`__abs__`、`__complex__`和`fromcomplex`方法应该得到类型提示，如示例 13-17 所示。

##### 示例 13-17。 *vector2d_v5.py* :给正在研究的方法添加注释

```
def__abs__(self)->float:①returnmath.hypot(self.x,self.y)def__complex__(self)->complex:②returncomplex(self.x,self.y)@classmethoddeffromcomplex(cls,datum:SupportsComplex)->Vector2d:③c=complex(datum)④returncls(c.real,c.imag)
```

① 需要`float`返回注释，否则 Mypy 推断`Any`，并且不检查方法体。

② 即使没有注释，Mypy 也能够推断出这将返回一个`complex`。根据您的 Mypy 配置，注释会防止出现警告。

③ 这里`SupportsComplex`确保`datum`是可转换的。

④ 这种显式转换是必要的，因为`SupportsComplex`类型没有声明在下一行中使用的`.real`和`.imag`属性。比如`Vector2d`没有那些属性，但是实现了`__complex__`。

如果`from __future__ import annotations`出现在模块顶部，`fromcomplex`的返回类型可以是`Vector2d`。该导入导致类型提示存储为字符串，而不在导入时计算函数定义时进行计算。没有`annotations`的`__future__`导入，`Vector2d`此时是无效引用(类还没有完全定义)，应该写成字符串:`'Vector2d'`，就好像是前向引用一样。这个`__future__`导入是在 PEP 563 中引入的——注释](https://fpy.li/pep563)的延期求值，在 Python 3.7 中实现。该行为计划在 3.10 中成为默认行为，但该更改被推迟到更高版本。 ^([20) 当这种情况发生时，导入将是多余的，但无害的。

接下来，让我们看看如何创建一个新的静态协议，并在以后扩展它。

## 设计静态协议

在学习 goose 打字时，我们在“定义和使用 ABC”中看到了`Tombola` ABC。这里我们将看到如何使用静态协议定义一个类似的接口。

`Tombola` ABC 指定了两种方法:`pick`和`load`。我们也可以用这两种方法定义一个静态协议，但是我从 Go 社区了解到，单方法协议使得静态鸭类型更加有用和灵活。Go 标准库有几个类似于`Reader`的接口，一个只需要一个`read`方法的 I/O 接口。过一段时间后，如果您意识到需要一个更完整的协议，您可以将两个或更多的协议组合起来定义一个新的协议。

使用一个随机选择项目的容器可能需要也可能不需要重新装载容器，但是它肯定需要一个方法来进行实际的选择，所以这是我为最小的`RandomPicker`协议选择的方法。该协议的代码在示例 13-18 中，其使用由示例 13-19 中的测试演示。

##### 示例 13-18。 *randompick.py* :定义`RandomPicker`

```
from typing import Protocol, runtime_checkable, Any

@runtime_checkable
class RandomPicker(Protocol):
    def pick(self) -> Any: ...
```

###### 注意

`pick`方法返回`Any`。在“实现一个通用静态协议”中，我们将看到如何使`RandomPicker`成为一个带参数的通用类型，让协议的用户指定`pick`方法的返回类型。

##### 示例 13-19。*random pick _ test . py*:`RandomPicker`正在使用中

```
importrandomfromtypingimportAny,Iterable,TYPE_CHECKINGfromrandompickimportRandomPicker①classSimplePicker:②def__init__(self,items:Iterable)->None:self._items=list(items)random.shuffle(self._items)defpick(self)->Any:③returnself._items.pop()deftest_isinstance()->None:④popper:RandomPicker=SimplePicker([1])⑤assertisinstance(popper,RandomPicker)⑥deftest_item_type()->None:⑦items=[1,2]popper=SimplePicker(items)item=popper.pick()assertiteminitemsifTYPE_CHECKING:reveal_type(item)⑧assertisinstance(item,int)
```

① 没有必要导入静态协议来定义实现它的类。我在这里导入了`RandomPicker`，只是为了以后在`test_isinstance`上使用。

② `SimplePicker`实现了`RandomPicker`——但是它没有子类化它。这是静态鸭打字在行动。

③ `Any`是默认的返回类型，所以这个注释并不是绝对必要的，但它确实更清楚地表明我们正在实现示例 13-18 中定义的`RandomPicker`协议。

④ 如果你想让 Mypy 查看它们，不要忘记在你的测试中添加`-> None`提示。

⑤ 我为`popper`变量添加了一个类型提示，以表明 Mypy 知道`SimplePicker`与*一致——与*一致。

⑥ 这个测试证明了`SimplePicker`的实例也是`RandomPicker`的实例。这是因为`@runtime_checkable`装饰器应用于 `RandomPicker` ，并且`SimplePicker`根据需要有一个`pick`方法。

⑦ 这个测试从一个`SimplePicker`调用`pick`方法，验证它是否返回给`SimplePicker`的项目之一，然后对返回的项目进行静态和运行时检查。

⑧ 这一行在 Mypy 输出中生成一个注释。

正如我们在示例 8-22 中看到的，`reveal_type`是一个被 Mypy 识别的“神奇”函数。这就是为什么它没有被导入，我们只能在受`typing.TYPE_CHECKING`保护的`if`块中调用它，在静态类型检查器眼中它只是`True`，但在运行时却是`False`。

示例 13-19 中的两项测试均通过。Mypy 在该代码中也没有看到任何错误，并在由`pick`返回的`item`上显示`reveal_type`的结果:

```
$ mypy randompick_test.py
randompick_test.py:24: note: Revealed type is 'Any'
```

在创建了我们的第一个协议之后，让我们来研究一些关于这个问题的建议。

## 协议设计的最佳实践

经过 10 年在 Go 中静态鸭子打字的经验，很明显窄协议更有用——这种协议通常只有一个方法，很少超过两个方法。Martin Fowler 写了一篇定义 [*角色接口*](https://fpy.li/13-33) 的文章，这是一个在设计协议时需要牢记的有用想法。

此外，有时您会看到在使用它的函数附近定义了一个协议——也就是说，在“客户端代码”中定义，而不是在库中定义。这使得创建新类型来调用该函数变得容易，这对于可扩展性和模拟测试来说是很好的。

窄协议和客户端代码协议的实践都避免了不必要的紧密耦合，符合[接口分离原则](https://fpy.li/13-34)，我们可以将其总结为“客户端不应该被迫依赖于他们不使用的接口。”

页面[" Contributing to typeshed "](https://fpy.li/13-35)推荐静态协议的这种命名约定(以下三点逐字引用):

*   使用简单明了的名称来表示清晰的概念(如`Iterator`、、`Container`、)。

*   对提供可调用方法的协议使用`SupportsX`(例如`SupportsInt`、`SupportsRead`、`SupportsReadSeek`)。 ^(21)

*   将`HasX`用于具有可读和/或可写属性或 getter/setter 方法的协议(如`HasItems`、`HasFileno`)。

Go 标准库有一个我喜欢的命名约定:对于单方法协议，如果方法名是动词，则附加“-er”或“-or”使其成为名词。比如，用`Reader`代替`SupportsRead`。更多的例子包括`Formatter`、`Animator`和`Scanner`。灵感见明日香贤治[《Go(Golang)标准库接口(精选)》](https://fpy.li/13-36)。

创建极简协议的一个很好的理由是，如果需要，以后可以扩展它们。我们现在将看到，用一个额外的方法创建一个派生协议并不难。

## 扩展协议

正如我在上一节开始时提到的，Go 开发者提倡在定义接口时偏向极简主义——他们对静态协议的称呼。许多最广泛使用的 Go 接口只有一个方法。

当实践揭示一个有更多方法的协议是有用的时候，与其在原协议上增加方法，不如从中派生出一个新的协议。用 Python 扩展静态协议有一些注意事项，如示例 13-20 所示。

##### 示例 13-20。 *randompickload.py* :扩展`RandomPicker`

```
fromtypingimportProtocol,runtime_checkablefromrandompickimportRandomPicker@runtime_checkable①classLoadableRandomPicker(RandomPicker,Protocol):②defload(self,Iterable)->None:...③
```

① 如果您希望派生的协议是运行时可检查的，您必须再次应用装饰器——它的行为不会被继承。 ^(22)

② 除了我们正在扩展的协议之外，每个协议都必须明确地将`typing.Protocol`命名为它的一个基类。这与 Python 中继承的工作方式不同。 ^(23)

③ 回到“常规的”面向对象编程:我们只需要声明这个派生协议中的新方法。`pick`方法声明继承自`RandomPicker`。

本章中定义和使用静态协议的最后一个例子到此结束。

为了结束这一章，我们将回顾数字 ABC 和它们可能被数字协议所取代。

## 数字 ABC 和数字协议

正如 我们在《数字塔的坠落》中看到的，标准库的`numbers`包中的 ABCs 工作良好，可以进行运行时类型检查。

如果你需要检查一个整数，你可以使用`isinstance(x, numbers.Integral)`来接受`int`、`bool`(其子类为`int`)或者其他由外部库提供的整数类型，这些外部库将它们的类型注册为`numbers` ABCs 的虚拟子类。例如，NumPy 有 [21 个整数类型](https://fpy.li/13-39)——以及注册为`numbers.Real`的浮点类型的几种变体，以及注册为`numbers.Complex`的具有各种位宽的复数。

###### 小费

有点令人惊讶的是，`decimal.Decimal`并没有注册为`numbers.Real`的虚子类。原因是，如果您的程序需要`Decimal`的精度，那么您希望避免小数与精度较低的浮点数的意外混合。

遗憾的是，数字塔不是为静态类型检查而设计的。根 ABC—`numbers.Number`—没有方法，所以如果你声明了`x: Number`，Mypy 不会让你做算术或者调用`x`上的任何方法。

如果不支持`numbers`ABC，有哪些选项？

寻找打字解决方案的一个好地方是*打字的*项目。作为 Python 标准库的一部分，`statistics`模块有一个对应的[*statistics . pyi*](https://fpy.li/13-40)存根文件，带有对*类型化*的类型提示。在那里你会发现下面的定义，它们被用来注释几个函数:

```
_Number = Union[float, Decimal, Fraction]
_NumberT = TypeVar('_NumberT', float, Decimal, Fraction)
```

这种方法是正确的，但有局限性。它不支持标准库之外的数字类型，而`numbers`ABC 在运行时支持——当数字类型注册为虚拟子类时。

当前的趋势是推荐由`typing`模块提供的数字协议，我们在“运行时可检查静态协议”中讨论过。

不幸的是，在运行时，数字协议可能会让您失望。正如在“运行时协议检查的限制”中提到的，Python 3.9 中的`complex`类型实现了`__float__`，但是该方法的存在只是为了用一个明确的消息来引发`TypeError`:“不能将复杂转换为浮点。”出于同样的原因，它也实现了`__int__`。这些方法的存在使得`isinstance`在 Python 3.9 中返回误导性的结果。在 Python 3.10 中，移除了无条件提升`TypeError`的`complex`的方法。^(24)

另一方面，NumPy 的复杂类型实现了有效的`__float__`和`__int__`方法，只有在第一次使用它们时才会发出警告:

```
>>> import numpy as np
>>> cd = np.cdouble(3+4j)
>>> cd
(3+4j)
>>> float(cd)
<stdin>:1: ComplexWarning: Casting complex values to real
discards the imaginary part
3.0
```

相反的问题也会发生:内置的`complex`、`float`和`int`，还有`numpy.float16`和`numpy.uint8`，没有`__complex__`方法，所以`isinstance(x, SupportsComplex)`为它们返回`False`。 ^(25) 把 NumPy 等复杂类型的`np.complex64`，做实现`__complex__`转换成内置的`complex`。

然而，在实践中，`complex()`内置构造函数处理所有这些类型的实例，没有错误或警告:

```
>>> import numpy as np
>>> from typing import SupportsComplex
>>> sample = [1+0j, np.complex64(1+0j), 1.0, np.float16(1.0), 1, np.uint8(1)]
>>> [isinstance(x, SupportsComplex) for x in sample]
[False, True, False, False, False, False]
>>> [complex(x) for x in sample]
[(1+0j), (1+0j), (1+0j), (1+0j), (1+0j), (1+0j)]
```

这表明`isinstance`对`SupportsComplex`的检查表明那些到`complex`的转换会失败，但是它们都成功了。在 typing-sig 邮件列表中，吉多·范·罗苏姆指出内置的`complex`接受单个参数，这就是为什么这些转换能够工作。

另一方面，Mypy 在对一个 `to_complex()` 函数的调用中接受所有这六种类型的参数，定义如下:

```
def to_complex(n: SupportsComplex) -> complex:
    return complex(n)
```

在我写这篇文章的时候，NumPy 没有类型提示，所以它的数字类型都是`Any`。 ^(26) 另一方面，Mypy 不知何故“意识到”内置的`int`和`float`可以转换成`complex`，尽管在*类型化的*上只有内置的`complex`类有一个`__complex__`方法。 ^(27)

总之，尽管数字类型应该不难进行类型检查，但目前的情况是这样的:类型提示 PEP 484 [避开了](https://fpy.li/cardxvi)数字塔，并隐式建议类型检查器硬编码内置`complex`、`float`和`int`之间的子类型关系。Mypy 做到了这一点，并且它也实际上接受了`int`和`float`是*一致的——即使它们没有实现`__complex__`。*

###### 小费

我只在对数字`Supports*`协议使用`isinstance`检查时发现了意想不到的结果，同时尝试了与`complex`的相互转换。如果你不使用复数，你可以依靠那些协议而不是`numbers` ABCs。

本节的主要要点是:

*   `numbers` ABCs 适合运行时类型检查，但不适合静态类型。

*   数字静态协议`SupportsComplex`、`SupportsFloat`等。适用于静态类型，但是当涉及复数时，对于运行时类型检查是不可靠的。

我们现在准备快速回顾一下本章所学的内容。T38T40

# 章节摘要

打字图(图 13-1 )是理解本章的关键。在简单介绍了四种类型化方法之后，我们对比了分别支持 duck 类型化和静态 duck 类型化的动态和静态协议。这两种协议都有一个基本的特征，那就是从来不需要一个类来明确声明对任何特定协议的支持。一个类仅仅通过实现必要的方法来支持一个协议。

下一个主要部分是“编程鸭子”，我们探索了 Python 解释器使序列和可迭代动态协议工作的长度，包括两者的部分实现。然后，我们看到了如何通过猴子补丁添加额外的方法，使一个类在运行时实现一个协议。duck typing 部分以防御性编程的提示结束，包括使用`try/except`在没有显式`isinstance`或`hasattr`检查的情况下检测结构类型，以及快速失败。

在 Alex Martelli 在“Waterfowl and ABCs”中介绍了 goose typing 之后，我们看到了如何对现有的 ABC 进行子类化，调查了标准库中的重要 ABC，并从头创建了一个 ABC，然后我们通过传统的子类化和注册来实现它。为了结束这一节，我们看到了`__subclasshook__`特殊方法如何通过识别提供实现 ABC 中定义的接口的方法的不相关类，使 ABC 支持结构化类型。

最后一个主要部分是“静态协议”，在这里我们恢复了静态鸭类型化的内容，它开始于第 8 章](ch08.xhtml#type_hints_in_def_ch)，在“静态协议”。我们看到了`@runtime_checkable`装饰器如何利用`__subclasshook__`来支持运行时的结构类型——即使静态协议的最佳使用是静态类型检查器，它可以考虑类型提示，使结构类型更加可靠。接下来我们讨论了静态协议的设计和编码，以及如何扩展它。这一章以[“数字 ABC 和数字协议”结束，讲述了数字塔废弃状态的悲惨故事以及提议的替代方案的一些现有缺点:数字静态协议，如`SupportsFloat`和其他添加到 Python 3.8 中的`typing`模块。

本章的主要信息是，在现代 Python 中，我们有四种互补的接口编程方式，每种方式都有不同的优缺点。在任何现代的大型 Python 代码库中，您都有可能为每种类型方案找到合适的用例。拒绝这些方法中的任何一种都会使您作为 Python 程序员的工作变得更加困难。

话虽如此，Python 还是在只支持 duck 类型的情况下获得了广泛的流行。其他流行的语言，如 JavaScript、PHP 和 Ruby，以及 Lisp、Smalltalk、Erlang 和 clo jure——虽然不流行，但非常有影响力——都是通过利用 duck typing 的强大功能和简单性而产生了巨大影响的语言。

# 进一步阅读

对于 快速看一下打字的利弊，以及`typing.Protocol`对于静态检查代码库健康的重要性，我强烈推荐 Glyph Lefkowitz 的帖子“我想要一只新鸭子:`typing.Protocol`和鸭子打字的未来”](https://fpy.li/13-42)。我还从他的帖子[“接口和协议”](https://fpy.li/13-43)中学到了很多，比较了`typing.Protocol`和`zope.interface`——一种在松散耦合插件系统中定义接口的早期机制，被 [Plone CMS](https://fpy.li/13-44) 、[金字塔 web 框架](https://fpy.li/13-45)和 [Twisted](https://fpy.li/13-46) 异步编程框架(Glyph 创建的一个项目)使用。 ^([28)

关于 Python 的优秀书籍——几乎按照定义——对 duck 类型化进行了大量的介绍。我最喜欢的两本 Python 书籍在第一版*流畅 Python* : *快速 Python 书籍*，第三版之后发布了更新。(曼宁)，由内奥米塞德；还有 [*Python 一言以蔽之*，第 3 版。亚历克斯·马尔泰利、安娜·拉文斯克罗夫特和史蒂夫·霍尔登(奥莱利)。](https://fpy.li/pynut3)

关于动态类型的利与弊的讨论，请参见吉多·范·罗苏姆在“Python 中的契约:与吉多·范·罗苏姆的对话，第四部分”](https://fpy.li/13-47)中对比尔·凡纳斯的采访。马丁·福勒的文章[“动态类型”](https://fpy.li/13-48)对这场争论进行了深刻而平衡的分析。他还写过[“角色接口”](https://fpy.li/13-33)，我在[“协议设计最佳实践”中提到过。尽管这篇文章不是关于鸭子类型的，但它与 Python 协议设计高度相关，因为他将狭义的角色接口与广义的类公共接口进行了对比。

Mypy 文档通常是与 Python 中的静态类型相关的任何信息的最佳来源，包括静态 duck 类型，在他们的[“协议和结构子类型”章节](https://fpy.li/13-50)中有介绍。

剩下的参考资料都是鹅打字。Beazley 和 Jones 的 *Python 食谱](https://fpy.li/pycook3)* ，第 3 版。(O'Reilly)有一节是关于定义 ABC 的(配方 8.12)。这本书是在 Python 3.4 之前写的，所以他们没有使用现在首选的通过从`abc.ABC`子类化来声明 ABC 的语法(相反，他们使用了`metaclass`关键字，我们只有在[第 24 章中才真正需要它)。除了这个小细节，食谱很好地涵盖了 ABC 的主要特点。

Doug Hellmann (Addison-Wesley)的 Python 标准库示例(T17)中有一章是关于`abc`模块的。在 Doug 的优秀的[*py motw*——本周 Python 模块](https://fpy.li/13-51)中也可以找到它。Hellmann 也使用了 ABC 声明的旧风格:`PluginBase(metaclass=abc.ABCMeta)`，而不是 Python 3.4 以来可用的更简单的`PluginBase(abc.ABC)`。

当使用 ABC 时，多重继承不仅是常见的，而且实际上是不可避免的，因为每个基本集合 ABC—`Sequence`、`Mapping`和`Set`—都扩展了`Collection`，而后者又扩展了多个 ABC(参见图 13-4 )。因此，第 14 章是这个的重要后续。

[PEP 3119—引入抽象基类](https://fpy.li/13-52)给出了 ABCs 的基本原理。[PEP 3141—数字的类型层次结构](https://fpy.li/13-53)呈现了 [`numbers`模块](https://fpy.li/13-54)的 ABC，但是 Mypy 问题[# 3186“int 不是数字？”](https://fpy.li/13-55)包括一些关于为什么数字塔不适合静态类型检查的争论。Alex Waygood 在 StackOverflow 上写了一篇[综合回答，讨论了注释数值类型的方法。我将继续关注 Mypy issue](https://fpy.li/13-56) [#3186](https://fpy.li/13-55) 的后续章节，希望有一个圆满的结局，让静态类型和 goose 类型兼容——就像它们应该的那样。

^(1) *设计模式:可复用面向对象软件的要素*《简介》第 18 页。

^(2) 维基百科上的[【猴子补丁】](https://fpy.li/13-4)文章中有一个用 Python 写的搞笑例子。

这就是为什么自动化测试是必要的。

^(4) 比雅尼·斯特劳斯特鲁普，*c++*的设计与进化，第 278 页(Addison-Wesley)。

^(5) 检索 2020 年 10 月 18 日。

当然，你也可以定义自己的 ABC——但是我不鼓励除了最高级的 python stas 之外的所有人走这条路，就像我不鼓励他们定义自己的自定义元类一样……甚至对于所说的“最高级的 python stas ”,我们这些对语言中的每一个折叠和折痕都有深刻掌握的人来说，这些都不是经常使用的工具。如果合适的话，这种“深度元编程”是为那些由大量独立开发团队独立扩展的广泛框架的作者而设计的……不到 1%的“最高级 Pythonistas”可能需要这种编程！— *上午*

^(7) 多重继承被*认为是有害的*被排除在 Java 之外，接口除外:Java 接口可以扩展多个接口，Java 类可以实现多个接口。

^(8) 也许客户需要审计随机数发生器；或者代理商想提供一个作弊的。你永远不知道…

^(9) 注册和虚拟子类都不是标准的 UML 术语。我用它们来表示特定于 Python 的类关系。

^(10) 在 ABCs 存在之前，抽象方法会提升`NotImplementedError`来表示子类负责它们的实现。在 Smalltalk-80 中，抽象方法体会调用`subclassResponsibility`，这是一个从`object`继承的方法，会产生一个错误消息，“我的子类应该覆盖了我的一个消息。”

^(11) 完整的树在第 5.4 节。Python 标准库文档*的“异常层次结构”。*

^(12)[`@abc.abstractmethod`](https://fpy.li/13-19)条目在 [`abc`模块文档](https://fpy.li/13-20)中。

^(13)](ch06.xhtml#defensive_argument)[第 6 章中的“具有可变参数的防御性编程”专门讨论了我们在这里刚刚避开的别名问题。

^(14) 我对`load()`使用的相同技巧对`loaded()`不起作用，因为`list`类型不实现`__bool__`，该方法我必须绑定到`loaded`。内置的`bool()`不需要`__bool__`工作，因为它也可以使用`__len__`。参见[4.1。Python 文档的“内置类型”一章中的](https://fpy.li/13-23)真值测试。

^(15) 在“多重继承和方法解析顺序”中有一整节讲解`__mro__`类属性。现在，这个简单的解释就可以了。

^(16) 类型一致性的概念在“Subtype-of vs consistent-with”中解释过。

^(17) 好了，`double()`不是很有用，除了作为例子。但是 Python 标准库有许多函数在 Python 3.8 中添加静态协议之前无法正确注释。我通过使用协议添加类型提示，帮助修复了*类型化*中的几个错误。例如，修复了[的 pull 请求“Mypy 应该向`max`警告潜在的无效参数吗？”](https://fpy.li/shed4051)利用了一个`_SupportsLessThan`协议，我用它来增强对`max`、`min`、`sorted`和`list.sort`的注释。

^(18)`__slots__`属性与当前的讨论无关——它是我们在“用 __slots__”中介绍过的优化。

^(19) 感谢 [PEP 544](https://fpy.li/pep544) (关于协议)的合著者 Ivan Levkivskyi 指出类型检查不仅仅是检查`x`的类型是否是`T`的问题:它是关于确定`x`的类型是否与*一致——与* `T`一致，这可能是昂贵的。难怪 Mypy 需要几秒钟的时间来键入 check，即使是很短的 Python 脚本。

^(20) 阅读 Python 指导委员会关于 python-dev 的[决定](https://fpy.li/13-32)。

^(21) 每个方法都是可调用的，所以这个准则不多说了。或许“提供一两种方法”？反正是准则，不是严格的规定。

^(22) 有关详细信息和基本原理，请参见 PEP 544—协议:结构子类型(静态鸭类型)中关于 [`@runtime_checkable`](https://fpy.li/13-37) 的部分。

^(23) 再次请阅读 PEP 544 中的[【合并和扩展协议】](https://fpy.li/13-38)了解详情和基本原理。

^(24) 见[Issue # 41974—删除`complex.__float__`、`complex.__floordiv__`等](https://fpy.li/13-41)。

我没有测试 NumPy 提供的所有其他浮点和整数变量。

^(27) 这是 typeshed 的善意谎言:从 Python 3.9 开始，内置的`complex`类型实际上没有`__complex__`方法。

^(28) 感谢技术评论家 Jürgen Gmach 推荐“接口和协议”这篇文章。