<link href="Styles/Style00.css" rel="stylesheet" type="text/css"> <link href="Styles/Style01.css" rel="stylesheet" type="text/css"> 

# 第十五章。关于类型提示的更多信息

> 我得到了一个惨痛的教训，对于小程序来说，动态打字是很棒的。对于大型程序，你需要一个更有纪律的方法。如果这种语言能给你这种纪律，而不是告诉你“嗯，你可以做任何你想做的事情”，那会很有帮助。
> 
> 吉多·范·罗苏姆，天魔迷 [1]

这一章是第 8 章的续集，涵盖了更多 Python 的渐进类型系统。主要议题是:

*   重载函数签名

*   `typing.TypedDict`为类型提示`dicts`用作记录

*   铅字铸造

*   对类型提示的运行时访问

*   泛型类型

    *   声明泛型类

    *   方差:不变、协变和逆变类型

    *   通用静态协议

# 本章的新内容

这个章节是*流畅 Python* 第二版新增的。让我们从过载开始。

# 超载签名

Python 函数 可能接受不同的参数组合。`@typing.overload`装饰器允许注释这些不同的组合。当函数的返回类型依赖于两个或多个参数的类型时，这一点尤其重要。

考虑一下`sum`内置函数。这是`help(sum)`的正文:

```
>>> help(sum)
sum(iterable, /, start=0)
    Return the sum of a 'start' value (default: 0) plus an iterable of numbers

    When the iterable is empty, return the start value.
    This function is intended specifically for use with numeric values and may
    reject non-numeric types.
```

`sum`内置是用 C 写的，但是 *typeshed* 对它有重载类型提示，在[*builtins . pyi*](https://fpy.li/15-2):中

```
@overload
def sum(__iterable: Iterable[_T]) -> Union[_T, int]: ...
@overload
def sum(__iterable: Iterable[_T], start: _S) -> Union[_T, _S]: ...
```

首先让我们看看重载的整体语法。这就是你可以在存根文件(*)中找到的关于`sum`的所有代码。pyi* )。实现将在不同的文件中。省略号(`...`)除了满足函数体的语法要求之外没有其他功能，类似于`pass`。所以*。pyi* 文件是有效的 Python 文件。

正如在“仅标注位置参数和变量参数”中提到的，`__iterable`中的两个前导下划线是由 Mypy 实施的用于仅位置参数的 PEP 484 约定。意思是可以调用`sum(my_list)`，不能调用`sum(__iterable = my_list)`。

类型检查器尝试按顺序将给定的参数与每个重载签名进行匹配。调用`sum(range(100), 1000)`与第一个重载不匹配，因为那个签名只有一个参数。但它符合第二个。

您还可以在常规 Python 模块中使用`@overload`，方法是在函数的实际签名和实现之前编写重载签名。示例 15-1 显示了`sum`如何在 Python 模块中被注释和实现。

##### 示例 15-1： *mysum.py* :重载签名的`sum`函数的定义

```
importfunctoolsimportoperatorfromcollections.abcimportIterablefromtypingimportoverload,Union,TypeVarT=TypeVar('T')S=TypeVar('S')①@overloaddefsum(it:Iterable[T])->Union[T,int]:...②@overloaddefsum(it:Iterable[T],/,start:S)->Union[T,S]:...③defsum(it,/,start=0):④returnfunctools.reduce(operator.add,it,start)
```

① 我们在第二次超载中需要这第二个`TypeVar`。

② 这个签名是针对简单的情况:`sum(my_iterable)`。结果类型可能是`T`——`my_iterable`产生的元素类型——或者如果 iterable 为空，结果类型可能是`int`,因为`start`参数的默认值是`0`。

③ 给定`start`时，可以是任意类型`S`，所以结果类型为`Union[T, S]`。这就是为什么我们需要`S`。如果我们重用了`T`，那么`start`的类型必须与`Iterable[T]`的元素类型相同。

④ 实际函数实现的签名没有类型提示。

注释一行函数需要很多行。我知道，可能有点过头了。至少它不是一个`foo`函数。

如果你想通过阅读代码来了解`@overload`，那么 *typeshed* 有上百个例子。在*类型化的*上，Python 内置的[存根文件](https://fpy.li/15-3)有 186 个重载，比标准库中的任何其他重载都多。

# 利用渐进打字的优势

将目标定为 100%带注释的代码可能会导致类型提示增加很多噪音，但没有什么价值。重构来简化类型提示会导致繁琐的 API。有时更好的办法是务实地留下一段没有类型提示的代码。

我们称之为 Pythonic 的方便的 API 通常很难注释。在下一节中，我们将看到一个例子:需要六个重载来正确注释灵活的`max`内置函数。

## 最大过载

很难向利用 Python 强大动态特性的函数添加类型提示。

在研究 typeshed 时，我发现了错误报告 [#4051](https://fpy.li/shed4051) : Mypy 未能警告将`None`作为内置`max()`函数的参数之一传递是非法的，或者传递在某个时刻产生`None`的 iterable 是非法的。在这两种情况下，您都会得到如下运行时异常:

```
TypeError: '>' not supported between instances of 'int' and 'NoneType'
```

`max`的文档以这句话开始:

> 返回 iterable 中最大的项或两个或多个参数中最大的项。

对我来说，这是一个非常直观的描述。

但是如果我必须用这些术语来注释一个函数，我必须问:到底是哪个？一个可迭代的还是两个或更多的参数？

现实更复杂，因为`max`还带有两个可选的关键字参数:`key`和`default`。

我用 Python 编写了`max`，以便更容易看出它的工作原理和重载注释之间的关系(内置的`max`在 C 中)；参见示例 15-2 。

##### 示例 15-2： *mymax.py* : Python 重写的`max`函数

```
# imports and definitions omitted, see next listing

MISSING = object()
EMPTY_MSG = 'max() arg is an empty sequence'

# overloaded type hints omitted, see next listing

def max(first, *args, key=None, default=MISSING):
    if args:
        series = args
        candidate = first
    else:
        series = iter(first)
        try:
            candidate = next(series)
        except StopIteration:
            if default is not MISSING:
                return default
            raise ValueError(EMPTY_MSG) from None
    if key is None:
        for current in series:
            if candidate < current:
                candidate = current
    else:
        candidate_key = key(candidate)
        for current in series:
            current_key = key(current)
            if candidate_key < current_key:
                candidate = current
                candidate_key = current_key
    return candidate
```

这个例子的重点不是`max`的逻辑，所以除了解释`MISSING`之外，我不会花时间在它的实现上。常量`MISSING`是一个唯一的`object`实例，用作标记。这是`default=`关键字参数的默认值，因此`max`可以接受`default=None`并仍然区分这两种情况:

1.  用户没有为`default=`提供值，所以它是`MISSING`，如果`first`是空的 iterable，那么`max`会引发`ValueError`。

2.  用户为`default=`提供了一些值，包括`None`，所以如果`first`是空的可迭代的，那么`max`返回那个值。

为了解决问题#4051](https://fpy.li/shed4051) ，我编写了示例 15-3 中的代码。 ^([2)

##### 示例 15-3：*【mymax . py】*:模块顶部，有导入、定义和重载

```
from collections.abc import Callable, Iterable
from typing import Protocol, Any, TypeVar, overload, Union

class SupportsLessThan(Protocol):
    def __lt__(self, other: Any) -> bool: ...

T = TypeVar('T')
LT = TypeVar('LT', bound=SupportsLessThan)
DT = TypeVar('DT')

MISSING = object()
EMPTY_MSG = 'max() arg is an empty sequence'

@overload
def max(__arg1: LT, __arg2: LT, *args: LT, key: None = ...) -> LT:
    ...
@overload
def max(__arg1: T, __arg2: T, *args: T, key: Callable[[T], LT]) -> T:
    ...
@overload
def max(__iterable: Iterable[LT], *, key: None = ...) -> LT:
    ...
@overload
def max(__iterable: Iterable[T], *, key: Callable[[T], LT]) -> T:
    ...
@overload
def max(__iterable: Iterable[LT], *, key: None = ...,
        default: DT) -> Union[LT, DT]:
    ...
@overload
def max(__iterable: Iterable[T], *, key: Callable[[T], LT],
        default: DT) -> Union[T, DT]:
    ...
```

我的 Python 实现`max`的长度与所有类型化导入和声明的长度大致相同。由于 duck typing，我的代码没有`isinstance`检查，并提供了与那些类型提示相同的错误检查——当然，只是在运行时。

`@overload`的一个关键好处是根据给定的参数类型尽可能精确地声明返回类型。接下来，我们将通过一次一组或两组地研究`max`的重载来看到这个好处。

### 实现的参数支持 ssThan，但未提供键和默认值

```
@overload
def max(__arg1: LT, __arg2: LT, *_args: LT, key: None = ...) -> LT:
    ...
# ... lines omitted ...
@overload
def max(__iterable: Iterable[LT], *, key: None = ...) -> LT:
    ...
```

在这些情况下，输入或者是实现 `SupportsLessThan`、的`LT`类型的独立自变量，或者是这些项的`Iterable`。`max`的返回类型与实际参数或项目相同，正如我们在“有界类型变量”中看到的。

匹配这些重载的示例调用:

```
max(1, 2, -3)  # returns 2
max(['Go', 'Python', 'Rust'])  # returns 'Rust'
```

### 提供了参数键，但没有默认值

```
@overload
def max(__arg1: T, __arg2: T, *_args: T, key: Callable[[T], LT]) -> T:
    ...
# ... lines omitted ...
@overload
def max(__iterable: Iterable[T], *, key: Callable[[T], LT]) -> T:
    ...
```

输入可以是任何类型的独立项`T`或单个`Iterable[T]`，并且`key=`必须是一个可调用的函数，接受相同类型的参数`T`，并返回一个实现`SupportsLessThan`的值。`max`的返回类型与实际参数相同。

匹配这些重载的示例调用:

```
max(1, 2, -3, key=abs)  # returns -3
max(['Go', 'Python', 'Rust'], key=len)  # returns 'Python'
```

### 提供了参数默认值，但没有键

```
@overload
def max(__iterable: Iterable[LT], *, key: None = ...,
        default: DT) -> Union[LT, DT]:
    ...
```

输入是实现`SupportsLessThan`的`LT`类型项目的可迭代项。`default=`参数是当`Iterable`为空时的返回值。因此`max`的返回类型必须是类型`LT`的`Union`和参数`default`的类型。

匹配这些重载的示例调用:

```
max([1, 2, -3], default=0)  # returns 2
max([], default=None)  # returns None
```

### 提供了参数键和默认值

```
@overload
def max(__iterable: Iterable[T], *, key: Callable[[T], LT],
        default: DT) -> Union[T, DT]:
    ...
```

这些输入是:

*   任何类型的项目的一个`Iterable`

*   采用类型为`T`的参数并返回实现`SupportsLessThan`的类型为`LT`的值的 Callable

*   任何类型的默认值`DT`

`max`的返回类型必须是`T`类型的`Union`或`default`参数的类型:

```
max([1, 2, -3], key=abs, default=None)  # returns -3
max([], key=abs, default=None)  # returns None
```

## 最大超载的好处

类型提示允许 Mypy 用下面的错误消息标记一个类似于`max([None, None])`的调用:

```
mymax_demo.py:109: error: Value of type variable "_LT" of "max"
  cannot be "None"
```

另一方面，必须编写这么多行来支持类型检查器可能会阻碍人们编写像`max`这样方便灵活的函数。如果我必须重新发明`min`函数，我可以重构并重用`max`的大部分实现。但是我必须复制并粘贴所有重载的声明——即使它们对于`min`来说是相同的，除了函数名。

我的朋友 joo s . o . Bueno——我所知道的最聪明的 Python 开发者之一——在推特上发了这个:

> 虽然很难表达出`max`的签名——但它很容易就符合一个人的想法。我的理解是，与 Python 相比，注释标记的表达能力非常有限。

现在让我们研究一下`TypedDict`类型结构。它没有我一开始想象的那么有用，但是有它的用处。用`TypedDict`做实验展示了静态类型处理动态结构的局限性，比如 JSON 数据。T37

# TypedDict

###### 警告

在处理像 JSON API 响应这样的动态数据结构时，使用`TypedDict`来防止错误是很诱人的 。但是这里的例子清楚地表明，JSON 的正确处理必须在运行时完成，而不是使用静态类型检查。对于使用类型提示的 JSON 类结构的运行时检查，查看 PyPI 上的 [*pydantic*](https://fpy.li/15-5) 包。

Python 字典有时用作记录，关键字用作不同类型的字段名称和字段值。

例如，考虑用 JSON 或 Python 描述一本书的记录:

```
{"isbn": "0134757599",
 "title": "Refactoring, 2e",
 "authors": ["Martin Fowler", "Kent Beck"],
 "pagecount": 478}
```

在 Python 3.8 之前，没有好的方法来注释这样的记录，因为我们在“通用映射”中看到的映射类型将所有值限制为具有相同的类型。

这里有两个蹩脚的注释记录的尝试，就像前面的 JSON 对象一样:

`Dict[str, Any]`

这些值可以是任何类型。

`Dict[str, Union[str, int, List[str]]]`

难以阅读，并且没有保留字段名和它们各自的字段类型之间的关系:`title`应该是一个`str`，它不能是一个`int`或者一个`List[str]`。

PEP 589——typed dict:带有一组固定键的字典的类型提示解决了这个问题。示例 15-4 显示了一个简单的`TypedDict`。

##### 示例 15-4：*books . py*:`BookDict`定义

```
from typing import TypedDict

class BookDict(TypedDict):
    isbn: str
    title: str
    authors: list[str]
    pagecount: int
```

乍看之下，`typing.TypedDict`似乎是一个数据类构建器，类似于`typing.NamedTuple`—第 5 章中介绍的。

句法上的相似令人误解。`TypedDict`很不一样。它的存在只是为了类型检查器的好处，对运行时没有影响。

`TypedDict`提供了两个东西:

*   用每个“字段”的值的类型提示来注释`dict`的类语法

*   一个构造函数，它告诉类型检查器期待一个带有指定键和值的`dict`。

在运行时，像`BookDict`这样的`TypedDict`构造函数是安慰剂:它与用相同的参数调用`dict`构造函数具有相同的效果。

`BookDict`创建平面`dict`的事实也意味着:

*   伪类定义中的“字段”不创建实例属性。

*   你不能为“字段”写带有默认值的初始化器

*   不允许方法定义。

让我们探索一下`BookDict`在运行时的行为(示例 15-5 )。

##### 示例 15-5：使用`BookDict`，但不完全符合预期

```
>>> frombooksimportBookDict>>> pp=BookDict(title='Programming Pearls',①... authors='Jon Bentley',②... isbn='0201657880',... pagecount=256)>>> pp③{'title': 'Programming Pearls', 'authors': 'Jon Bentley', 'isbn': '0201657880',
 'pagecount': 256} >>> type(pp)<class 'dict'> >>> pp.title④Traceback (most recent call last):
 File "<stdin>", line 1, in <module>AttributeError: 'dict' object has no attribute 'title'>>> pp['title']'Programming Pearls' >>> BookDict.__annotations__⑤{'isbn': <class 'str'>, 'title': <class 'str'>, 'authors': typing.List[str],
 'pagecount': <class 'int'>}
```

① 您可以像调用带有关键字参数的`dict`构造函数一样调用`BookDict`，或者传递一个`dict`参数——包括一个`dict`文字。

② 哎呀…我忘了`authors`拿清单。但是逐步键入意味着在运行时没有类型检查。

③ 调用`BookDict`的结果是一个普通的`dict` …

④ …因此，您不能使用`object.field`符号读取数据。

⑤ 类型提示在`BookDict.__annotations__`中，不在`pp`中。

如果没有类型检查器，`TypedDict`就像注释一样有用:它可以帮助人们阅读代码，但仅此而已。相比之下，即使你不使用类型检查器，第 5 章中的类构建器也是有用的，因为在运行时它们会生成或增强你可以实例化的自定义类。它们还提供了表 5-1 中列出的几种有用的方法或功能。

示例 15-6 建立一个有效的`BookDict`并在其上尝试一些操作。这显示了`TypedDict`如何使 Mypy 捕捉错误，如示例 15-7 所示。

##### 示例 15-6： *demo_books.py* :合法与非法操作上一个`BookDict`

```
frombooksimportBookDictfromtypingimportTYPE_CHECKINGdefdemo()->None:①book=BookDict(②isbn='0134757599',title='Refactoring, 2e',authors=['Martin Fowler','Kent Beck'],pagecount=478)authors=book['authors']③ifTYPE_CHECKING:④reveal_type(authors)⑤authors='Bob'⑥book['weight']=4.2delbook['title']if__name__=='__main__':demo()
```

① 记得添加一个返回类型，这样 Mypy 就不会忽略这个函数。

② 这是一个有效的`BookDict`:所有的键都存在，具有正确类型的值。

③ Mypy 将从`BookDict`中`'authors'`键的注释中推断出`authors`的类型。

④ `typing.TYPE_CHECKING`仅在程序进行类型检查时为`True`。在运行时，它总是假的。

⑤ 前面的`if`语句阻止`reveal_type(authors)`在运行时被调用。`reveal_type`不是运行时 Python 函数，而是 Mypy 提供的调试工具。这就是为什么它没有`import`的原因。其输出见示例 15-7 。

⑥ `demo`函数的最后三行是非法的。它们将导致示例 15-7 中的错误信息。

类型检查 *demo_books.py* 从示例 15-6 ，我们得到示例 15-7 。

##### 示例 15-7：类型检查 *demo_books.py*

```
…/typeddict/ $ mypy demo_books.py
demo_books.py:13: note: Revealed type is 'built-ins.list[built-ins.str]'  ①
demo_books.py:14: error: Incompatible types in assignment
                  (expression has type "str", variable has type "List[str]")  ②
demo_books.py:15: error: TypedDict "BookDict" has no key 'weight'  ③
demo_books.py:16: error: Key 'title' of TypedDict "BookDict" cannot be deleted  ④
Found 3 errors in 1 file (checked 1 source file)
```

① 这个笔记是`reveal_type(authors)`的结果。

② `authors`变量的类型是从初始化它的`book'authors']`表达式的类型中推断出来的。你不能把一个`str`赋值给一个`List[str]`类型的变量。类型检查器通常不允许变量的类型改变。 ^([3)

③ 不能分配给不属于`BookDict`定义的键。

④ 无法删除属于`BookDict`定义一部分的键。

现在让我们看看在函数签名中使用的`BookDict`，来检查函数调用的类型。

假设您需要从图书记录中生成 XML，如下所示:

```
<BOOK>
  <ISBN>0134757599</ISBN>
  <TITLE>Refactoring, 2e</TITLE>
  <AUTHOR>Martin Fowler</AUTHOR>
  <AUTHOR>Kent Beck</AUTHOR>
  <PAGECOUNT>478</PAGECOUNT>
</BOOK>
```

如果你正在编写嵌入到微型微控制器中的 MicroPython 代码，你可能会编写一个类似于示例 15-8 中所示的函数。 [4]

##### 示例 15-8： *books.py* : `to_xml`功能

```
AUTHOR_ELEMENT='<AUTHOR>{}</AUTHOR>'defto_xml(book:BookDict)->str:①elements:list[str]=[]②forkey,valueinbook.items():ifisinstance(value,list):③elements.extend(AUTHOR_ELEMENT.format(n)forninvalue)④else:tag=key.upper()elements.append(f'<{tag}>{value}</{tag}>')xml='\n\t'.join(elements)returnf'<BOOK>\n\t{xml}\n</BOOK>'
```

① 这个例子的要点是:在函数签名中使用`BookDict`。

② 通常有必要对开始为空的集合进行注释，否则 Mypy 无法推断出元素的类型。 [5]

③ Mypy 理解`isinstance`检查，并将`value`视为该块中的`list`。

④ 当我用`key == 'authors'`作为`if`守护这个块的条件时，Mypy 在这一行发现了一个错误:`"object" has no attribute "__iter__"`，因为它把`book.items()`返回的`value`的类型推断为`object`，不支持生成器表达式所要求的`__iter__`方法。使用`isinstance`检查，这是可行的，因为 Mypy 知道`value`是这个块中的一个`list`。

示例 15-9 显示了一个解析 JSON `str`并返回`BookDict`的函数。

##### 示例 15-9： books_any.py: `from_json`功能

```
deffrom_json(data:str)->BookDict:whatever=json.loads(data)①returnwhatever②
```

① `json.loads()`的返回类型为`Any`。 [6]

② 我可以返回`whatever`——类型为`Any`——因为`Any`与*一致——每种类型都与*一致，包括声明的返回类型`BookDict`。

示例 15-9 的第二点非常重要，要记住:Mypy 不会标记这段代码中的任何问题，但是在运行时`whatever`中的值可能不符合`BookDict`结构——事实上，它可能根本不是一个`dict`！

如果用`--disallow-any-expr`运行 Mypy，它会抱怨`from_json`正文中的两行:

```
…/typeddict/ $ mypy books_any.py --disallow-any-expr
books_any.py:30: error: Expression has type "Any"
books_any.py:31: error: Expression has type "Any"
Found 2 errors in 1 file (checked 1 source file)
```

前面代码片段中提到的第 30 行和第 31 行是`from_json`函数的主体。我们可以通过在`whatever`变量的初始化中添加类型提示来消除类型错误，如示例 15-10 所示。

##### 示例 15-10： books.py: `from_json`带变量注释的函数

```
deffrom_json(data:str)->BookDict:whatever:BookDict=json.loads(data)①returnwhatever②
```

① 当类型为`Any`的表达式被立即赋给带有类型提示的变量时，`--disallow-any-expr`不会导致错误。

② 现在`whatever`属于类型`BookDict`，即声明的返回类型。

###### 警告

不要被示例 15-10 误导了！查看静态代码，类型检查器无法预测`json.loads()`将返回任何类似于`BookDict`的内容。只有运行时验证才能保证这一点。

静态类型检查无法防止固有动态代码的错误，例如`json.loads()`，它在运行时构建不同类型的 Python 对象，如示例 15-11 、 15-12 和 15-13 所示。

##### 示例 15-11： demo_not_book.py: `from_json`返回无效的`BookDict`，`to_xml`接受

```
frombooksimportto_xml,from_jsonfromtypingimportTYPE_CHECKINGdefdemo()->None:NOT_BOOK_JSON=""" {"title": "Andromeda Strain","flavor": "pistachio","authors": true}"""not_book=from_json(NOT_BOOK_JSON)①ifTYPE_CHECKING:②reveal_type(not_book)reveal_type(not_book['authors'])print(not_book)③print(not_book['flavor'])④xml=to_xml(not_book)⑤print(xml)⑥if__name__=='__main__':demo()
```

① 该行不产生有效的`BookDict`——参见`NOT_BOOK_JSON`的内容。

② 让 Mypy 展示几种类型。

③ 这应该不成问题:`print`可以处理`object`和其他每一种类型。

④ `BookDict`没有`'flavor'`键，但是 JSON 源码有……会发生什么？

⑤ 记得署名:`def to_xml(book: BookDict) -> str:`。

⑥ XML 输出会是什么样子？

现在我们用 Mypy ( 示例 15-12 )检查 *demo_not_book.py* 。

##### 示例 15-12：用于 *demo_not_book.py* 的 Mypy 报告，为清晰起见，重新格式化

```
…/typeddict/ $ mypy demo_not_book.py
demo_not_book.py:12: note: Revealed type is
   'TypedDict('books.BookDict', {'isbn': built-ins.str,
                                 'title': built-ins.str,
                                 'authors': built-ins.list[built-ins.str],
                                 'pagecount': built-ins.int})'  ①
demo_not_book.py:13: note: Revealed type is 'built-ins.list[built-ins.str]'  ②
demo_not_book.py:16: error: TypedDict "BookDict" has no key 'flavor'  ③
Found 1 error in 1 file (checked 1 source file)
```

① 揭示的类型是名义类型，不是`not_book`的运行时内容。

② 同样，这是`BookDict`中定义的`not_book['authors']`的标称类型。不是运行时类型。

③ 该错误针对行`print(not_book['flavor'])`:该键在名义类型中不存在。

现在让我们运行 *demo_not_book.py* ，显示示例 15-13 中的输出。

##### 示例 15-13：运行输出`demo_not_book.py`

```
…/typeddict/ $ python3 demo_not_book.py
{'title': 'Andromeda Strain', 'flavor': 'pistachio', 'authors': True}  ①
pistachio  ②
<BOOK>  ③
        <TITLE>Andromeda Strain</TITLE>
        <FLAVOR>pistachio</FLAVOR>
        <AUTHORS>True</AUTHORS>
</BOOK>
```

① 这其实不是一个`BookDict`。

② `not_book['flavor']`的值。

③ `to_xml`有一个`BookDict`参数，但是没有运行时检查:垃圾入，垃圾出。

示例 15-13 显示 *demo_not_book.py* 输出无意义，但没有运行时错误。在处理 JSON 数据时使用`TypedDict`并没有提供多少类型安全性。

如果你从鸭子类型的角度来看示例 15-8 中`to_xml`的代码，参数`book`必须提供一个`.items()`方法，该方法返回类似`(key, value)`的元组的 iterable，其中:

*   `key`必须有一个`.upper()`方法

*   `value`可以是任何东西

本演示的要点是:当处理具有动态结构的数据时，比如 JSON 或 XML，`TypedDict`绝对不能代替运行时的数据验证。为此，使用 [*pydantic*](https://fpy.li/15-5) 。

`TypedDict`有更多的特性，包括对可选键的支持、有限的继承形式和可选的声明语法。如果你想了解更多，请查阅 [PEP 589—TypedDict:具有固定键集的字典的类型提示](https://fpy.li/pep589)。

现在让我们把注意力转向一个最好避免的功能，但有时是不可避免的:`typing.cast`。

# 铅字铸造

没有 类型系统是完美的，静态类型检查器、*类型化的*项目中的类型提示或者拥有它们的第三方包中的类型提示也是如此。

`typing.cast()`特殊函数提供了一种方法来处理我们无法修复的代码中的类型检查故障或不正确的类型提示。Mypy 0.930 文档解释道:

> 强制转换用于消除虚假的类型检查器警告，并在类型检查器不能完全理解发生了什么时给它一点帮助。

在运行时，`typing.cast`什么也不做。这是它的[实现](https://fpy.li/15-15):

```
def cast(typ, val):
    """Cast a value to a type.
 This returns the value unchanged.  To the type checker this
 signals that the return value has the designated type, but at
 runtime we intentionally don't check anything (we want this
 to be as fast as possible).
 """
    return val
```

PEP 484 要求类型检查器“盲目相信”在`cast`中声明的类型。PEP 484 的[“Casts”部分给出了一个类型检查器需要`cast`指导的例子:](https://fpy.li/15-16)

```
from typing import cast

def find_first_str(a: list[object]) -> str:
    index = next(i for i, x in enumerate(a) if isinstance(x, str))
    # We only get here if there's at least one string
    return cast(str, a[index])
```

对生成器表达式的`next()`调用将返回一个`str`项的索引或者引发`StopIteration`。因此，如果没有引发异常，`find_first_str`将始终返回一个`str`，并且`str`是声明的返回类型。

但是如果最后一行只有`return aindex]`，Mypy 会推断返回类型为`object`，因为`a`参数被声明为`list[object]`。所以需要`cast()`来引导 Mypy。 ^([7)

这里是另一个关于`cast`的例子，这次是为了纠正 Python 标准库的一个过时的类型提示。在示例 21-12 中，我创建了一个 *asyncio* `Server`对象，我想获取服务器正在监听的地址。我编写了这行代码:

```
addr = server.sockets[0].getsockname()
```

但是 Mypy 报告了这个错误:

```
Value of type "Optional[List[socket]]" is not indexable
```

2021 年 5 月*typed*上`Server.sockets`的类型提示对 Python 3.6 有效，其中`sockets`属性可能是`None`。但是在 Python 3.7 中，`sockets`变成了一个带有 getter 的属性，它总是返回一个`list`——如果服务器没有套接字，这个属性可能是空的。而且从 Python 3.8 开始，getter 返回一个`tuple`(用作不可变序列)。

由于我现在不能修复*排版*， [8] 我加了一个`cast`，像这样:

```
from asyncio.trsock import TransportSocket
from typing import cast

# ... many lines omitted ...

    socket_list = cast(tuple[TransportSocket, ...], server.sockets)
    addr = socket_list[0].getsockname()
```

在这种情况下使用`cast`需要几个小时来理解问题，并阅读 *asyncio* 源代码来找到正确的套接字类型:来自未记录的`asyncio.trsock`模块的`TransportSocket`类。为了可读性，我还必须添加两个`import`语句和另一行代码。 [9] 但是代码更安全。

细心的读者可能会注意到，如果`sockets`为空，则`sockets0]`可能会升起`IndexError`。然而，就我对`asyncio`的理解，这不会发生在[示例 21-12 中，因为在我读取其`sockets`属性时`server`已准备好接受连接，因此它不会为空。反正`IndexError`是运行时错误。即使在像`print([][0])`这样微不足道的情况下，Mypy 也不能发现问题。

###### 警告

不要太习惯使用`cast`来沉默 Mypy，因为 Mypy 在报告错误时通常是正确的。如果你经常使用`cast`，那就是一个[码气味](https://fpy.li/15-20)。您的团队可能误用了类型提示，或者您的代码库中可能有低质量的依赖项。

尽管有缺点，但`cast`还是有其正当的用途。这是吉多·范·罗苏姆写的一些东西:

> 偶尔的`cast()`来电或者`# type: ignore`评论有什么不好？^(101024】)

完全禁止使用`cast`是不明智的，尤其是因为其他变通方法更糟糕:

*   `# type: ignore`信息量少。 [11]

*   使用`Any`具有传染性:因为`Any`与*一致——与*所有类型一致，滥用它可能会通过类型推断产生级联效应，破坏类型检查器检测代码其他部分错误的能力。

当然，并不是所有的打字错误都能用`cast`解决。有时我们需要`# type: ignore`，偶尔需要`Any`，或者甚至让一个函数没有类型提示。

接下来，我们来谈谈在运行时使用注释。

# 运行时读取类型提示

在导入时，Python 读取函数、类和模块中的类型提示，并将它们存储在名为`__annotations__`的属性中。例如，考虑示例 15-14 中的`clip`功能。 [12]

##### 示例 15-14： clipannot.py:一个`clip`函数的注释签名

```
def clip(text: str, max_len: int = 80) -> str:
```

类型提示作为一个`dict`存储在函数的`__annotations__`属性中:

```
>>> from clip_annot import clip
>>> clip.__annotations__
{'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}
```

`'return'`键映射到示例 15-14 中`->`符号后的返回类型提示。

请注意，注释是由解释器在导入时评估的，就像参数默认值也被评估一样。这就是为什么注释中的值是 Python 类`str`和`int`，而不是字符串`'str'`和`'int'`。注释的导入时间评估是 Python 3.10 的标准，但是如果 [PEP 563](https://fpy.li/pep563) 或 [PEP 649](https://fpy.li/pep649) 成为标准行为，这可能会改变。

## 运行时注释的问题

类型提示使用的增加引发了两个问题:

*   当使用许多类型提示时，导入模块会使用更多的 CPU 和内存。

*   引用尚未定义的类型需要使用字符串而不是实际类型。

这两个问题都是相关的。第一个原因是我们刚刚看到的:注释在导入时由解释器进行评估，并存储在`__annotations__`属性中。现在让我们关注第二个问题。

将注释存储为字符串有时是必需的，因为“正向引用”问题:当一个类型提示需要引用同一个模块中下面定义的类时。然而，该问题在源代码中的一个常见表现看起来根本不像是向前引用:那是当一个方法返回一个相同类的新对象时。因为直到 Python 完全评估了类主体，类对象才被定义，所以类型提示必须使用类的名称作为字符串。这里有一个例子:

```
class Rectangle:
    # ... lines omitted ...
    def stretch(self, factor: float) -> 'Rectangle':
        return Rectangle(width=self.width * factor)
```

从 Python 3.10 开始，将前向引用类型提示写成字符串是标准的、必需的做法。静态类型检查器从一开始就被设计用来处理这个问题。

但是在运行时，如果您编写代码来读取`stretch`的`return`注释，您将获得一个字符串`'Rectangle'`，而不是对实际类型`Rectangle`类的引用。现在你的代码需要弄清楚这个字符串是什么意思。

`typing`模块包括三个函数和一个分类为[自省助手](https://fpy.li/15-24)的类，其中最重要的是`typing.get_type_hints`。其文件的一部分指出:

`get_type_hints(obj, globals=None, locals=None, include_extras=False)`

[…]这通常与`obj.__annotations__`相同。此外，通过在`globals`和`locals`名称空间中对编码为字符串的前向引用进行求值来处理它们。[…]

###### 警告

从 Python 3.10 开始，应该使用新的 [`inspect.get_annotations(…)`](https://fpy.li/15-25) 函数，而不是`typing.​get_​type_​hints`。然而，有些读者可能还没有使用 Python 3.10，所以在例子中我将使用`typing.​get_​type_​hints`，因为在 Python 3.5 中添加了`typing`模块，所以可以使用它。

[PEP 563—注释的延期评估](https://fpy.li/pep563)被批准，以使不必将注释写成字符串，并减少类型提示的运行时开销。其主要思想在[【摘要】](https://fpy.li/15-26)的这两句话中有所描述:

> 这个 PEP 建议改变函数注释和变量注释，使它们不再在函数定义时被求值。相反，它们以字符串形式保存在*注释*中。

从 Python 3.7 开始，这就是在任何以这个`import`语句开始的模块中处理注释的方式:

```
from __future__ import annotations
```

为了演示它的效果，我把来自示例 15-14 的同一个`clip`函数的副本放在一个 *clip_annot_post.py* 模块中，那个`__future__`导入行在顶部。

在控制台上，当我导入该模块并从`clip`中读取注释时，我得到了以下结果:

```
>>> from clip_annot_post import clip
>>> clip.__annotations__
{'text': 'str', 'max_len': 'int', 'return': 'str'}
```

正如你所看到的，所有的类型提示现在都是普通的字符串，尽管在`clip`的定义中它们没有被写成带引号的字符串(示例 15-14 )。

`typing.get_type_hints`函数能够解析许多类型提示，包括那些在`clip`中的:

```
>>> from clip_annot_post import clip
>>> from typing import get_type_hints
>>> get_type_hints(clip)
{'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}
```

调用`get_type_hints`给了我们真正的类型——即使在某些情况下，原始类型提示被写成带引号的字符串。这是在运行时读取类型提示的推荐方式。

在 Python 3.10 中，PEP 563 行为被设定为默认行为，不需要`__future__`导入。然而， *FastAPI* 和 *pydantic* 的维护者提出了警告，称这种变化会破坏他们在运行时依赖类型提示的代码，无法可靠地使用`get_type_hints`。

在随后关于 python-dev 邮件列表的讨论中，PEP 563 的作者 ukasz Langa 描述了该函数的一些局限性:

> ……]事实证明`typing.get_type_hints()`有一些限制，使得它在运行时的使用成本很高，更重要的是不足以解析所有类型。最常见的例子是处理生成类型的非全局上下文(例如，内部类、函数中的类等)。).但是如果使用了类生成器，那么`typing.get_type_hints()`也不能正确处理前向引用的一个典型例子:具有接受或返回自身类型对象的方法的类。我们可以用一些诡计来把这些点联系起来，但总的来说这并不太好。 ^([13)

Python 的指导委员会决定推迟将 PEP 563 作为默认行为，直到 Python 3.11 或更高版本，给开发人员更多的时间来提出一个解决方案，解决 PEP 563 试图解决的问题，而不破坏运行时类型提示的广泛使用。[PEP 649——使用描述符](https://fpy.li/pep649)的注释的延期评估作为一种可能的解决方案正在考虑中，但可能会达成不同的折衷方案。

综上所述:从 Python 3.10 开始，在运行时读取类型提示并不是 100%可靠的，并且很可能在 2022 年改变。

###### 注意

大规模使用 Python 的公司想要静态类型化的好处，但是他们不想为导入时类型提示的求值付出代价。静态检查发生在开发人员工作站和专用 CI 服务器上，但是在生产容器中加载模块的频率和数量要高得多，这种成本在规模上是不可忽略的。

这在 Python 社区中造成了紧张，有些人希望类型提示仅存储为字符串，以减少加载成本，而有些人也希望在运行时使用类型提示，如 *pydantic* 和 *FastAPI* 的创建者和用户，他们宁愿存储类型对象，而不是评估那些注释，这是一项具有挑战性的任务。

## 处理问题

鉴于目前不稳定的情况，如果需要在运行时读取注释，我推荐:

*   避免直接阅读`__annotations__`；而是使用`inspect.get_annotations`(从 Python 3.10 开始)或者`typing.get_type_hints`(从 Python 3.5 开始)。

*   编写一个你自己的定制函数，作为对`in​spect​.get_annotations`或`typing.get_type_hints`的一个薄薄的包装，并让你的代码库的其余部分调用这个定制函数，这样将来的变化就局限在一个单独的函数中了。

为了演示第二点，下面是示例 24-5 中定义的`Checked`类的第一行，我们将在第 24 章中学习:

```
class Checked:
    @classmethod
    def _fields(cls) -> dict[str, type]:
        return get_type_hints(cls)
    # ... more lines ...
```

`Checked._fields`类方法保护模块的其他部分不直接依赖于`typing.get_type_hints`。如果`get_type_hints`将来发生变化，需要额外的逻辑，或者你想用`inspect.get_annotations`替换它，这种变化仅限于`Checked._fields`，并不影响你的程序的其余部分。

###### 警告

鉴于正在进行的讨论和对类型提示的运行时检查提出的更改，官方的[“注释最佳实践”](https://fpy.li/15-28)文档是必读的，并且可能会在 Python 3.11 的道路上更新。该指南由 Larry Hastings 撰写，他是[PEP 649——使用描述符](https://fpy.li/pep649)延迟注释评估的作者，这是解决[PEP 563——延迟注释评估提出的运行时问题的替代方案。](https://fpy.li/pep563)

本章的剩余部分将讨论泛型，从如何定义一个可以被用户参数化的泛型类开始。

# 实现泛型类

在 示例 13-7](ch13.xhtml#ex_tombola_abc) 中，我们定义了`Tombola` ABC:一个像宾果笼子一样工作的类的接口。来自示例 13-10 的`LottoBlower`类是一个具体的实现。现在我们将研究`LottoBlower`的通用版本，就像在[示例 15-15 中使用的一样。

##### 示例 15-15： generic_lotto_demo.py:使用一个通用的彩票鼓风机类

```
fromgeneric_lottoimportLottoBlowermachine=LottoBlower[int](range(1,11))①first=machine.pick()②remain=machine.inspect()③
```

① 为了实例化一个泛型类，我们给它一个实际的类型参数，就像这里的`int`。

② Mypy 会正确地推断出`first`是一只`int` …

③ …并且`remain`是一个整数的`tuple`。

此外，Mypy 用有用的消息报告参数化类型的违规，如示例 15-16 中所示。

##### 示例 15-16： generic_lotto_errors.py:由 Mypy 报告的错误

```
fromgeneric_lottoimportLottoBlowermachine=LottoBlower[int]([1,.2])## error: List item 1 has incompatible type "float"; ①##        expected "int"machine=LottoBlower[int](range(1,11))machine.load('ABC')## error: Argument 1 to "load" of "LottoBlower" ②##        has incompatible type "str";##        expected "Iterable[int]"## note:  Following member(s) of "str" have conflicts:## note:      Expected:## note:          def __iter__(self) -> Iterator[int]## note:      Got:## note:          def __iter__(self) -> Iterator[str]
```

① 在实例化`LottoBlower[int]`时，Mypy 标记`float`。

② 在调用`.load('ABC')`时，Mypy 解释了为什么一个`str`不行:`str.__iter__`返回一个`Iterator[str]`，但是`LottoBlower[int]`需要一个`Iterator[int]`。

示例 15-17 为示例。

##### 示例 15-17： generic_lotto.py:一个通用的彩票鼓风机类

```
importrandomfromcollections.abcimportIterablefromtypingimportTypeVar,GenericfromtombolaimportTombolaT=TypeVar('T')classLottoBlower(Tombola,Generic[T]):①def__init__(self,items:Iterable[T])->None:②self._balls=list[T](items)defload(self,items:Iterable[T])->None:③self._balls.extend(items)defpick(self)->T:④try:position=random.randrange(len(self._balls))exceptValueError:raiseLookupError('pick from empty LottoBlower')returnself._balls.pop(position)defloaded(self)->bool:⑤returnbool(self._balls)definspect(self)->tuple[T,...]:⑥returntuple(self._balls)
```

① 泛型类声明经常使用多重继承，因为我们需要子类化`Generic`来声明正式的类型参数——在本例中是`T`。

② `__init__`中的`items`参数属于`Iterable[T]`类型，当一个实例被声明为`LottoBlower[int]`时，它就变成了`Iterable[int]`。

③ `load`方法同样受到限制。

④ `T`的返回类型现在变成了`LottoBlower[int]`中的`int`。

⑤ 这里没有类型变量。

⑥ 最后，`T`设置返回的`tuple`中条目的类型。

###### 小费

`typing`模块文档的[“用户定义的泛型类型”](https://fpy.li/15-29)部分很短，给出了很好的例子，并提供了一些我在这里没有涉及的细节。

现在我们已经看到了如何实现一个泛型类，让我们定义术语来讨论泛型。

## 泛型类型的基本术语

下面是我在学习泛型时发现有用的几个定义: [14]

Generic type

用一个或多个类型变量声明的类型。
例子:`LottoBlower[T]`，`abc.Mapping[KT, VT]`

Formal type parameter

出现在泛型类型声明中的类型变量。
示例:上例`abc.Mapping[KT, VT]`中的`KT`和`VT`

Parameterized type

用实际类型参数声明的类型。
例子:`LottoBlower[int]`，`abc.Mapping[str, float]`

Actual type parameter

当声明参数化类型时，作为参数给出的实际类型。
举例:`LottoBlower[int]`中的`int`

下一个主题是如何使泛型类型更加灵活，引入了协变、逆变和不变性的概念。

# 差异

###### 注意

根据你在其他语言中使用泛型的经验，这可能是本书中最具挑战性的部分。方差的概念是抽象的，严谨的表述会让这一部分看起来像数学书的书页。

实际上，variance 主要与想要支持新的通用容器类型或提供基于回调的 API 的库作者有关。即使这样，您也可以通过只支持不变容器来避免太多的复杂性——这是我们现在在 Python 标准库中所拥有的。因此，在第一次阅读时，你可以跳过整个章节，或者只阅读关于不变类型的章节。

我们首先在“可调用类型中的方差”中看到了*方差*的概念，应用于参数化泛型`Callable`类型。在这里，我们将扩展这个概念来涵盖一般的集合类型，使用一个“真实世界”的类比来使这个抽象的概念更加具体。

想象一下，某学校食堂有规定，只能安装果汁机。 [15] 一般的饮料机是不允许的，因为它们可能会提供苏打水，这是学校董事会禁止的。 [16]

## 不变分配器

让我们试着用一个通用的`BeverageDispenser`类来模拟自助餐厅场景，这个类可以根据饮料的类型进行参数化。参见示例 15-18 。

##### 示例 15-18： invariant.py:类型定义和`install`函数

```
fromtypingimportTypeVar,GenericclassBeverage:①"""Any beverage."""classJuice(Beverage):"""Any fruit juice."""classOrangeJuice(Juice):"""Delicious juice from Brazilian oranges."""T=TypeVar('T')②classBeverageDispenser(Generic[T]):③"""A dispenser parameterized on the beverage type."""def__init__(self,beverage:T)->None:self.beverage=beveragedefdispense(self)->T:returnself.beveragedefinstall(dispenser:BeverageDispenser[Juice])->None:④"""Install a fruit juice dispenser."""
```

① `Beverage`、`Juice`、`OrangeJuice`构成类型层次。

② 简单的`TypeVar`声明。

③ `BeverageDispenser`是对饮料类型的参数化。

④ `install`是一个模块全局函数。它的类型提示强制执行只接受果汁分配器的规则。

给定示例 15-18 中的定义，以下代码是合法的:

```
juice_dispenser = BeverageDispenser(Juice())
install(juice_dispenser)
```

然而，这是不合法的:

```
beverage_dispenser = BeverageDispenser(Beverage())
install(beverage_dispenser)
## mypy: Argument 1 to "install" has
## incompatible type "BeverageDispenser[Beverage]"
##          expected "BeverageDispenser[Juice]"
```

提供任何`Beverage`服务的自动售货机都是不可接受的，因为自助餐厅需要一台专用于`Juice`的自动售货机。

有点令人惊讶的是，这段代码也是非法的:

```
orange_juice_dispenser = BeverageDispenser(OrangeJuice())
install(orange_juice_dispenser)
## mypy: Argument 1 to "install" has
## incompatible type "BeverageDispenser[OrangeJuice]"
##          expected "BeverageDispenser[Juice]"
```

也不允许使用专用于`OrangeJuice`的分配器。只有`BeverageDispenser[Juice]`可以。在打字行话中，我们说当`BeverageDispenser[OrangeJuice]`与`BeverageDispenser[Juice]`不兼容时`BeverageDispenser(Generic[T])`是不变的——尽管`OrangeJuice`是 `Juice`的*子类型。*

Python 可变集合类型——比如`list`和`set`——是不变的。来自示例 15-17 的`LottoBlower`类也是不变的。

## 协变分配器

如果我们想要更灵活，将分发器建模为一个通用类，可以接受一些饮料类型及其子类型，我们必须使它协变。示例 15-19 展示了我们如何声明`BeverageDispenser`。

##### 示例 15-19： *covariant.py* :类型定义和`install`功能

```
T_co=TypeVar('T_co',covariant=True)①classBeverageDispenser(Generic[T_co]):②def__init__(self,beverage:T_co)->None:self.beverage=beveragedefdispense(self)->T_co:returnself.beveragedefinstall(dispenser:BeverageDispenser[Juice])->None:③"""Install a fruit juice dispenser."""
```

① 声明类型变量时设置`covariant=True`；`_co`是*类型化*上协变类型参数的常规后缀。

② 使用`T_co`参数化`Generic`特殊类。

③ `install`的类型提示与示例 15-18 中的相同。

以下代码有效，因为现在`Juice`分配器和`OrangeJuice`分配器在协变`BeverageDispenser`中都有效:

```
juice_dispenser = BeverageDispenser(Juice())
install(juice_dispenser)

orange_juice_dispenser = BeverageDispenser(OrangeJuice())
install(orange_juice_dispenser)
```

但是一个任意的`Beverage`分配器是不可接受的:

```
beverage_dispenser = BeverageDispenser(Beverage())
install(beverage_dispenser)
## mypy: Argument 1 to "install" has
## incompatible type "BeverageDispenser[Beverage]"
##          expected "BeverageDispenser[Juice]"
```

这就是协方差:参数化分配器的子类型关系与类型参数的子类型关系的变化方向相同。

## 一种逆变垃圾桶

现在我们将为部署垃圾桶的自助餐厅规则建模。让我们假设食物和饮料装在可生物降解的包装里，剩菜和一次性使用的餐具也是可生物降解的。垃圾桶必须适用于可生物降解的垃圾。

###### 注意

为了这个教导性的例子，让我们做一些简化的假设，将垃圾按照整齐的层次进行分类:

*   `Refuse`是最常见的垃圾类型。所有的垃圾都是垃圾。

*   `Biodegradable`是一种特定类型的垃圾，可以随着时间的推移被生物体分解。有的`Refuse`不是`Biodegradable`。

*   `Compostable`是一种特定类型的`Biodegradable`垃圾，可以在堆肥箱或堆肥设施中有效地转化为有机肥料。在我们的定义中，并不是所有的垃圾都是垃圾。

为了对自助餐厅中可接受的垃圾桶的规则进行建模，我们需要通过一个使用它的例子来引入“逆变”的概念，如示例 15-20 所示。

##### 示例 15-20： *逆变. py* :类型定义和`install`功能

```
fromtypingimportTypeVar,GenericclassRefuse:①"""Any refuse."""classBiodegradable(Refuse):"""Biodegradable refuse."""classCompostable(Biodegradable):"""Compostable refuse."""T_contra=TypeVar('T_contra',contravariant=True)②classTrashCan(Generic[T_contra]):③defput(self,refuse:T_contra)->None:"""Store trash until dumped."""defdeploy(trash_can:TrashCan[Biodegradable]):"""Deploy a trash can for biodegradable refuse."""
```

① 拒绝的类型层次:`Refuse`是最一般的类型，`Compostable`是最具体的类型。

② `T_contra`是逆变型变量的常规名称。

③ `TrashCan`是关于垃圾类型的逆变。

根据这些定义，这些类型的垃圾桶是可以接受的:

```
bio_can: TrashCan[Biodegradable] = TrashCan()
deploy(bio_can)

trash_can: TrashCan[Refuse] = TrashCan()
deploy(trash_can)
```

更一般的`TrashCan[Refuse]`是可以接受的，因为它可以接受任何种类的垃圾，包括`Biodegradable`。但是，`TrashCan[Compostable]`不行，因为它不能带 `Biodegradable` :

```
compost_can: TrashCan[Compostable] = TrashCan()
deploy(compost_can)
## mypy: Argument 1 to "deploy" has
## incompatible type "TrashCan[Compostable]"
##          expected "TrashCan[Biodegradable]"
```

我们总结一下刚才看到的概念。

## 差异审查

方差是一个微妙的属性。下面几节概述了不变、协变和逆变类型的概念，并提供了一些推理它们的经验法则。

### 不变类型

当两个参数化类型之间没有父类型或子类型关系时，泛型类型`L`是不变的，不管实际参数之间可能存在的关系如何。换句话说，如果`L`不变，那么`L[A]`就不是`L[B]`的超类型或子类型。它们在两方面都不一致。

如前所述，Python 的可变集合在默认情况下是不变的。`list`类型就是一个很好的例子:`list[int]`与*不一致——与*T10 一致，反之亦然。

通常，如果一个形式类型参数出现在方法参数的类型提示中，并且同一参数出现在方法返回类型中，则该参数必须保持不变，以确保在更新和读取集合时的类型安全。

例如，下面是内置在 [*排版*](https://fpy.li/15-30) 上的`list`的部分类型提示:

```
class list(MutableSequence[_T], Generic[_T]):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[_T]) -> None: ...
    # ... lines omitted ...
    def append(self, __object: _T) -> None: ...
    def extend(self, __iterable: Iterable[_T]) -> None: ...
    def pop(self, __index: int = ...) -> _T: ...
    # etc...
```

注意`_T`出现在`__init__`、`append`和`extend`的参数中，并作为`pop`的返回类型。如果这样的类类型在`_T`中是协变的或逆变的，就没有办法使它安全。

### 协变类型

考虑两种类型`A`和`B`，其中`B`与*一致——与* `A`一致，都不是`Any`。一些作者使用`<:`和`:>`符号来表示类型关系，如下所示:

`A :> B`

`A`是的*超类型或者与`B`相同。*

`B <: A`

`B`是的*子类型或者与`A`相同。*

给定`A :> B`，当`C[A] :> C[B]`时，泛型类型`C`是协变的。

注意`:>`符号的方向在两种情况下是相同的，其中`A`在`B`的的左边。协变泛型类型遵循实际类型参数的子类型关系。

不可变容器可以是协变的。例如，`typing.FrozenSet`类就是这样被[记录为](https://fpy.li/15-31)的，它是一个使用常规名称`T_co`的类型变量的协变变量:

```
class FrozenSet(frozenset, AbstractSet[T_co]):
```

将`:>`符号应用于参数化类型，我们有:

```
           float :> int
frozenset[float] :> frozenset[int]
```

迭代器是协变泛型的另一个例子:它们不像`frozenset`那样是只读集合，但它们只产生输出。任何期望使用产生浮点数的`abc.Iterator[float]`的代码都可以安全地使用产生整数的`abc.Iterator[int]`。`Callable`出于类似的原因，类型在返回类型上是协变的。

### 逆变类型

给定`A :> B`，泛型`K`是逆变 if `K[A] <: K[B]`。

逆变泛型类型反转实际类型参数的子类型关系。

`TrashCan`类举例说明了这一点:

```
          Refuse :> Biodegradable
TrashCan[Refuse] <: TrashCan[Biodegradable]
```

逆变容器通常是只写的数据结构，也称为“接收器”在标准库中没有这种集合的例子，但是有一些带有逆变类型参数的类型。

`Callable[ParamType, …], ReturnType]`在参数类型上是逆变的，但在`ReturnType`上是协变的，正如我们在[“可调用类型的变化”中看到的。另外， `Generator`](https://fpy.li/15-32) ， [`Coroutine`](https://fpy.li/typecoro) ， [`AsyncGenerator`](https://fpy.li/15-33) 有一个逆变型参数。`Generator`类型在[“经典协程的泛型类型提示”中描述；`Coroutine`和`AsyncGenerator`在第 21 章的和中有描述。

对于当前关于方差的讨论，要点是逆变形参定义了用于调用数据或向对象发送数据的实参类型，而不同的协变形参定义了对象产生的输出类型—产出类型或返回类型，具体取决于对象。“发送”和“产出”的含义在“经典协同程序”中有解释。

我们可以从这些对协变输出和逆变输入的观察中得到有用的指导。

### 方差经验法则

最后，这里的是一些在考虑差异时要考虑的经验法则:

*   如果形式类型参数为来自对象的数据定义了一种类型，那么它可以是协变的。

*   如果一个形式类型参数为数据定义了一个类型，而这个数据在最初构造之后进入对象，那么它可能是逆变的。

*   如果一个形参为来自对象的数据定义了一个类型，而同一个形参为进入对象的数据定义了一个类型，那么形参必须是不变的。

*   为了安全起见，让形式类型参数保持不变。

`Callable[[ParamType, …], ReturnType]`演示规则#1 和# 2:`ReturnType`是协变的，每个`ParamType`是逆变的。

默认情况下，`TypeVar`创建不变的形式参数，这就是标准库中可变集合的注释方式。

“经典协程的泛型类型提示”继续当前关于方差的讨论。

接下来，让我们看看如何定义通用的静态协议，将协方差的思想应用到几个新的例子中。

# 实现通用静态协议

Python 3.10 标准库提供了一些通用的静态协议。其中一个是`SupportsAbs`，在[的*打字*模块](https://fpy.li/15-34)中是这样实现的:

```
@runtime_checkable
class SupportsAbs(Protocol[T_co]):
    """An ABC with one abstract method __abs__ that is covariant in its
 return type."""
    __slots__ = ()

    @abstractmethod
    def __abs__(self) -> T_co:
        pass
```

`T_co`是根据命名约定声明的:

```
T_co = TypeVar('T_co', covariant=True)
```

多亏了`SupportsAbs`，Mypy 识别出这个代码是有效的，正如你在示例 15-21 中看到的。

##### 示例 15-21： *abs_demo.py* :通用`SupportsAbs`协议的使用

```
importmathfromtypingimportNamedTuple,SupportsAbsclassVector2d(NamedTuple):x:floaty:floatdef__abs__(self)->float:①returnmath.hypot(self.x,self.y)defis_unit(v:SupportsAbs[float])->bool:②"""'True' if the magnitude of 'v' is close to 1."""returnmath.isclose(abs(v),1.0)③assertissubclass(Vector2d,SupportsAbs)④v0=Vector2d(0,1)⑤sqrt2=math.sqrt(2)v1=Vector2d(sqrt2/2,sqrt2/2)v2=Vector2d(1,1)v3=complex(.5,math.sqrt(3)/2)v4=1⑥assertis_unit(v0)assertis_unit(v1)assertnotis_unit(v2)assertis_unit(v3)assertis_unit(v4)print('OK')
```

① 定义`__abs__`使得`Vector2d` *与* `SupportsAbs`一致。

② 用`float`参数化`SupportsAbs`可确保…

③ Mypy 接受`abs(v)`作为`math.isclose`的第一个参数。

④ 感谢`SupportsAbs`定义中的`@runtime_checkable`，这是一个有效的运行时断言。

⑤ 其余代码都通过了 Mypy 检查和运行时断言。

⑥ `int`类型也与*一致——与*和`SupportsAbs`一致。根据[](https://fpy.li/15-35)*，`int.__abs__`返回一个`int`，它与*一致——与*在`is_unit`类型提示中为`v`实参声明的`float`类型形参一致。*

 *类似地，我们可以编写一个`RandomPicker`协议的通用版本，如示例 13-18 所示，它是用返回`Any`的单个方法`pick`定义的。

示例 15-22 展示了如何在`pick`的返回类型上生成一个泛型`RandomPicker`协变。

##### 示例 15-22：*generic _ random pick . py*:generic 的定义`RandomPicker`

```
fromtypingimportProtocol,runtime_checkable,TypeVarT_co=TypeVar('T_co',covariant=True)①@runtime_checkableclassRandomPicker(Protocol[T_co]):②defpick(self)->T_co:...③
```

① 宣布`T_co`为`covariant`。

② 这使得`RandomPicker`具有一个协变的形式类型参数。

③ 使用`T_co`作为返回类型。

泛型`RandomPicker`协议可以是协变的，因为它唯一的形参用在返回类型中。

有了这个，我们就可以称之为一章了。*  *# 章节摘要

第章从一个使用`@overload`的简单例子开始，接下来是一个我们详细研究过的更复杂的例子:正确注释`max`内置函数所需的重载签名。

接下来是`typing.TypedDict`特殊构造。我选择在这里介绍它，而不是在我们看到`typing.NamedTuple`的第 5 章中，因为`TypedDict`不是一个类构造器；这仅仅是向变量或参数添加类型提示的一种方式，它需要一个带有一组特定字符串键和每个键的特定类型的`dict`——当我们使用`dict`作为记录时会发生这种情况，通常是在处理 JSON 数据的上下文中。这一部分有点长，因为使用`TypedDict`会给人一种虚假的安全感，我想展示当试图从本质上是动态的映射中创建静态结构化记录时，运行时检查和错误处理是如何不可避免的。

接下来我们讨论了`typing.cast`，这是一个用来指导类型检查器工作的功能。仔细考虑何时使用`cast`很重要，因为过度使用它会妨碍类型检查。

接下来是对类型提示的运行时访问。关键点是使用`typing.​get_type_hints`而不是直接读取`__annotations__`属性。然而，对于某些注释，该函数可能不可靠，我们看到 Python 核心开发人员仍在研究一种方法，使类型提示在运行时可用，同时减少它们对 CPU 和内存使用的影响。

最后几节是关于泛型的，从`LottoBlower`泛型类开始——我们后来知道它是一个不变的泛型类。该示例后面是四个基本术语的定义:泛型类型、形式类型参数、参数化类型和实际类型参数。

接下来介绍方差的主要主题，使用自助餐厅饮料自动售货机和垃圾桶作为不变、协变和逆变泛型类型的“真实生活”示例。接下来，我们回顾、形式化并进一步将这些概念应用于 Python 标准库中的示例。

最后，我们看到了通用静态协议是如何定义的，首先考虑的是`typing.SupportsAbs`协议，然后将同样的想法应用到`RandomPicker`的例子中，使其比第十三章中的原始协议更加严格。

###### 注意

Python 的类型系统是一个庞大且快速发展的主题。这一章不全面。我选择关注广泛适用的、特别具有挑战性的、或者概念上重要的、因此可能长期相关的主题。

# 进一步阅读

Python 的静态类型系统在最初设计时就很复杂，并且随着时间的推移变得越来越复杂。表 15-1 列出了截至 2021 年 5 月我所知道的所有 pep。要涵盖所有内容需要一整本书。

Table 15-1\. PEPs about type hints, with links in the titles. PEP with numbers marked with * are important enough to be mentioned in the opening paragraph of the [`typing` documentation](https://fpy.li/typing). Question marks in the Python column indicate PEPs under discussion or not yet implemented; “n/a” appears in informational PEPs with no specific Python version.

| 精力 | 标题 | 计算机编程语言 | 年 |
| --- | --- | --- | --- |
| 3107 | [功能注释](https://fpy.li/pep3107) | 3.0 | 2006 |
| 483* | [理论式提示](https://fpy.li/pep483) | 不适用的 | 2014 |
| 484* | [类型提示](https://fpy.li/pep484) | 3.5 | 2014 |
| 482 | [类型提示的文献综述](https://fpy.li/pep482) | 不适用的 | 2015 |
| 526* | [变量注释的语法](https://fpy.li/pep526) | 3.6 | 2016 |
| 544* | [方案:结构亚分型(静态鸭分型)](https://fpy.li/pep544) | 3.8 | 2017 |
| 557 | [数据类别](https://fpy.li/pep557) | 3.7 | 2017 |
| 560 | [对类型模块和泛型类型的核心支持](https://fpy.li/pep560) | 3.7 | 2017 |
| 561 | [分发和包装类型信息](https://fpy.li/pep561) | 3.7 | 2017 |
| 563 | [推迟注释评估](https://fpy.li/pep563) | 3.7 | 2017 |
| 586* | [文字类型](https://fpy.li/pep586) | 3.8 | 2018 |
| 585 | [标准集合中的类型提示泛型](https://fpy.li/pep585) | 3.9 | 2019 |
| 589* | [TypedDict:具有固定键集的字典的类型提示](https://fpy.li/pep589) | 3.8 | 2019 |
| 591* | [为键入添加一个最终限定符](https://fpy.li/pep591) | 3.8 | 2019 |
| 593 | [灵活的功能和变量注释](https://fpy.li/pep593) | ? | 2019 |
| 604 | [允许将联合类型写成 X &#124; Y](https://fpy.li/pep604) | 3.10 | 2019 |
| 612 | [参数规格变量](https://fpy.li/pep612) | 3.10 | 2019 |
| 613 | [显式类型别名](https://fpy.li/pep613) | 3.10 | 2020 |
| 645 | [允许写可选类型为 x？](https://fpy.li/pep645) | ? | 2020 |
| 646 | [可变泛型](https://fpy.li/pep646) | ? | 2020 |
| 647 | [自定义类型守卫](https://fpy.li/pep647) | 3.10 | 2021 |
| 649 | [使用描述符的注释的延迟评估](https://fpy.li/pep649) | ? | 2021 |
| 655 | [将单个类型的项目标记为必需或潜在缺失](https://fpy.li/pep655) | ? | 2021 |

Python 的官方文档很难跟上所有这些，所以 Mypy 的文档是必不可少的参考。Patrick Viafore (O'Reilly)著的《健壮的 Python》[*是我所知道的第一本广泛涉及 Python 静态类型系统的书，出版于 2021 年 8 月。你可能正在读第二本这样的书。*](https://fpy.li/15-36)

差异这个微妙的话题在 PEP 484 中有自己的[部分，在 Mypy 的](https://fpy.li/15-37)[“Generics”](https://fpy.li/15-38)页面以及其宝贵的[“Common Issues”](https://fpy.li/15-39)页面中也有涉及。

如果你打算使用补充`typing.get_type_hints`函数的`inspect`模块，函数签名对象值得一读。

如果你对 Python 的历史感兴趣，你可能想知道吉多·范·罗苏姆在 2004 年 12 月 23 日发布了[“给 Python 添加可选的静态类型”](https://fpy.li/15-40)。

[“Python 3 Types in the Wild:A Tale of Two Type Systems”](https://fpy.li/15-41)是英卡拉特·拉克-阿姆努基特和其他来自伦斯勒理工学院和 IBM TJ 沃森研究中心的研究论文。本文调查了 GitHub 上开源项目中类型提示的使用，显示大多数项目不使用它们，并且大多数有类型提示的项目显然不使用类型检查器。我发现关于 Mypy 和 Google 的 pytype 的不同语义的讨论最有趣，他们认为这是“本质上两种不同的类型系统”。

关于渐进类型化的两篇开创性论文是吉拉德·布拉查的“可插拔类型系统”](https://fpy.li/15-42)和埃里克·梅耶尔和彼得·德雷顿的[“尽可能静态类型化，需要时动态类型化:编程语言冷战的结束”](https://fpy.li/15-43)。 ^([17)

我在阅读一些关于其他语言的书籍的相关部分时学到了很多，这些语言实现了一些相同的思想:

*   [*原子科特林*](https://fpy.li/15-44) 布鲁斯·埃凯尔和斯韦特兰娜·伊萨科娃(思维视角)

*   [*有效 Java* ，第 3 版。，](https://fpy.li/15-45)作者约书亚·布洛赫(Addison-Wesley)

*   [*用类型编程:Vlad Riscutia (Manning)的类型脚本示例*](https://fpy.li/15-46)

*   鲍里斯·切尔尼(O'Reilly)的 [*编程打字稿*](https://fpy.li/15-47)

*   *飞镖编程语言*](https://fpy.li/15-48) 由吉拉德·布拉查(Addison-Wesley)^([18)

对于一些对类型系统的批判性观点，我推荐 Victor Youdaiken 的帖子[《类型理论中的坏想法》](https://fpy.li/15-49)和[《被认为有害的类型 II》](https://fpy.li/15-50)。

最后，我惊讶地发现了 Ken Arnold 写的[“被认为有害的泛型”](https://fpy.li/15-51)，他从一开始就是 Java 的核心贡献者，也是 Java 编程语言官方书籍*《T21》前四版的合著者(Addison-Wesley)——与 Java 的首席设计师詹姆斯·高斯林合作。*

可悲的是，阿诺德的批评也适用于 Python 的静态类型系统。在阅读打字 pep 的许多规则和特殊情况时，我经常想起高斯林帖子中的这段话:

> 这就带来了我经常提到的 C++的问题:我称之为“异常规则的 N 阶异常”听起来是这样的:“你可以做 x，除了在 y 的情况下，除非 y 做 z，在这种情况下你可以如果……”

幸运的是，Python 比 Java 和 C++有一个关键优势:可选的类型系统。当类型检查器变得太麻烦时，我们可以压制它们，忽略类型提示。

[1] 来自 YouTube 的视频“一个语言创造者的对话:吉多·范·罗苏姆、詹姆斯·高斯林、拉里·沃尔和安德斯·海尔斯伯格”，于 2019 年 4 月 2 日直播。报价从 [1:32:05](https://fpy.li/15-1) 开始，为简洁起见进行了编辑。全文可在[*https://github.com/fluentpython/language-creators*](https://github.com/fluentpython/language-creators)获得。

我很感激耶勒·泽尔斯特拉——一个排版的维护者——他教会了我几件事，包括如何将我原来的九个超载减少到六个。

[3] 截止 2020 年 5 月，pytype 允许。但是它的 [FAQ](https://fpy.li/15-6) 说将来会不允许。参见问题“为什么 pytype 没有发现我改变了一个注释变量的类型？”在 pytype [常见问题解答](https://fpy.li/15-6)中。

[4] 我更喜欢使用 [lxml](https://fpy.li/15-8) 包来生成和解析 xml:入门容易，功能齐全，速度快。不幸的是，lxml 和 Python 自己的 [*ElementTree*](https://fpy.li/15-9) 不适合我假设的微控制器有限的 RAM。

[5]Mypy 文档在其[“常见问题和解决方案”页面](https://fpy.li/15-10)的[“空集合的类型”](https://fpy.li/15-11)部分中对此进行了讨论。

[6] 布雷特·卡农、吉多·范·罗苏姆等人从 2016 年开始在 [Mypy 第 182 期:定义一个 JSON 类型](https://fpy.li/15-12)中讨论如何类型化提示`json.loads()`。

[7] 示例中使用`enumerate`是为了混淆类型检查器。Mypy 正确地分析了直接产生字符串而不是通过`enumerate`索引的更简单的实现，并且不需要`cast()`。

[8] 我报告了*typeshed*[issue # 5535](https://fpy.li/15-17)“asyncio . base _ events 的错误类型提示。服务器套接字属性。塞巴斯蒂安·里托很快就修好了。然而，我决定保留这个例子，因为它说明了`cast`的一个常见用例，并且我编写的`cast`是无害的。

[9] 老实说，我最初在带有`server.sockets[0]`的行后面附加了一个`# type: ignore`注释，因为经过一点研究，我发现 *asyncio* [文档](https://fpy.li/15-18)和[测试用例](https://fpy.li/15-19)中有类似的行，所以我怀疑问题不在我的代码中。

[10][2020 年 5 月 19 日消息](https://fpy.li/15-21)到打字-签名邮件列表。

[11] 语法`# type: ignore[code]`允许你指定哪个 Mypy 错误代码被静音，但是代码并不总是容易解释的。参见 Mypy 文档中的[“错误代码”](https://fpy.li/15-22)。

[12] 关于`clip`的实现我就不赘述了，不过如果你好奇的话可以在[*clip _ annot . py*](https://fpy.li/15-23)中阅读整个模块。

[13] 消息[“人教版 563 参照人教版 649”](https://fpy.li/15-27)，发布于 2021 年 4 月 16 日。

[14] 这些术语出自约书亚·布洛赫的经典著作《有效的 Java*，第 3 版。(艾迪森-卫斯理)。定义和例子都是我的。*

*[15] 我第一次在吉拉德·布拉查(Addison-Wesley)所著的《Dart 编程语言一书中的埃里克·梅耶尔的*前言*中看到关于方差的自助餐厅类比。*

*[16] 比禁书好多了！*

*作为脚注的读者，你可能记得我用自助餐厅的类比来解释差异。*

*[18] 那本书是为 Dart 1 写的。Dart 2 有显著的变化，包括类型系统。然而，布拉查是编程语言设计领域的重要研究者，我发现这本书对他关于 Dart 设计的观点很有价值。*

*[19] 参见人教版 484 中[【协方差与逆变】](https://fpy.li/15-37)一节的最后一段。**