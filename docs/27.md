<link href="Styles/Style00.css" rel="stylesheet" type="text/css"> <link href="Styles/Style01.css" rel="stylesheet" type="text/css"> 

# 第二十二章。动态属性和特性

> 属性的至关重要性在于，它们的存在使得公开公共数据属性作为类的公共接口的一部分变得非常安全，而且确实是明智的。
> 
> Martelli，Ravenscroft 和 Holden，“为什么属性很重要” ^(1)

数据属性和方法在 Python 中统称为*属性*。一个方法是一个可以被*调用*的属性。*动态属性*呈现与数据属性相同的界面——即`obj.attr`——但按需计算。这遵循了 Bertrand Meyer 的*统一访问原则*:

> 一个模块提供的所有服务应该通过一个统一的符号可用，这不会泄露它们是通过存储还是通过计算实现的。 ^(2)

有几种方法可以在 Python 中实现动态属性。本章涵盖了最简单的方法:`@property`装饰器和`__getattr__`特殊方法。

一个实现了`__getattr__`的 用户定义类可以实现动态属性的变体，我称之为*虚拟属性*:这些属性没有在类的源代码中的任何地方显式声明，也没有出现在`__dict__`实例中，但是当用户试图读取一个不存在的属性(如`obj.no_such_attr`)时，可以在其他地方检索或动态计算这些属性。

编写动态和虚拟属性是框架作者所做的那种元编程。然而，在 Python 中，基本技术很简单，所以我们可以在日常的数据争论任务中使用它们。这就是我们将如何开始这一章。

# 本章的新内容

本章的大部分更新都是基于对`@functools.cached_property`(Python 3.8 中引入)的讨论，以及`@property`和`@functools.cache`(3.9 中的新特性)的结合使用。这影响了出现在“计算属性”中的`Record`和`Event`类的代码。我还添加了一个重构来利用[PEP 412——密钥共享字典](https://fpy.li/pep412)优化。

为了突出更多相关的特性，同时保持示例的可读性，我删除了一些不必要的代码——将旧的`DbRecord`类合并到`Record`,用`dict`替换了`shelve.Shelve`,并删除了下载 OSCON 数据集的逻辑——这些示例现在从包含在 [*Fluent Python* 代码库](https://fpy.li/code)中的本地文件中读取。

# 动态属性的数据争论

在接下来的几个例子中，我们将利用动态属性来处理 O'Reilly 为 OSCON 2014 大会发布的 JSON 数据集。示例 22-1 显示了数据集中的四条记录。 ^(3)

##### 示例 22-1。来自 osconfeed.json 的样本记录；部分字段内容已缩写

```
{"Schedule": `{``"conferences"``:``[{``"serial"``:``115``}],` ``"events"``:``[` ``{``"serial"``:``34505``,` ``"name"``:``"Why Schools Don´t Use Open Source to Teach Programming"``,` ``"event_type"``:``"40-minute conference session"``,` ``"time_start"``:``"2014-07-23 11:30:00"``,` ``"time_stop"``:``"2014-07-23 12:10:00"``,` ``"venue_serial"``:``1462``,` ``"description"``:``"Aside from the fact that high school programming..."``,` ``"website_url"``:``"http://oscon.com/oscon2014/public/schedule/detail/34505"``,` ``"speakers"``:``[``157509``],` ``"categories"``:``[``"Education"``]``}` ``],` ``"speakers"``:``[` ``{``"serial"``:``157509``,` ``"name"``:``"Robert Lefkowitz"``,` ``"photo"``:``null``,` ``"url"``:``"http://sharewave.com/"``,` ``"position"``:``"CTO"``,` ``"affiliation"``:``"Sharewave"``,` ``"twitter"``:``"sharewaveteam"``,` ``"bio"``:``"Robert ´r0ml´ Lefkowitz is the CTO at Sharewave, a startup..."``}` ``],` ``"venues"``:``[` ``{``"serial"``:``1462``,` ``"name"``:``"F151"``,` ``"category"``:``"Conference Venues"``}` ``]` ``}` ``}``````````````````````````````
```

 ```示例 22-1 显示了 JSON 文件中 895 条记录中的 4 条。整个数据集是一个带有键`"Schedule"`的 JSON 对象，它的值是另一个带有四个键的映射:`"conferences"`、`"events"`、`"speakers"`和`"venues"`。这四个键中的每一个都映射到一个记录列表。在完整的数据集中，`"events"`、`"speakers"`和`"venues"`列表有几十或几百条记录，而`"conferences"`只有一条记录，如示例 22-1 所示。每条记录都有一个`"serial"`字段，它是列表中记录的唯一标识符。

我用 Python 的控制台探索数据集，如示例 22-2 所示。

##### 示例 22-2。osconfeed . JSON 的互动探索

```
>>> importjson>>> withopen('data/osconfeed.json')asfp:... feed=json.load(fp)①>>> sorted(feed['Schedule'].keys())②['conferences', 'events', 'speakers', 'venues'] >>> forkey,valueinsorted(feed['Schedule'].items()):... print(f'{len(value):3}{key}')③... 1 conferences 484 events 357 speakers
 53 venues >>> feed['Schedule']['speakers'][-1]['name']④'Carina C. Zona' >>> feed['Schedule']['speakers'][-1]['serial']⑤141590 >>> feed['Schedule']['events'][40]['name']'There *Will* Be Bugs' >>> feed['Schedule']['events'][40]['speakers']⑥[3471, 5199]
```

① `feed`是一个`dict`，包含嵌套的字典和列表，有字符串和整数值。

② 列出`"Schedule"`里面的四个记录集合。

③ 显示每个集合的记录计数。

④ 浏览嵌套的字典和列表以获得最后一个发言者的名字。

⑤ 获取同一扬声器的序列号。

⑥ 每个事件都有一个带有零个或多个扬声器序列号的`'speakers'`列表。

## 探索具有动态属性的类 JSON 数据

示例 22-2 是 足够简单，但是语法`feed'Schedule']['events'][40]['name']`比较繁琐。在 JavaScript 中，你可以通过写`feed.Schedule.events[40].name`得到相同的值。用 Python 实现一个类似于`dict`的类是很容易的——网上有很多这样的实现。 ^([4) 我写的是 `FrozenJSON` ，比大多数菜谱都简单，因为它只支持读取:只是为了探索数据。`FrozenJSON`也是递归的，自动处理嵌套映射和列表。

示例 22-3 是`FrozenJSON`的演示，源代码见示例 22-4 。

##### 示例 22-3。 `FrozenJSON`来自示例 22-4 允许读取`name`等属性，调用`.keys()`和`.items()`等方法

```
>>>importjson>>>raw_feed=json.load(open('data/osconfeed.json'))>>>feed=FrozenJSON(raw_feed)①>>>len(feed.Schedule.speakers)②357>>>feed.keys()dict_keys(['Schedule'])>>>sorted(feed.Schedule.keys())③['conferences','events','speakers','venues']>>>forkey,valueinsorted(feed.Schedule.items()):④...print(f'{len(value):3} {key}')...1conferences484events357speakers53venues>>>feed.Schedule.speakers[-1].name⑤'Carina C. Zona'>>>talk=feed.Schedule.events[40]>>>type(talk)⑥<class'explore0.FrozenJSON'>>>>talk.name'There *Will* Be Bugs'>>>talk.speakers⑦[3471,5199]>>>talk.flavor⑧Traceback(mostrecentcalllast):...KeyError:'flavor'
```

① 从由嵌套字典和列表组成的`raw_feed`构建一个`FrozenJSON`实例。

② `FrozenJSON`允许使用属性符号遍历嵌套字典；我们在此显示发言者名单的长度。

③ 也可以访问底层字典的方法，如`.keys()`，以检索记录集合名称。

④ 使用`items()`，我们可以检索记录集合名称及其内容，以显示每个名称的`len()`。

⑤ 一个`list`，比如`feed.Schedule.speakers`，仍然是一个列表，但是里面的条目如果是映射的话就被转换成`FrozenJSON`。

⑥ `events`列表中的第 40 项是一个 JSON 对象；现在是一个`FrozenJSON`实例。

⑦ 事件记录有一个带有扬声器序列号的`speakers`列表。

⑧ 试图读取一个丢失的属性会引发`KeyError`，而不是通常的 `AttributeError`。

`FrozenJSON`类的基础是`__getattr__`方法，我们已经在" Vector Take # 3:Dynamic Attribute Access "中的`Vector`示例中使用了该方法，通过字母检索`Vector`组件:`v.x`、`v.y`、`v.z`等。重要的是要记住，只有当通常的过程无法检索到属性时，解释器才会调用`__getattr__`特殊方法(也就是说，当在实例、类或其超类中都找不到指定的属性时)。

示例 22-3 的最后一行暴露了我的代码的一个小问题:试图读取一个丢失的属性应该引发`AttributeError`，而不是如图所示的`KeyError`。当我实现错误处理来做到这一点时，`__getattr__`方法变得两倍长，分散了我想要展示的最重要的逻辑的注意力。假设用户知道`FrozenJSON`是由映射和列表构建的，我认为`KeyError`不会太混乱。

##### 示例 22-4。 explore0.py:将一个 JSON 数据集转换成一个`FrozenJSON`，保存嵌套的 `FrozenJSON` 对象、列表和简单类型

```
fromcollectionsimportabcclassFrozenJSON:"""A read-only façade for navigating a JSON-like object
       using attribute notation
    """def__init__(self,mapping):self.__data=dict(mapping)①def__getattr__(self,name):②try:returngetattr(self.__data,name)③exceptAttributeError:returnFrozenJSON.build(self.__data[name])④def__dir__(self):⑤returnself.__data.keys()@classmethoddefbuild(cls,obj):⑥ifisinstance(obj,abc.Mapping):⑦returncls(obj)elifisinstance(obj,abc.MutableSequence):⑧return[cls.build(item)foriteminobj]else:⑨returnobj
```

① 从`mapping`参数构建一个`dict`。这确保了我们得到一个映射或者可以转换成映射的东西。`__data`上的双下划线前缀使其成为*私有属性*。

② `__getattr__`只有在没有那个`name`的属性时才被调用。

③ 如果`name`匹配实例`__data` `dict`的一个属性，则返回该属性。这是如何处理类似`feed.keys()`的调用:`keys`方法是 `__data` `dict`的一个属性。

④ 否则，从`self.__data`中取出键为`name`的项目，并返回在其上调用`FrozenJSON.build()`的结果。^(5)

⑤ 实现`__dir__`支持`dir()`内置，它反过来支持标准 Python 控制台以及 IPython、Jupyter Notebook 等中的自动完成。这个简单的代码将基于`self.__data`中的键启用递归自动完成，因为`__getattr__`动态构建`FrozenJSON`实例——这对于数据的交互式探索非常有用。

⑥ 这是一个替代构造函数，是`@classmethod`装饰器的常用用法。

⑦ 如果`obj`是一个映射，用它构建一个`FrozenJSON`。这是*鹅式打字*的一个例子——如果你需要复习，参见“鹅式打字”。

⑧ 如果是一个`MutableSequence`，那么一定是一个列表， ^(6) 所以我们通过把`obj`中的每一项递归传递给`.build()`来构建一个`list`。

⑨ 如果不是`dict`或`list`，则原样返回该项目。

一个`FrozenJSON`实例具有以名称`_FrozenJSON__data`存储的`__data`私有实例属性，如“Python 中的私有和‘受保护’属性”中所述。试图通过其他名称检索属性将触发`__getattr__`。这个方法首先会查看`self.__data` `dict`是否有属性(不是键！)的名字；这允许`FrozenJSON`实例通过委托给`self.__data.items()`来处理`dict`方法，比如`items`。如果`self.__data`没有给定`name`的属性，`__getattr__`使用`name`作为关键字从`self.__data`中检索一个项目，并将该项目传递给`FrozenJSON.build`。这允许浏览 JSON 数据中的嵌套结构，因为每个嵌套映射都由`build`类方法转换成另一个`FrozenJSON`实例。

注意`FrozenJSON`不会转换或缓存原始数据集。当我们遍历数据时，`__getattr__`一次又一次地创建`FrozenJSON`实例。对于这种规模的数据集以及仅用于浏览或转换数据的脚本来说，这是可以的。

任何从任意来源生成或模拟动态属性名的脚本都必须处理一个问题:原始数据中的键可能不是合适的属性名。下一节将讨论这个问题。

## 无效属性名问题

`FrozenJSON`代码不处理 Python 关键字的属性名。例如，如果您像这样构建一个对象:

```
>>> student = FrozenJSON({'name': 'Jim Bo', 'class': 1982})
```

您将无法读取`student.class`，因为`class`是 Python 中的保留关键字:

```
>>> student.class
  File "<stdin>", line 1
    student.class
         ^
SyntaxError: invalid syntax
```

当然，您可以随时这样做:

```
>>> getattr(student, 'class')
1982
```

但是`FrozenJSON`的想法是提供对数据的方便访问，所以更好的解决方案是检查给`FrozenJSON.__init__`的映射中的一个键是否是关键字，如果是，就给它附加一个`_`，这样该属性就可以如下所示:

```
>>> student.class_
1982
```

将示例 22-4 中的单排`__init__`替换为示例 22-5 中的单排`__init__`即可。

##### 示例 22-5。 explore1.py:将一个`_`附加到作为 Python 关键字的属性名上

```
def__init__(self,mapping):self.__data={}forkey,valueinmapping.items():ifkeyword.iskeyword(key):①key+='_'self.__data[key]=value
```

① `keyword.iskeyword(…)`功能正是我们所需要的；要使用它，必须导入`keyword`模块，这个代码片段中没有显示。

如果 JSON 记录中的键不是有效的 Python 标识符，也会出现类似的问题:

```
>>> x = FrozenJSON({'2be':'or not'})
>>> x.2be
  File "<stdin>", line 1
    x.2be
      ^
SyntaxError: invalid syntax
```

这种有问题的键在 Python 3 中很容易被检测到，因为`str`类提供了`s.isidentifier()`方法，该方法根据语言语法告诉您`s`是否是有效的 Python 标识符。但是将不是有效标识符的键转换成有效的属性名并不容易。一个解决方案是实现`__getitem__`以允许使用类似`x['2be']`的符号进行属性访问。为了简单起见，我不会担心这个问题。

在考虑了动态属性名之后，让我们转向`FrozenJSON`的另一个基本特性:`build`类方法的逻辑。`Frozen.JSON.build`由`__getattr__`使用，根据被访问的属性值返回不同类型的对象:嵌套结构被转换为`FrozenJSON`实例或`FrozenJSON`实例列表。

代替类方法，相同的逻辑可以实现为`__new__`特殊方法，我们将在下面看到。

## 使用 __new_ 创建灵活的对象

我们 经常称`__init__`为构造函数方法，但那是因为我们采用了其他语言的行话。在 Python 中，`__init__`将`self`作为第一个参数，因此当解释器调用`__init__`时，对象已经存在。还有，`__init__`不能退任何东西。所以它实际上是一个初始化器，而不是构造器。

当调用一个类来创建实例时，Python 调用那个类来构造实例的特殊方法是`__new__`。这是一个类方法，但是得到了特殊的处理，所以没有对它应用`@classmethod`装饰器。Python 接受由`__new__`返回的实例，然后将其作为`__init__`的第一个参数`self`传递。我们很少需要编码`__new__`，因为从`object`继承的实现满足绝大多数用例。

如果需要的话，`__new__`方法也可以返回一个不同类的实例。当这种情况发生时，解释器不会调用`__init__`。换句话说，Python 构建对象的逻辑类似于以下伪代码:

```
# pseudocode for object construction
def make(the_class, some_arg):
    new_object = the_class.__new__(some_arg)
    if isinstance(new_object, the_class):
        the_class.__init__(new_object, some_arg)
    return new_object

# the following statements are roughly equivalent
x = Foo('bar')
x = make(Foo, 'bar')
```

示例 22-6 显示了`FrozenJSON`的一个变体，其中以前的`build`类方法的逻辑被移到了`__new__`。

##### 示例 22-6。 explore2.py:使用`__new__`而不是`build`来构造新的对象，这些对象可能是也可能不是`FrozenJSON`的实例

```
fromcollectionsimportabcimportkeywordclassFrozenJSON:"""A read-only façade for navigating a JSON-like object
       using attribute notation
    """def__new__(cls,arg):①ifisinstance(arg,abc.Mapping):returnsuper().__new__(cls)②elifisinstance(arg,abc.MutableSequence):③return[cls(item)foriteminarg]else:returnargdef__init__(self,mapping):self.__data={}forkey,valueinmapping.items():ifkeyword.iskeyword(key):key+='_'self.__data[key]=valuedef__getattr__(self,name):try:returngetattr(self.__data,name)exceptAttributeError:returnFrozenJSON(self.__data[name])④def__dir__(self):returnself.__data.keys()
```

① 作为一个类方法，`__new__`得到的第一个参数是类本身，其余参数和`__init__`得到的一样，除了`self`。

② 默认行为是委托给超类的`__new__`。在这种情况下，我们从`object`基类调用`__new__`，传递`FrozenJSON`作为唯一的参数。

③ `__new__`的其余线条与旧的`build`方法完全相同。

④ 这是以前调用`FrozenJSON.build`的地方；现在我们只调用 `FrozenJSON` 类，Python 通过调用`FrozenJSON.__new__`来处理。

方法获取类作为第一个参数，因为通常，创建的对象将是该类的一个实例。所以在`FrozenJSON.__new__`中，当表达式 `super().__new__(cls)`有效调用`object.__new__(FrozenJSON)`时，`object`类构建的实例实际上是`FrozenJSON`的实例。新实例的`__class__`属性将保存对`FrozenJSON`的引用，即使实际的构造是由`object.__new__`执行的，用 C 实现，在解释器的内部。

OSCON JSON 数据集的结构不利于交互式探索。例如，索引为`40`，标题为`'There *Will* Be Bugs'`的事件有两个发言人`3471`和`5199`。找到发言人的名字是很困难的，因为那些是序列号，而`Schedule.speakers`名单并没有被他们编入索引。为了获得每个发言者，我们必须遍历列表，直到找到一个具有匹配序列号的记录。我们的下一个任务是重组数据，为链接记录的自动检索做准备。```  ```# 计算属性

我们第一次看到`@property`装饰器是在第 11 章中，在“一个可散列的 vector 2d”部分。在示例 11-7 中，我在`Vector2d`中使用了两个属性，只是为了使`x`和`y`属性只读。这里我们将看到计算值的属性，从而引出如何缓存这些值的讨论。

OSCON JSON 数据的`'events'`列表中的 记录包含指向`'speakers'`和`'venues'`列表中记录的整数序列号。例如，这是一次会议谈话的记录(省略了描述):

```
{"serial":33950, `"name"``:``"There *Will* Be Bugs"``,` ``"event_type"``:``"40-minute conference session"``,` ``"time_start"``:``"2014-07-23 14:30:00"``,` ``"time_stop"``:``"2014-07-23 15:10:00"``,` ``"venue_serial"``:``1449``,` ``"description"``:``"If you're pushing the envelope of programming..."``,` ``"website_url"``:``"http://oscon.com/oscon2014/public/schedule/detail/33950"``,` ``"speakers"``:``[``3471``,``5199``],` ``"categories"``:``[``"Python"``]``}`````````
```

 ```我们将实现一个具有`venue`和`speakers`属性的`Event`类来自动返回链接的数据——换句话说，就是“解引用”序列号。给定一个`Event`实例，示例 22-7 显示了期望的行为。

##### 示例 22-7。读取`venue`和`speakers`返回`Record`对象

```
 >>> event ① <Event 'There *Will* Be Bugs'> >>> event.venue ② <Record serial=1449> >>> event.venue.name ③ 'Portland 251' >>> for spkr in event.speakers: ④ ...     print(f'{spkr.serial}: {spkr.name}') ... 3471: Anna Martelli Ravenscroft 5199: Alex Martelli
```

① 给定一个`Event`实例…

② …读取`event.venue`返回一个`Record`对象，而不是一个序列号。

③ 现在很容易得到`venue`的名字。

④ 属性返回一个`Record`实例的列表。

像往常一样，我们将一步一步地构建代码，从`Record`类和一个读取 JSON 数据并返回带有`Record`实例的`dict`的函数开始。

## 步骤 1:数据驱动的属性创建

示例 22-8 显示了指导这第一步的 doctest。

##### 示例 22-8。试驾计划表 _v1.py(来自示例 22-9 )

```
>>>records=load(JSON_PATH)①>>>speaker=records['speaker.3471']②>>>speaker③<Recordserial=3471>>>>speaker.name,speaker.twitter④('Anna Martelli Ravenscroft','annaraven')
```

① `load`一个`dict`带有 JSON 数据。

② `records`中的键是根据记录类型和序列号构建的字符串。

③ `speaker`是示例 22-9 中定义的`Record`类的实例。

④ 原始 JSON 中的字段可以作为`Record`实例属性被检索。

*schedule_v1.py* 的代码在示例 22-9 中。

##### 示例 22-9。 schedule_v1.py:重组 OSCON 日程数据

```
importjsonJSON_PATH='data/osconfeed.json'classRecord:def__init__(self,**kwargs):self.__dict__.update(kwargs)①def__repr__(self):returnf'<{self.__class__.__name__} serial={self.serial!r}>'②defload(path=JSON_PATH):records={}③withopen(path)asfp:raw_data=json.load(fp)④forcollection,raw_recordsinraw_data['Schedule'].items():⑤record_type=collection[:-1]⑥forraw_recordinraw_records:key=f'{record_type}.{raw_record["serial"]}'⑦records[key]=Record(**raw_record)⑧returnrecords
```

① 这是用关键字参数创建的属性构建实例的常用快捷方式(详细解释如下)。

② 使用`serial`字段构建自定义`Record`表示，如示例 22-8 所示。

③ `load`将最终返回一个`Record`实例的`dict`。

④ 解析 JSON，返回原生 Python 对象:列表、字典、字符串、数字等。

⑤ 迭代名为`'conferences'`、`'events'`、`'speakers'`和`'venues'`的四个顶级列表。

⑥ `record_type`是没有最后一个字符的列表名，所以`speakers`变成了`speaker`。在 Python ≥ 3.9 中，我们可以用`collection.removesuffix('s')`更明确地做到这一点——参见[PEP 616——去除前缀和后缀的字符串方法](https://fpy.li/pep616)。

⑦ 以格式`'speaker.3471'`构建`key`。

⑧ 用`key`创建一个`Record`实例并保存在`records`中。

`Record.__init__`方法展示了一个旧的 Python 黑客。回想一下，对象的`__dict__`是保存其属性的地方——除非`__slots__`在类中声明，正如我们在“用 __slots__”中看到的。因此，用映射更新实例`__dict__`是在该实例中创建一堆属性的快速方法。 ^(7)

###### 注意

根据应用程序的不同，`Record`类可能需要处理不是有效属性名的键，正如我们在“无效属性名问题”中看到的。处理这个问题会偏离这个例子的核心思想，并且在我们正在阅读的数据集中不是一个问题。

示例 22-9 中`Record`的定义太简单了，你可能会奇怪为什么我以前不用它，而不用更复杂的`FrozenJSON`。原因有二。首先，`FrozenJSON`通过递归转换嵌套映射和列表来工作；`Record`不需要这样做，因为我们转换的数据集没有嵌套在映射或列表中的映射。记录只包含字符串、整数、字符串列表和整数列表。第二个原因:`FrozenJSON`提供了对嵌入的`__data` `dict`属性的访问——我们曾经用它来调用像`.keys()`这样的方法——现在我们也不需要那个功能了。

###### 注意

Python 标准库提供了类似于`Record`的类，其中每个实例都有一组任意的属性，这些属性是根据给`__init__`的关键字参数构建的: [`types.SimpleNamespace`](https://fpy.li/22-5) 、 [`argparse.Namespace`](https://fpy.li/22-6) 和 [`multiprocessing.managers.Namespace`](https://fpy.li/22-7) 。我编写了更简单的`Record`类来突出基本思想:`__init__`更新实例`__dict__`。

在重新组织日程数据集之后，我们可以增强`Record`类来自动检索在`event`记录中引用的`venue`和`speaker`记录。在接下来的例子中，我们将使用属性来实现这一点。

## 步骤 2:检索链接记录的属性

下一个版本的目标是:给定一个`event`记录，读取它的`venue`属性将返回一个`Record`。这类似于当您访问一个`ForeignKey`字段时 Django ORM 所做的:您得到的不是键，而是链接的模型对象。

我们将从`venue`属性开始。参见示例 22-10 中的部分交互示例。

##### 示例 22-10。从 schedule_v2.py 的文档测试中提取

```
>>>event=Record.fetch('event.33950')①>>>event②<Event'There *Will* Be Bugs'>>>>event.venue③<Recordserial=1449>>>>event.venue.name④'Portland 251'>>>event.venue_serial⑤1449
```

① `Record.fetch`静态方法从数据集中获取一个`Record`或一个`Event`。

② 注意`event`是`Event`类的一个实例。

③ 访问`event.venue`会返回一个`Record`实例。

④ 现在很容易找出一个`event.venue`的名字。

⑤ 来自 JSON 数据的`Event`实例也有一个`venue_serial`属性。

`Event`是`Record`的子类，增加了一个`venue`来检索链接的记录，以及一个专门的`__repr__`方法。

该段代码在 [*Fluent Python* 代码库](https://fpy.li/code)的[*schedule _ v2 . py*](https://fpy.li/22-8)模块中。这个例子有将近 60 行，所以我将分几部分介绍它，从增强的`Record`类开始。

##### 示例 22-11。 schedule_v2.py: `Record`使用新的`fetch`方法的类

```
importinspect①importjsonJSON_PATH='data/osconfeed.json'classRecord:__index=None②def__init__(self,**kwargs):self.__dict__.update(kwargs)def__repr__(self):returnf'<{self.__class__.__name__} serial={self.serial!r}>'@staticmethod③deffetch(key):ifRecord.__indexisNone:④Record.__index=load()returnRecord.__index[key]⑤
```

① `inspect`将用于`load`，列于示例 22-13 。

② `__index`私有类属性将最终保存对由`load`返回的`dict`的引用。

③ `fetch`是一个`staticmethod`来明确它的效果不受调用它的实例或类的影响。

④ 如果需要，填充`Record.__index`。

⑤ 用它来检索给定`key`的记录。

###### 小费

这是使用`staticmethod`有意义的一个例子。`fetch`方法总是作用于`Record.__index`类属性，即使是从一个子类中调用，比如`Event.fetch()`——我们很快就会探究。将它编码成一个类方法会产生误导，因为第一个参数`cls`不会被使用。

现在我们开始使用`Event`类中的属性，如示例 22-12 中所列。

##### 示例 22-12。schedule _ v2 . py:`Event`类

```
classEvent(Record):①def__repr__(self):try:returnf'<{self.__class__.__name__} {self.name!r}>'②exceptAttributeError:returnsuper().__repr__()@propertydefvenue(self):key=f'venue.{self.venue_serial}'returnself.__class__.fetch(key)③
```

① `Event`延伸`Record`。

② 如果实例有一个`name`属性，它将被用来生成一个定制的表示。否则，从`Record`委托给`__repr__`。

③ `venue`属性从`venue_serial`属性构建一个`key`，并将其传递给`fetch`类方法，继承自`Record`(使用`self.__class__`的原因稍后解释)。

示例 22-12的`venue`方法第二行返回`self​.__class__.fetch(key)`。为什么不干脆叫`self.fetch(key)`？更简单的形式适用于特定的 OSCON 数据集，因为没有带有`'fetch'`键的事件记录。但是，如果一个事件记录有一个名为`'fetch'`的键，那么在那个特定的`Event`实例中，引用`self.fetch`将检索那个字段的值，而不是`Event`从`Record`继承的`fetch`类方法。这是一个微妙的错误，它可以很容易地通过测试，因为它依赖于数据集。

###### 警告

当从数据中创建实例属性名时，由于类属性(例如方法)的隐藏或者由于现有实例属性的意外覆盖而导致的数据丢失，总是存在错误的风险。这些问题可以解释为什么 Python 字典不像 JavaScript 对象。

如果`Record`类的行为更像一个映射，实现一个动态的`__getitem__`而不是一个动态的`__getattr__`，就不会有覆盖或隐藏错误的风险。自定义映射可能是实现`Record`的 Pythonic 方式。但是如果我走那条路，我们就不会研究动态属性编程的技巧和陷阱。

该示例的最后一部分是示例 22-13 中修改后的`load`函数。

##### 示例 22-13。schedule _ v2 . py:`load`函数

```
defload(path=JSON_PATH):records={}withopen(path)asfp:raw_data=json.load(fp)forcollection,raw_recordsinraw_data['Schedule'].items():record_type=collection[:-1]①cls_name=record_type.capitalize()②cls=globals().get(cls_name,Record)③ifinspect.isclass(cls)andissubclass(cls,Record):④factory=cls⑤else:factory=Record⑥forraw_recordinraw_records:⑦key=f'{record_type}.{raw_record["serial"]}'records[key]=factory(**raw_record)⑧returnrecords
```

① 到目前为止， *schedule_v1.py* 中的`load`没有变化(示例 22-9 )。

② 大写`record_type`获得一个可能的类名；例如`'event'`变成了`'Event'`。

③ 从模块全局范围中获取该名称的对象；如果没有这样的对象，获取`Record`类。

④ 如果刚刚检索的对象是一个类，并且是`Record`的子类…

⑤ …将`factory`名称绑定到它。这意味着`factory`可能是`Record`的任何子类，这取决于`record_type`。

⑥ 否则，将`factory`名称绑定到`Record`。

⑦ 创建`key`并保存记录的`for`循环与之前相同，除了…

⑧ …`records`中存储的对象是由`factory`构造的，可能是`Record`或类似`Event`的子类，根据`record_type`选择。

注意，唯一拥有自定义类的`record_type`是`Event`，但是如果名为`Speaker`或`Venue`的类被编码，`load`将在构建和保存记录时自动使用这些类，而不是默认的`Record`类。

我们现在将同样的想法应用到`Events`类中的一个新的`speakers`属性。

## 步骤 3:属性覆盖现有属性

示例 22-12 中`venue`属性的名与`"events"`集合记录中的字段名不匹配。它的数据来自一个`venue_serial`字段名。相比之下，`events`集合中的每条记录都有一个带有序列号列表的`speakers`字段。我们希望将该信息公开为`Event`实例中的`speakers`属性，该属性返回一系列`Record`实例。如示例 22-14 所示，这种名称冲突需要特别注意。

##### 示例 22-14。schedule _ v3 . py:`speakers`属性

```
@propertydefspeakers(self):spkr_serials=self.__dict__['speakers']①fetch=self.__class__.fetchreturn[fetch(f'speaker.{key}')forkeyinspkr_serials]②
```

① 我们想要的数据在一个`speakers`属性中，但是我们必须直接从实例`__dict__`中检索它，以避免对`speakers`属性的递归调用。

② 返回与 `spkr_serials`中的数字对应的所有记录的列表。

在`speakers`方法内部，试图读取`self.speakers`将调用属性本身，快速引发一个`RecursionError`。然而，如果我们通过`self.__dict__['speakers']`读取相同的数据，Python 通常的检索属性的算法被绕过，属性不被调用，递归被避免。因此，直接向对象的`__dict__`读取或写入数据是一种常见的 Python 元编程技巧。

###### 警告

解释器通过首先查看`obj`的类来评估`obj.my_attr`。如果这个类有一个名为`my_attr`的属性，那么这个属性会隐藏一个同名的实例属性。“属性覆盖实例属性”中的例子将演示这一点，而第 23 章将揭示一个属性被实现为描述符——一个更强大和更通用的抽象。

当我在示例 22-14 中编写列表理解时，我的程序员的蜥蜴脑想到:“这可能很贵。”不尽然，因为 OSCON 数据集中的事件没有几个发言人，所以编写任何更复杂的代码都是不成熟的优化。然而，缓存一个属性是一种常见的需求——也有一些注意事项。让我们在接下来的例子中看看如何做到这一点。

## 步骤 4:定制的属性缓存

缓存属性是一种常见的需求，因为人们期望像`event.venue`这样的表达式应该是廉价的。 ^(8) 如果`Event`属性背后的`Record.fetch`方法需要查询数据库或 web API，那么某种形式的缓存可能是必要的。

在第一版 *Fluent Python* 中，我为`speakers`方法编写了自定义缓存逻辑，如示例 22-15 所示。

##### 示例 22-15。使用`hasattr`的自定义缓存逻辑禁用密钥共享优化

```
@propertydefspeakers(self):ifnothasattr(self,'__speaker_objs'):①spkr_serials=self.__dict__['speakers']fetch=self.__class__.fetchself.__speaker_objs=[fetch(f'speaker.{key}')forkeyinspkr_serials]returnself.__speaker_objs②
```

① 如果实例没有名为`__speaker_objs`的属性，那么获取 speaker 对象并存储在那里。

② 返回`self.__speaker_objs`。

在示例 22-15 中手工缓存很简单，但是在实例初始化后创建一个属性会破坏PEP 412—密钥共享字典](https://fpy.li/pep412)优化，正如[“dict 如何工作的实际结果”中所解释的。根据数据集的大小，内存使用的差异可能很重要。

一个类似的手工解决方案需要为`Event`类编写一个`__init__`来创建必要的初始化为`None`的`__speaker_objs`，然后在`speakers`方法中检查它。参见示例 22-16 。

##### 示例 22-16。在`__init__`中定义的存储利用密钥共享优化

```
class Event(Record):

    def __init__(self, **kwargs):
        self.__speaker_objs = None
        super().__init__(**kwargs)

# 15 lines omitted...
    @property
    def speakers(self):
        if self.__speaker_objs is None:
            spkr_serials = self.__dict__['speakers']
            fetch = self.__class__.fetch
            self.__speaker_objs = [fetch(f'speaker.{key}')
                    for key in spkr_serials]
        return self.__speaker_objs
```

示例 22-15 和 22-16 展示了传统 Python 代码库中相当常见的简单缓存技术。然而，在多线程程序中，手工缓存会引入竞争条件，导致数据损坏。如果两个线程正在读取先前没有缓存的属性，则第一个线程将需要计算缓存属性的数据(在示例中为`__speaker_objs`),而第二个线程可能读取尚未完成的缓存值。

幸运的是，Python 3.8 引入了`@functools.cached_property` decorator，这是线程安全的。不幸的是，它带有几个警告，解释如下。

## 步骤 5:使用 functools 缓存属性

`functools`模块为缓存提供了三个装饰器。我们在“用 functools.cache 实现内存化” ( 第九章)中看到了`@cache`和`@lru_cache`。Python 3.8 引入了`@cached_property`。

`functools.cached_property`装饰器将方法的结果缓存在同名的实例属性中。例如，在示例 22-17 中，`venue`方法计算的值存储在`self`的`venue`属性中。之后，当客户端代码试图读取`venue`时，使用新创建的`venue`实例属性，而不是方法。

##### 示例 22-17。简单使用一个`@cached_property`

```
    @cached_property
    def venue(self):
        key = f'venue.{self.venue_serial}'
        return self.__class__.fetch(key)
```

在“步骤 3:属性覆盖现有属性”中，我们看到一个属性隐藏了一个同名的实例属性。如果那是真的，`@cached_property`怎么工作？如果属性覆盖了实例属性，那么`venue`属性将被忽略，而`venue`方法将一直被调用，每次都计算`key`并运行`fetch`！

答案有点悲哀:`cached_property`是用词不当。`@cached_property`装饰器不会创建一个完整的属性，它会创建一个*非覆盖描述符*。描述符是管理对另一个类中的属性的访问的对象。我们将深入第 23 章中的描述符。`property`装饰器是创建*覆盖描述符*的高级 API。第 23 章将包括关于*覆盖*与*非覆盖*描述符的全面解释。

现在，让我们把底层实现放在一边，从用户的角度来关注一下`cached_property`和`property`之间的区别。Raymond Hettinger 在 [Python 文档](https://fpy.li/22-9)中很好地解释了它们:

> `cached_property()`的机制与`property()`有些不同。除非定义了 setter，否则常规属性会阻止属性写入。相比之下，`cached_property`允许写。
> 
> `cached_property`装饰器只在查找时运行，并且只在同名的属性不存在时运行。当它运行时，`cached_property`用相同的名字写入属性。后续的属性读写优先于`cached_property`方法，它像普通属性一样工作。
> 
> 可以通过删除属性来清除缓存的值。这允许`cached_property`方法再次运行。 ^(9)

将返回到我们的`Event`类:`@cached_property`的特定行为使得它不适合修饰`speakers`，因为该方法依赖于一个名为`speakers`的现有属性，该属性包含事件发言者的序列号。

###### 警告

`@cached_property`有一些重要的限制:

*   如果修饰的方法已经依赖于同名的实例属性，则它不能作为`@property`的替代。

*   它不能在定义`__slots__`的类中使用。

*   它挫败了实例`__dict__`的密钥共享优化，因为它在`__init__`之后创建了一个实例属性。

尽管有这些限制，`@cached_property`以一种简单的方式解决了一个常见的需求，并且是线程安全的。它的 [Python 代码](https://fpy.li/22-13)就是一个使用 [*重入锁*](https://fpy.li/22-14) 的例子。

`@cached_property` 文档](https://fpy.li/22-15)推荐了一个我们可以和`speakers`一起使用的替代方案:堆叠`@property`和`@cache`装饰器，如[示例 22-18 所示。

##### 示例 22-18。将`@property`堆叠在`@cache`上

```
@property①@cache②defspeakers(self):spkr_serials=self.__dict__['speakers']fetch=self.__class__.fetchreturn[fetch(f'speaker.{key}')forkeyinspkr_serials]
```

① 顺序很重要:`@property`放在最上面…

② ……的`@cache`。

回想一下来自“堆叠装饰者”](ch09.xhtml#stacked_decorators_tip)的那个语法的意思。[示例 22-18 的前三行类似于:

```
speakers = property(cache(speakers))
```

`@cache`应用于`speakers`，返回一个新函数。然后这个函数被`@property`修饰，用一个新构造的属性替换它。

这结束了我们对只读属性和缓存装饰器的讨论，探索了 OSCON 数据集。在下一节中，我们将开始一系列创建读/写属性的新示例。```  ```# 使用属性进行属性验证

除了 计算属性值之外，属性还用于通过将公共属性更改为受 getter 和 setter 保护的属性来实施业务规则，而不会影响客户端代码。让我们看一个扩展的例子。

## LineItem Take #1:订单中项目的类

想象一下，一个商店的应用程序批量销售有机食品，顾客可以按重量订购坚果、干果或谷物。在该系统中，每个订单将包含一系列行项目，每个行项目可以由一个类的实例来表示，如示例 22-19 所示。

##### 示例 22-19。 bulkfood_v1.py:最简单的`LineItem`类

```
class LineItem:

    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price
```

那很好也很简单。也许太简单了。示例 22-20 显示一个问题。

##### 示例 22-20。负权重导致负小计

```
    >>> raisins = LineItem('Golden raisins', 10, 6.95)
    >>> raisins.subtotal()
    69.5
    >>> raisins.weight = -20  # garbage in...
    >>> raisins.subtotal()    # garbage out...
    -139.0
```

这是一个玩具的例子，但并不像你想象的那样奇特。这里有一个亚马逊网站早期的故事:

> 我们发现客户可以订购数量为负数的书籍！我想，我们会把价格记入他们的信用卡，然后等着他们把书运过来。
> 
> Amazon.com 创始人兼 CEO 杰夫·贝索斯 ^(10)

我们如何解决这个问题？我们可以改变`LineItem`的接口，为`weight`属性使用一个 getter 和一个 setter。这就是 Java 的方式，它没有错。

另一方面，很自然地可以通过赋值来设置项目的`weight`;也许这个系统已经投入生产，其他部分已经可以直接访问`item.weight`。在这种情况下，Python 的方法是用属性替换数据属性。

## LineItem Take #2:验证属性

实现一个属性将允许我们使用一个 getter 和一个 setter，但是`LineItem`的接口不会改变(即设置一个`LineItem`的`weight`仍然会写成`raisins.weight = 12`)。

示例 22-21 列出了读/写`weight`属性的代码。

##### 示例 22-21。 bulkfood_v2.py:一个带有`weight`属性的`LineItem`

```
classLineItem:def__init__(self,description,weight,price):self.description=descriptionself.weight=weight①self.price=pricedefsubtotal(self):returnself.weight*self.price@property②defweight(self):③returnself.__weight④@weight.setter⑤defweight(self,value):ifvalue>0:self.__weight=value⑥else:raiseValueError('value must be > 0')⑦
```

① 这里已经使用了属性 setter，确保不能创建带有负`weight`的实例。

② `@property`装饰吸气剂法。

③ 所有实现属性的方法共享公共属性的名称:`weight`。

④ 实际值存储在私有属性`__weight`中。

⑤ 装饰的 getter 有一个`.setter`属性，也是装饰器；这将 getter 和 setter 联系在一起。

⑥ 如果值大于零，我们设置私有`__weight`。

⑦ 否则，`ValueError`升高。

请注意，现在无法创建重量无效的`LineItem`:

```
>>> walnuts = LineItem('walnuts', 0, 10.00)
Traceback (most recent call last):
    ...
ValueError: value must be > 0
```

现在我们已经保护了`weight`不被用户提供负值。虽然买家通常不能设定一件商品的价格，但笔误或错误可能会创建一个带有负数的`LineItem`。为了防止这种情况，我们也可以将`price`转换成一个属性，但是这需要在我们的代码中进行一些重复。

还记得保罗·格拉厄姆在第 17 章引用的话吗:“当我在程序中看到模式时，我认为这是麻烦的迹象。”治疗重复的方法是抽象。有两种方法可以抽象出属性定义:使用属性工厂或描述符类。描述符类方法更加灵活，我们将在第 23 章对其进行全面的讨论。属性实际上是作为描述符类本身实现的。但是这里我们将通过实现一个作为函数的属性工厂来继续我们对属性的探索。

但是在实现属性工厂之前，我们需要对属性有更深入的理解。

# 正确看待房地产

虽然 经常用作装饰器，但是`property`内置其实是一个类。在 Python 中，函数和类通常是可互换的，因为两者都是可调用的，并且没有用于对象实例化的`new`操作符，所以调用构造函数与调用工厂函数没有区别。并且两者都可以用作装饰器，只要它们返回一个新的可调用对象，该对象是被装饰的可调用对象的合适替换。

这是`property`构造函数的完整签名:

```
property(fget=None, fset=None, fdel=None, doc=None)
```

所有参数都是可选的，如果没有为其中一个参数提供函数，则相应的操作将不会被结果 property 对象所允许。

Python 2.2 中添加了`property`类型，但是`@`修饰语法只出现在 Python 2.4 中，所以几年来，属性都是通过将访问器函数作为前两个参数来定义的。

在示例 22-22 中展示了定义属性的“经典”语法。

##### 示例 22-22。 bulkfood_v2b.py:同示例 22-21 ，但不使用装饰器

```
classLineItem:def__init__(self,description,weight,price):self.description=descriptionself.weight=weightself.price=pricedefsubtotal(self):returnself.weight*self.pricedefget_weight(self):①returnself.__weightdefset_weight(self,value):②ifvalue>0:self.__weight=valueelse:raiseValueError('value must be > 0')weight=property(get_weight,set_weight)③
```

① 普通的吸气剂。

② 普通二传手。

③ 构建`property`，并将其分配给一个公共类属性。

在某些情况下，经典形式比修饰语法更好；我们马上要讨论的属性工厂的代码就是一个例子。另一方面，在一个有许多方法的类体中，装饰者明确指出哪些是 getters 和 setters，而不依赖于在名字中使用前缀`get`和`set`的惯例。

一个类中属性的存在会影响如何在该类的实例中找到属性，这种方式起初可能会令人惊讶。下一节解释。

## 属性覆盖实例属性

属性总是类属性，但它们实际上管理类实例中的属性访问。

在“覆盖类属性”](ch11.xhtml#overriding_class_attributes)中，我们看到当一个实例和它的类都有一个同名的数据属性时，实例属性会覆盖或隐藏类属性——至少在读取该实例时是这样。[示例 22-23 说明了这一点。

##### 示例 22-23。实例属性隐藏了类`data`属性

```
>>> classClass:①... data='the class data attr'... @property... defprop(self):... return'the prop value'...>>> obj=Class()>>> vars(obj)②{} >>> obj.data③'the class data attr' >>> obj.data='bar'④>>> vars(obj)⑤{'data': 'bar'} >>> obj.data⑥'bar' >>> Class.data⑦'the class data attr'
```

① 用两个类属性定义`Class`:属性`data`和属性`prop`。

② `vars`返回`obj`的`__dict__`，表示它没有实例属性。

③ 从`obj.data`读取数据会检索`Class.data`的值。

④ 写入`obj.data`创建一个实例属性。

⑤ 检查实例以查看实例属性。

⑥ 现在从`obj.data`读取检索实例属性的值。当从`obj`实例中读取时，实例`data`隐藏了类`data`。

⑦ `Class.data`属性保持不变。

现在，让我们尝试覆盖`obj`实例上的`prop`属性。恢复之前的控制台会话，我们有示例 22-24 。

##### 示例 22-24。实例属性不隐藏类属性(上接示例 22-23 )

```
>>> Class.prop①<property object at 0x1072b7408> >>> obj.prop②'the prop value' >>> obj.prop='foo'③Traceback (most recent call last):
...AttributeError: can't set attribute>>> obj.__dict__['prop']='foo'④>>> vars(obj)⑤{'data': 'bar', 'prop': 'foo'} >>> obj.prop⑥'the prop value' >>> Class.prop='baz'⑦>>> obj.prop⑧'foo'
```

① 直接从`Class`读取`prop`检索属性对象本身，而不运行它的 getter 方法。

② 读取`obj.prop`执行属性 getter。

③ 尝试设置实例`prop`属性失败。

④ 把`'prop'`直接放到`obj.__dict__`作品里。

⑤ 我们可以看到`obj`现在有两个实例属性:`data`和`prop`。

⑥ 但是，读取`obj.prop`仍然运行属性 getter。实例属性不会隐藏该属性。

⑦ 覆盖`Class.prop`会破坏属性对象。

⑧ 现在`obj.prop`检索实例属性。`Class.prop`不再是属性，所以它不再覆盖`obj.prop`。

作为最后一个演示，我们将向`Class`添加一个新属性，并看到它覆盖了一个实例属性。示例 22-25 接替示例 22-24 的工作。

##### 示例 22-25。新类属性隐藏现有实例属性(上接示例 22-24 )

```
>>> obj.data①'bar' >>> Class.data②'the class data attr' >>> Class.data=property(lambdaself:'the "data" prop value')③>>> obj.data④'the "data" prop value' >>> delClass.data⑤>>> obj.data⑥'bar'
```

① `obj.data`检索实例的`data`属性。

② `Class.data`检索类别`data`属性。

③ 用新属性覆盖`Class.data`。

④ `obj.data`现在被`Class.data`地产跟踪。

⑤ 删除该属性。

⑥ `obj.data`现在再次读取实例`data`属性。

本节的要点是，像`obj.data`这样的表达式不会在`obj`中开始搜索`data`。搜索实际上从`obj.__class__`开始，只有当类中没有名为`data`的属性时，Python 才会在`obj`实例本身中查找。这通常适用于 *覆盖描述符*，其中属性只是一个例子。描述符的进一步处理必须等待第 23 章的。

现在回到属性。每个 Python 代码单元——模块、函数、类、方法——都可以有一个 docstring。下一个主题是如何将文档附加到属性。

## 财产文件

当控制台`help()`函数或 ide 等工具需要显示属性的文档时，它们从属性的`__doc__`属性中提取信息。

如果与经典调用语法一起使用，`property`可以获得文档字符串作为`doc`参数:

```
    weight = property(get_weight, set_weight, doc='weight in kilograms')
```

getter 方法的 docstring 带有`@property` decorator 本身的那个——被用作整个属性的文档。图 22-1 显示了由示例 22-26 中的代码生成的帮助屏幕。

![Screenshots of the Python console](Images/flpy_2201.png)

###### 图 22-1。Python 控制台发出`help(Foo.bar)`和`help(Foo)`命令时的截图。源代码在示例 22-26 中。

##### 示例 22-26。物业文件

```
class Foo:

    @property
    def bar(self):
        """The bar attribute"""
        return self.__dict__['bar']

    @bar.setter
    def bar(self, value):
        self.__dict__['bar'] = value
```

现在我们已经讨论了这些属性的基本要素，让我们回到保护`LineItem`的`weight`和`price`属性的问题上来，这样它们只接受大于零的值——但是不用手工实现两对几乎相同的 getter/setter。

# 编写属性工厂代码

我们将 创建一个工厂来创建`quantity`属性——这样命名是因为托管属性表示应用程序中不能为负或零的数量。示例 22-27 展示了使用两个`quantity`属性实例的`LineItem`类的简洁外观:一个用于管理`weight`属性，另一个用于`price`。

##### 示例 22-27。 bulkfood_v2prop.py:正在使用的`quantity`属性工厂

```
classLineItem:weight=quantity('weight')①price=quantity('price')②def__init__(self,description,weight,price):self.description=descriptionself.weight=weight③self.price=pricedefsubtotal(self):returnself.weight*self.price④
```

① 使用工厂将第一个定制属性`weight`定义为一个类属性。

② 第二次调用构建了另一个定制属性`price`。

③ 这里属性已经激活，确保否定或`0` `weight`被拒绝。

④ 这里也使用了属性，检索存储在实例中的值。

回想一下，属性是类属性。当构建每个`quantity`属性时，我们需要传递将由该特定属性管理的`LineItem`属性的名称。不幸的是，不得不在这一行中键入单词`weight`两次:

```
    weight = quantity('weight')
```

但是避免这种重复是复杂的，因为属性无法知道哪个类属性名称将被绑定到它。记住:先计算赋值的右边，所以当调用`quantity()`时，`weight`类属性甚至不存在。

###### 注意

改进`quantity`属性以便用户不需要重新输入属性名是一个不小的元编程问题。我们将在第 23 章中解决这个问题。

示例 22-28 列出了`quantity`属性工厂的实现。 ^(11)

##### 示例 22-28。bulk food _ v2 prop . py:`quantity`地产工厂

```
defquantity(storage_name):①defqty_getter(instance):②returninstance.__dict__[storage_name]③defqty_setter(instance,value):④ifvalue>0:instance.__dict__[storage_name]=value⑤else:raiseValueError('value must be > 0')returnproperty(qty_getter,qty_setter)⑥
```

① `storage_name`参数决定每个属性的数据存储在哪里；对于`weight`，存储名称将为`'weight'`。

② `qty_getter`的第一个参数可以命名为`self`，但是这很奇怪，因为这不是一个类体；`instance`指的是将存储属性的`LineItem`实例。

③ `qty_getter`引用了`storage_name`，所以在这个函数的关闭中会保留；直接从`instance.__dict__`中检索该值，以绕过该属性并避免无限递归。

④ 定义了`qty_setter`，也将`instance`作为第一个参数。

⑤ `value`直接存储在`instance.__dict__`中，再次绕过属性。

⑥ 构建一个自定义属性对象并返回它。

示例 22-28 中值得仔细研究的部分围绕着`storage_name`变量。当您以传统方式对每个属性进行编码时，您将在 getter 和 setter 方法中硬编码存储值的属性的名称。但是在这里，`qty_getter`和`qty_setter`函数是通用的，它们依赖于`storage_name`变量来知道从哪里获取/设置实例`__dict__`中的托管属性。每次调用`quantity`工厂来构建属性时，`storage_name`必须被设置为一个唯一的值。

函数`qty_getter`和`qty_setter`将被工厂函数最后一行中创建的`property`对象包装。稍后，当被调用执行它们的任务时，这些函数将从它们的闭包中读取`storage_name`,以确定在哪里检索/存储托管属性值。

在示例 22-29 中，我创建并检查了一个`LineItem`实例，暴露了存储属性。

##### 示例 22-29。 bulkfood_v2prop.py:探索属性和存储属性

```
 >>> nutmeg = LineItem('Moluccan nutmeg', 8, 13.95) >>> nutmeg.weight, nutmeg.price ① (8, 13.95) >>> nutmeg.__dict__ ② {'description': 'Moluccan nutmeg', 'weight': 8, 'price': 13.95}
```

① 通过隐藏同名实例属性的属性读取`weight`和`price`。

② 使用`vars`检查`nutmeg`实例:这里我们看到了用于存储值的实际实例属性。

请注意我们的工厂构建的属性如何利用在“属性覆盖实例属性”中描述的行为:`weight`属性覆盖`weight`实例属性，因此对`self.weight`或`nutmeg.weight`的每个引用都由属性函数处理，绕过属性逻辑的唯一方法是直接访问实例`__dict__`。

示例 22-28 中的代码可能有点复杂，但是很简洁:它的长度与示例 22-21 中定义`weight`属性的修饰 getter/setter 对的长度相同。示例 22-27 中的`LineItem`定义在没有 getter/setter 噪声的情况下看起来更好。

在一个真实的系统中，同一种验证可能出现在许多领域中，跨越几个类，并且`quantity`工厂将被放在一个实用模块中反复使用。最终，这个简单的工厂可以被重构为一个更具可扩展性的描述符类，由专门的子类执行不同的验证。我们将在第 23 章中讨论。

现在让我们用属性删除问题来结束对属性的讨论。

# 处理属性删除

我们 不仅可以使用`del`语句删除变量，还可以删除属性:

```
>>> class Demo:
...    pass
...
>>> d = Demo()
>>> d.color = 'green'
>>> d.color
'green'
>>> del d.color
>>> d.color
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Demo' object has no attribute 'color'
```

在实践中，删除属性并不是我们在 Python 中每天都要做的事情，用属性来处理它的要求就更不寻常了。但是是支持的，我能想到一个很傻的例子来论证。

在属性定义中，`@my_property.deleter`装饰器包装了负责删除由属性管理的属性的方法。正如所承诺的，傻傻的例子 22-30 的灵感来自*巨蟒和圣杯*中黑骑士的场景。 ^(12)

##### 示例 22-30。黑骑士. py

```
class BlackKnight:

    def __init__(self):
        self.phrases = [
            ('an arm', "'Tis but a scratch."),
            ('another arm', "It's just a flesh wound."),
            ('a leg', "I'm invincible!"),
            ('another leg', "All right, we'll call it a draw.")
        ]

    @property
    def member(self):
        print('next member is:')
        return self.phrases[0][0]

    @member.deleter
    def member(self):
        member, text = self.phrases.pop(0)
        print(f'BLACK KNIGHT (loses {member}) -- {text}')
```

*blackknight.py* 中的文档测试在示例 22-31 中。

##### 示例 22-31。Black Knight . py:doc tests for示例 22-30 (黑骑士从不认输)

```
 >>> knight = BlackKnight()
 >>> knight.member
 next member is:
 'an arm'
 >>> del knight.member
 BLACK KNIGHT (loses an arm) -- 'Tis but a scratch.
 >>> del knight.member
 BLACK KNIGHT (loses another arm) -- It's just a flesh wound.
 >>> del knight.member
 BLACK KNIGHT (loses a leg) -- I'm invincible!
 >>> del knight.member
 BLACK KNIGHT (loses another leg) -- All right, we'll call it a draw.
```

使用经典的调用语法而不是 decorators，`fdel`参数配置 deleter 函数。例如，`member`属性在`BlackKnight`类的主体中编码如下:

```
    member = property(member_getter, fdel=member_deleter)
```

如果你没有使用属性，属性删除也可以通过实现底层的`__delattr__`特殊方法来处理，在【属性处理的特殊方法】中有介绍。用`__delattr__`编写一个愚蠢的类是留给拖拉的读者的一个练习。

属性是一个强大的功能，但有时更简单或更低级的替代方法更好。在本章的最后一节，我们将回顾 Python 为动态属性编程提供的一些核心 API。

# 属性处理的基本属性和函数

在本章中，甚至在本书之前，我们已经使用了 Python 提供的一些内置函数和特殊方法来处理动态属性。本节在一个地方给出了它们的概述，因为它们的文档分散在官方文档中。

## 影响属性处理的特殊属性

以下部分中列出的许多函数和特殊方法的行为取决于三个特殊属性:

`__class__`

对对象类的引用(即`obj.__class__`与`type(obj)`相同)。Python 只在对象的类中寻找特殊方法，比如`__getattr__`，而不在实例本身中寻找。

`__dict__`

存储对象或类的可写属性的映射。拥有`__dict__`的对象可以在任何时候设置任意的新属性。如果一个类有一个`__slots__`属性，那么它的实例可能没有`__dict__`。参见`__slots__`(下一步)。

`__slots__`

可以在类中定义以节省内存的属性。`__slots__`是命名允许属性的字符串的`tuple`。 ^(13) 如果`'__dict__'`名称不在`__slots__`中，那么该类的实例将没有自己的`__dict__`，在那些实例中只允许使用`__slots__`中列出的属性。回忆“使用 __ 插槽 _ _ 节省内存”了解更多信息。

## 用于属性处理的内置函数

这五个内置函数执行对象属性读取、写入和自省:

`dir([object])`

列出了对象的大部分属性。官方文档](https://fpy.li/22-18)说`dir`是为了交互使用，所以它没有提供一个完整的属性列表，而是一个“有趣”的名称集。`dir`可以检查有无`__dict__`实现的对象。`dir`没有列出`__dict__`属性本身，但是列出了`__dict__`键。`dir`也没有列出类的几个特殊属性，如`__mro__`、`__bases__`、`__name__`。你可以通过实现`__dir__`特殊方法来定制`dir`的输出，正如我们在[示例 22-4 中看到的。如果没有给出可选的`object`参数，`dir`将列出当前作用域中的名称。

`getattr(object, name[, default])`

从`object`中获取由`name`字符串标识的 属性。主要用例是检索我们事先不知道名称的属性(或方法)。这可以从对象的类或超类中获取属性。如果不存在这样的属性，`getattr`引发`AttributeError`或返回`default`值(如果给定的话)。使用`gettatr`的一个很好的例子是在标准库的`cmd`包中的 [`Cmd.onecmd`方法](https://fpy.li/22-19)中，它用于获取和执行用户定义的命令。

`hasattr(object, name)`

如果命名属性存在于`object`中，则返回`True`，或者可以通过某种方式获取(例如，通过继承)。[文档](https://fpy.li/22-20)解释道:“这是通过调用 getattr(object，name)实现的，看看它是否会引发 AttributeError。”

`setattr(object, name, value)`

如果`object`允许的话，将`value`分配给`object`的命名属性。这可能会创建新属性或覆盖现有属性。

`vars([object])`

返回的和`object`的`__dict__`；`vars`不能处理定义了`__slots__`并且没有`__dict__`的类的实例(与`dir`相反，后者处理这样的实例)。如果没有参数，`vars()`的作用与`locals()`相同:返回一个代表本地范围的`dict`。

## 属性处理的特殊方法

当在用户定义的类中实现时，这里列出的特殊方法处理属性检索、设置、删除和列出。

属性 访问使用点符号或内置函数`getattr`、`hasattr`和`setattr`触发此处列出的适当的特殊方法。直接在实例`__dict__`中读写属性不会触发这些特殊的方法——如果需要，这是绕过它们的通常方式。

第[节“3.3.11。“数据模型”一章的“特殊方法查找”](https://fpy.li/22-21)警告道:

> 对于自定义类，只有在对象的类型上定义，而不是在对象的实例字典中定义，才能保证特殊方法的隐式调用正确工作。

换句话说，假设将在类本身上检索特殊方法，即使动作的目标是实例。因此，特殊方法不会被同名的实例属性隐藏。

在下面的例子中，假设有一个名为`Class`的类，`obj`是`Class`的实例，`attr`是`obj`的属性。

对于这些特殊方法中的每一个，属性访问是使用点符号还是使用“属性处理内置函数”中列出的内置函数都没有关系。比如`obj.attr`和`getattr(obj, 'attr', 42)`都触发`Class.__getattribute__(obj, 'attr')`。

`__delattr__(self, name)`

当试图使用`del`语句删除属性时，总是调用；例如`del obj.attr`触发`Class.__delattr__(obj, 'attr')`。如果`attr`是一个属性，那么如果这个类实现了`__delattr__`，它的 deleter 方法就不会被调用。

`__dir__(self)`

当在对象上调用`dir`时，调用，以提供属性列表；例如`dir(obj)`触发`Class.__dir__(obj)`。所有现代 Python 控制台中的制表符补全也使用它。

`__getattr__(self, name)`

在搜索了`obj`、`Class`及其超类之后，仅当检索命名属性的尝试失败时调用。表达式`obj.no_such_attr`、`getattr(obj, 'no_such_attr')`和`hasattr(obj, 'no_such_attr')`可以触发`Class.__getattr__(obj, 'no_such_attr')`，但前提是在`obj`或`Class`及其超类中找不到该名称的属性。

`__getattribute__(self, name)`

当试图直接从 Python 代码中检索命名属性时，总是调用(在某些情况下，解释器可能会绕过它，例如，获取`__repr__`方法)。点符号和`getattr`和`hasattr`内置触发该方法。`__getattr__`仅在`__getattribute__`之后调用，且仅在`__getattribute__`升高`AttributeError`时调用。为了检索实例`obj`的属性而不触发无限递归，`__getattribute__`的实现应该使用`super().__getattribute__(obj, name)`。

`__setattr__(self, name, value)`

当试图设置命名属性时，总是调用。点符号和`setattr`内置触发该方法；例如`obj.attr = 42`和`setattr(obj, 'attr', 42)`都触发`Class.__setattr__(obj, 'attr', 42)`。

###### 警告

实际上，因为它们是无条件调用的，并且实际上影响每个属性访问，所以`__getattribute__`和 `__setattr__` 特殊方法比 `__getattr__` 更难正确使用，后者只处理不存在的属性名。使用属性或描述符比定义这些特殊方法更不容易出错。

这就结束了我们对属性、特殊方法和其他动态属性编码技术的探索。

# 章节摘要

我们通过展示简单类的实际例子开始了对动态属性的介绍，以使处理 JSON 数据集更容易。第一个例子是`FrozenJSON`类，它将嵌套的字典和列表转换成嵌套的`FrozenJSON`实例和列表。`FrozenJSON`代码演示了使用`__getattr__`特殊方法动态转换数据结构，无论何时读取它们的属性。上一个版本的`FrozenJSON`展示了使用`__new__`构造器方法将一个类转换成一个灵活的对象工厂，而不局限于它自身的实例。

然后，我们将 JSON 数据集转换成一个`dict`，存储一个`Record`类的实例。`Record`的第一个版本只有几行，引入了“bunch”习语:使用`self.__dict__.update(**kwargs)`从传递给`__init__`的关键字参数构建任意属性。第二次迭代增加了`Event`类，通过属性实现链接记录的自动检索。计算出的属性值有时需要缓存，我们介绍了几种这样做的方法。

在意识到`@functools.cached_property`并不总是适用之后，我们学习了另一种选择:将`@property`组合在`@functools.cache`之上，按照这个顺序。

对属性的覆盖继续到了`LineItem`类，在这里部署了一个属性来保护`weight`属性免受没有商业意义的负值或零值的影响。在深入研究了属性语法和语义之后，我们创建了一个属性工厂来对`weight`和`price`执行相同的验证，而无需编写多个 getters 和 setters。属性工厂利用一些微妙的概念——比如闭包，以及由属性覆盖的实例属性——提供了一个优雅的通用解决方案，使用了与单个手工编码的属性定义相同的行数。

最后，我们简要地看了用属性处理属性删除，然后概述了核心 Python 语言中支持属性元编程的关键特殊属性、内置函数和特殊方法。

# 进一步阅读

属性处理和自检内置函数的官方文档是 Python 标准库的[第二章【内置函数】](https://fpy.li/22-22)。相关的特殊方法和`__slots__`特殊属性在[3 . 3 . 2 中的*Python 语言参考*中有记载。自定义属性访问"](https://fpy.li/22-23)。如何绕过实例调用特殊方法的语义在 ["3.3.9 中解释。特殊方法查找"](https://fpy.li/22-24)。在第 4 章“内置类型”的*中，Python 标准库的*、[4.13。特殊属性"](https://fpy.li/22-25)包括`__class__`和`__dict__`属性。

*巨蟒食谱](https://fpy.li/pycook3)* ，第 3 版。大卫·比兹利和布莱恩·k·琼斯(O'Reilly)写的有几个食谱涵盖了本章的主题，但我将重点介绍其中的三个:“食谱 8.8。在子类中扩展属性”解决了覆盖从超类继承的属性中的方法的棘手问题；“配方 8.15。“委托属性访问”实现了一个代理类，展示了本书[“属性处理的特殊方法”中的大多数特殊方法；还有超赞的“食谱 9.21”。避免重复的属性方法”，这是示例 22-28 中呈现的属性工厂功能的基础。

*[Python 概括地说，](https://fpy.li/pynut3)* 第 3 版。亚历克斯·马尔泰利(Alex Martelli)、安娜·拉文斯克罗夫特(Anna Ravenscroft)和史蒂夫·霍尔登(Steve Holden，O'Reilly)撰写的文章严谨而客观。他们只用了三页来讨论属性，但这是因为这本书遵循了一种公理化的呈现风格:前面的 15 页左右从头开始提供了 Python 类语义的全面描述，包括描述符，描述符是属性实际上是如何在幕后实现的。所以，当 Martelli 等人谈到房地产时，他们在那三页纸中包含了很多见解——包括我选择用来打开这一章的内容。

Bertrand Meyer——在本章开头的统一访问原则定义中引用——是契约式设计方法论的先驱，设计了 Eiffel 语言，并编写了优秀的*面向对象软件构造*，第二版。(皮尔森)。前六章提供了我所见过的关于面向对象分析和设计的最好的概念性介绍。第 11 章介绍了契约式设计，第 35 章提供了 Meyer 对一些有影响力的面向对象语言的评估:Simula、Smalltalk、CLOS(公共 Lisp 对象系统)、Objective-C、C++和 Java，并对其他一些语言进行了简要的评论。只有在这本书的最后一页，他才透露他用作伪代码的可读性很高的“符号”是 Eiffel。

^(1) 亚历克斯·马尔泰利、安娜·拉文斯克罗夫特、史蒂夫·霍尔登、 *[巨蟒一言以蔽之、](https://fpy.li/pynut3)* 第三版。(奥莱利)，第 123 页。

^(2)Bertrand Meyer，*面向对象软件构造*，第二版。(皮尔逊)，第 57 页。

^(3)OSCON——奥赖利开源大会——是新冠肺炎疫情的牺牲品。从 2021 年 1 月 10 日起，我在这些例子中使用的最初的 744 KB JSON 文件不再在线。您将在示例代码库中找到 [*osconfeed.json* 的副本。](https://fpy.li/22-1)

^(4) 两个例子是 [`AttrDict`](https://fpy.li/22-2) 和 [`addict`](https://fpy.li/22-3) 。

^(5) 表达式`self.__data[name]`是`KeyError`异常可能发生的地方。理想情况下，应该处理它并引发一个`AttributeError`，因为这是对`__getattr__`的期望。我们邀请勤奋的读者编写错误处理代码作为练习。

^(6) 数据的来源是 JSON，JSON 数据中唯一的集合类型是`dict`和`list`。

^(7) 顺便说一下，`Bunch`是 Alex Martelli 在 2001 年的一个名为[“一堆命名的东西的简单而方便的‘收集器’类”](https://fpy.li/22-4)的食谱中分享这个技巧时使用的类的名称。

^(8) 这其实是我在本章开篇提到的迈耶的均匀存取原理的一个不利方面。如果你对这个讨论感兴趣，请阅读可选的。

^(9) 来源:[@ functools . cached _ property](https://fpy.li/22-9)文档。我知道 Raymond Hettinger 撰写了这个解释，因为他是作为对我提交的一个问题的回应而写的:[BPO 42781—func tools . cached _ property 文档应该解释它是非覆盖的](https://fpy.li/22-11)。Hettinger 是官方 Python 文档和标准库的主要贡献者。他还写了优秀的[“描述符如何指导”](https://fpy.li/22-12)，这是第 23 章的关键资源。

^(10) 直接引自杰夫·贝索斯在*华尔街日报*的故事，[《推销员的诞生》](https://fpy.li/22-16)(2011 年 10 月 15 日)。请注意，截至 2021 年，您需要订阅才能阅读文章。

^(11) 本代码改编自《食谱 9.21》。避免重复的属性方法”来自*[Python Cookbook](https://fpy.li/pycook3)*，第 3 版。大卫·比兹利和布莱恩·k·琼斯(奥莱利)。

当我在 2021 年 10 月回顾这段视频时，这个血腥的场景在 Youtube 上已经有了。

Alex Martelli 指出，尽管可以将`__slots__`编码为`list`，但是最好是显式的，并且总是使用`tuple`，因为在处理完类体之后改变`__slots__`中的列表没有任何效果，所以在那里使用可变序列会产生误导。

^(14) 亚历克斯·马尔泰利，*巨蟒一言以蔽之*，第二版。(奥莱利)，第 101 页。

Jonathan Amsterdam 在《Dobbs 博士杂志》上发表的一篇名为[“Java 新被认为是有害的”](https://fpy.li/22-30)的文章以及获奖书籍 *Effective Java* 第三版的第一项“考虑静态工厂方法，而不是构造函数的”中给出了我要提到的原因。，作者约书亚·布洛赫(艾迪森-卫斯理)。``````