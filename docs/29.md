<link href="Styles/Style00.css" rel="stylesheet" type="text/css"> <link href="Styles/Style01.css" rel="stylesheet" type="text/css"> 

# 第二十四章。类元编程

> 每个人都知道调试比一开始写程序要难两倍。所以，如果你在编写它的时候尽可能的聪明，你将如何调试它呢？
> 
> Brian W. Kernighan 和 P. J. Plauger，*编程风格的要素* ^([1](ch24.xhtml#idm46582370208288))

类元编程是在运行时创建或定制类的艺术。类是 Python 中的一级对象，因此可以随时使用函数来创建新的类，而无需使用`class`关键字。类装饰器也是函数，但是被设计用来检查、改变、甚至用另一个类替换被装饰的类。最后，元类是类元编程最先进的工具:它们允许你创建具有特殊特征的全新类别的类，比如我们已经看到的抽象基类。

元类是强大的，但是很难证明是正确的，甚至更难。类装饰器解决了许多相同的问题，并且更容易理解。此外，Python 3.6 实现了[PEP 487——更简单的类创建定制](https://fpy.li/pep487)，提供了支持以前需要元类或类装饰器的任务的特殊方法。 ^([2](ch24.xhtml#idm46582370203888))

本章按照复杂程度的升序介绍了类元编程技术。

###### 警告

这是一个激动人心的话题，很容易让人忘乎所以。所以我必须提出这个建议。

出于可读性和可维护性的考虑，您可能应该在应用程序代码中避免本章中描述的技术。

另一方面，如果你想写下一个伟大的 Python 框架，这些是交易的工具。

# 本章的新内容

第一版 *Fluent Python* 的“类元编程”章节中的所有代码仍然正确运行。然而，鉴于 Python 3.6 以来添加的新特性，前面的一些示例不再代表最简单的解决方案。

我用不同的例子替换了这些例子，强调了 Python 新的元编程特性，或者添加了进一步的要求来证明使用更高级的技术是正确的。一些新的例子利用类型提示来提供类似于`@dataclass`装饰器和`typing.NamedTuple`的类构建器。

“真实世界中的元类”是一个新的章节，包含了一些关于元类适用性的高级考虑。

###### 小费

一些最好的重构是删除用更新更简单的方法解决相同问题而产生的冗余代码。这适用于生产代码和书籍。

我们将从回顾 Python 数据模型中为所有类定义的属性和方法开始。

# 作为对象的类

像 Python 中的大多数程序实体一样，类也是对象。每个类都有许多在 Python 数据模型中定义的属性，记录在 ["4.13 中。Python 标准库中*章节“内置类型”的特殊属性*](https://fpy.li/24-1)。这些属性中的三个 在本书中已经出现过几次:`__class__`、`__name__`和`__mro__`。其他类别标准属性包括:

`cls.__bases__`

该类的基类的元组。

`cls.__qualname__`

类或函数的限定名，这是从模块的全局范围到类定义的虚线路径。当一个类在另一个类中定义时，这是相关的。比如在 [`Ox`](https://fpy.li/24-2) 这样的 Django 模型类中，有一个内部类叫做`Meta`。`Meta`的`__qualname__`是`Ox.Meta`，但它的`__name__`只是`Meta`。该属性的规范是[PEP 3155—类和函数的限定名](https://fpy.li/24-3)。

`cls.__subclasses__()`

这个方法返回这个类的直接子类的列表。该实现使用弱引用来避免超类及其子类之间的循环引用——在它们的`__bases__`属性中包含对超类的强引用。该方法列出当前在内存中的子类。尚未导入的模块中的子类不会出现在结果中。

`cls.mro()`

解释器在构建一个类时调用这个方法来获取存储在该类的`__mro__`属性中的超类元组。一个元类可以覆盖这个方法来定制这个类在构造下的方法解析顺序。

###### 小费

本节提到的属性都没有被`dir(…)`功能列出。

现在，如果一个类是一个对象，那么一个类的类是什么？

# 类型:内置的类工厂

我们通常认为`type`是一个返回对象类的函数，因为这就是`type(my_object)`所做的:它返回`my_object.__class__`。

然而，`type`是一个在用三个参数调用时创建新类的类。

考虑这个简单的类:

```
class MyClass(MySuperClass, MyMixin):
    x = 42

    def x2(self):
        return self.x * 2
```

使用`type`构造函数，您可以用下面的代码在运行时创建`MyClass`:

```
MyClass = type('MyClass',
               (MySuperClass, MyMixin),
               {'x': 42, 'x2': lambda self: self.x * 2},
          )
```

该`type`调用在功能上等同于之前的`class MyClass…`块语句。

当 Python 读取一个`class`语句时，它调用`type`用这些参数构建类对象:

`name`

出现在`class`关键字之后的标识符，例如`MyClass`。

`bases`

类标识符后括号中给出的超类元组，如果在`class`语句中没有提到超类，则为`(object,)`。

`dict`

属性名到值的映射。可调用变成了方法，正如我们在[“方法是描述符”](ch23.xhtml#methods_are_descriptors_sec)中看到的。其他值成为类属性。

###### 注意

`type`构造函数接受可选的关键字参数，这些参数被`type`本身忽略，但被原封不动地传递给`__init_subclass__`，后者必须使用它们。我们将在“介绍 _ _ init _ subclass _ _”中研究这个特殊的方法，但是我不会涉及关键字参数的使用。更多内容，请阅读[PEP 487—更简单的类创建定制](https://fpy.li/pep487)。

`type`类是一个 *元类*:一个构建类的类。换句话说，`type`类的实例就是类。标准库提供了一些其他的元类，但是`type`是默认的:

```
>>> type(7)
<class 'int'>
>>> type(int)
<class 'type'>
>>> type(OSError)
<class 'type'>
>>> class Whatever:
...     pass
...
>>> type(Whatever)
<class 'type'>
```

我们将在“元类 101”中构建自定义元类。

接下来，我们将使用内置的`type`来创建一个构建类的函数。

# 类工厂函数

标准库有一个在本书中多次出现的类工厂函数:`collections.namedtuple`。在[第五章](ch05.xhtml#data_class_ch)我们也看到了`typing.NamedTuple`和`@dataclass`。所有这些类构建器都利用了本章中介绍的技术。

我们将从一个超级简单的可变对象类工厂开始——这是对`@dataclass`最简单的替代。

假设我正在编写一个宠物店应用程序，我想将狗的数据存储为简单的记录。但是我不想写这样的样板文件:

```
class Dog:
    def __init__(self, name, weight, owner):
        self.name = name
        self.weight = weight
        self.owner = owner
```

无聊……每个字段名出现三次，这个样板文件甚至没有给我们带来一个好的`repr`:

```
>>> rex = Dog('Rex', 30, 'Bob')
>>> rex
<__main__.Dog object at 0x2865bac>
```

从`collections.namedtuple`中得到一个提示，让我们创建一个`record_factory`，它可以动态地创建像`Dog`这样的简单类。例 24-1 显示了它应该如何工作。

##### 例 24-1。测试`record_factory`，一个简单的类工厂

```
>>>Dog=record_factory('Dog','name weight owner')![1](Images/1.png)>>>rex=Dog('Rex',30,'Bob')>>>rex![2](Images/2.png)Dog(name='Rex',weight=30,owner='Bob')>>>name,weight,_=rex![3](Images/3.png)>>>name,weight('Rex',30)>>>"{2}'s dog weighs {1}kg".format(*rex)![4](Images/4.png)"Bob's dog weighs 30kg">>>rex.weight=32![5](Images/5.png)>>>rexDog(name='Rex',weight=32,owner='Bob')>>>Dog.__mro__![6](Images/6.png)(<class'factories.Dog'>, <class 'object'>)
```

![1](Images/1.png)

工厂可以像`namedtuple`一样调用:类名，后面是属性名，在单个字符串中用空格分隔。

![2](Images/2.png)

好听的`repr`。

![3](Images/3.png)

实例是可迭代的，所以在赋值时可以方便地解包…

![4](Images/4.png)

…或者在传递给`format`这样的函数时。

![5](Images/5.png)

记录实例是可变的。

![6](Images/6.png)

新创建的类继承自`object`——与我们的工厂没有关系。

`record_factory`的代码在例 24-2 中。 ^([3](ch24.xhtml#idm46582369630768))

##### 例 24-2。一个简单的类工厂

```
fromtypingimportUnion,Anyfromcollections.abcimportIterable,IteratorFieldNames=Union[str,Iterable[str]]![1](Images/1.png)defrecord_factory(cls_name:str,field_names:FieldNames)->type[tuple]:![2](Images/2.png)slots=parse_identifiers(field_names)![3](Images/3.png)def__init__(self,*args,**kwargs)->None:![4](Images/4.png)attrs=dict(zip(self.__slots__,args))attrs.update(kwargs)forname,valueinattrs.items():setattr(self,name,value)def__iter__(self)->Iterator[Any]:![5](Images/5.png)fornameinself.__slots__:yieldgetattr(self,name)def__repr__(self):![6](Images/6.png)values=', '.join(f'{name}={value!r}'forname,valueinzip(self.__slots__,self))cls_name=self.__class__.__name__returnf'{cls_name}({values})'cls_attrs=dict(![7](Images/7.png)__slots__=slots,__init__=__init__,__iter__=__iter__,__repr__=__repr__,)returntype(cls_name,(object,),cls_attrs)![8](Images/8.png)defparse_identifiers(names:FieldNames)->tuple[str,...]:ifisinstance(names,str):names=names.replace(',','').split()![9](Images/9.png)ifnotall(s.isidentifier()forsinnames):raiseValueError('names must all be valid identifiers')returntuple(names)
```

![1](Images/1.png)

用户可以将字段名作为单个字符串或可重复的字符串提供。

![2](Images/2.png)

接受类似`collections.namedtuple`前两个的论点；返回一个`type`—即一个行为类似于`tuple`的类。

![3](Images/3.png)

构建属性名称元组；这将是新类的`__slots__`属性。

![4](Images/4.png)

这个函数将成为新类中的`__init__`方法。它接受位置和/或关键字参数。 ^([4](ch24.xhtml#idm46582369288640))

![5](Images/5.png)

按照`__slots__`给出的顺序生成字段值。

![6](Images/6.png)

产生好的`repr`，迭代`__slots__`和`self`。

![7](Images/7.png)

汇编一个类属性字典。

![8](Images/8.png)

构建并返回新类，调用`type`构造函数。

![9](Images/9.png)

将空格或逗号分隔的`names`转换为`str`列表。

例 24-2 是我们第一次在类型提示中看到`type`。如果注释仅仅是`-> type`，那将意味着`record_factory`返回一个类——这将是正确的。但是注释`-> type[tuple]`更精确:它说返回的类将是`tuple`的子类。

例 24-2 中`record_factory`的最后一行构建了一个以`cls_name`的值命名的类，以`object`为其单一直接基类，命名空间加载了`__slots__`、`__init__`、`__iter__`和`__repr__`，其中后三个是实例方法。

我们可以将`__slots__`类属性命名为其他名称，但是我们必须实现`__setattr__`来验证被分配的属性的名称，因为对于我们的记录类，我们希望属性集总是相同的，并且顺序相同。然而，回想一下`__slots__`的主要特性是在处理数百万个实例时节省内存，并且使用`__slots__`有一些缺点，在[“使用 __slots__”中讨论过](ch11.xhtml#slots_section)。

###### 警告

由`record_factory`创建的类的实例是不可序列化的——也就是说，它们不能用`dump`函数从`pickle`模块中导出。解决这个问题超出了本例的范围，本例的目的是在一个简单的用例中展示`type`类的作用。完整解决方案，研究源代码为[`collections.namedtuple`](https://fpy.li/24-4)；搜索单词“腌制。”

现在让我们来看看如何模拟更现代的类构建器，如`typing.NamedTuple`，它采用一个用户定义的类编写为`class`语句，并自动增强它的功能。

# 引入 __init_subclass__

`__init_subclass__`和`__set_name__`都是在[PEP 487——更简单的类创建定制](https://fpy.li/pep487)中提出的。我们在[“LineItem Take # 4:存储属性的自动命名”](ch23.xhtml#auto_storage_sec)中第一次看到了`__set_name__`描述符的特殊方法。现在让我们来学习`__init_subclass__`。

在[第 5 章](ch05.xhtml#data_class_ch)中，我们看到`typing.NamedTuple`和`@dataclass`让程序员使用`class`语句为一个新类指定属性，然后由类构建器通过自动添加像`__init__`、`__repr__`、`__eq__`等基本方法来增强。

这两个类构造器都读取用户的`class`语句中的类型提示来增强类。这些类型提示还允许静态类型检查器验证设置或获取这些属性的代码。然而，`NamedTuple`和`@dataclass`没有利用类型提示的在运行时进行属性验证。下一个示例中的`Checked`类会。

###### 注意

对于运行时类型检查，不可能支持每一个可以想到的静态类型提示，这可能是为什么`typing.NamedTuple`和`@dataclass`甚至不尝试它的原因。然而，一些也是具体类的类型可以和`Checked`一起使用。这包括常用于字段内容的简单类型，如`str`、`int`、`float`和`bool`，以及这些类型的列表。

示例 24-3 展示了如何使用`Checked`构建一个`Movie`类。

##### 例 24-3。init sub/checked lib . py:doctest，用于创建`Checked`的`Movie`子类

```
>>>classMovie(Checked):![1](Images/1.png)...title:str![2](Images/2.png)...year:int...box_office:float...>>>movie=Movie(title='The Godfather',year=1972,box_office=137)![3](Images/3.png)>>>movie.title'The Godfather'>>>movie![4](Images/4.png)Movie(title='The Godfather',year=1972,box_office=137.0)
```

![1](Images/1.png)

`Movie`继承自`Checked`——我们将在后面的示例 24-5 中定义。

![2](Images/2.png)

每个属性都用构造函数进行了注释。这里我使用了内置类型。

![3](Images/3.png)

`Movie`必须使用关键字参数创建实例。

![4](Images/4.png)

作为回报，你得到一个漂亮的`__repr__`。

用作属性类型提示的构造函数可以是任何可调用的函数，它接受零个或一个参数，并返回一个适合于预期字段类型的值，或者通过引发`TypeError`或`ValueError`来拒绝该参数。

对示例 24-3 中的注释使用内置类型意味着该类型的构造函数必须接受这些值。对于`int`，这意味着任何`x`使得`int(x)`返回一个`int`。对于`str`，在运行时什么都可以，因为`str(x)`可以与 Python 中的任何`x`一起工作。 ^([5](ch24.xhtml#idm46582368980672))

当不带参数调用时，构造函数应返回其类型的默认值。 ^([6](ch24.xhtml#idm46582368978384))

这是 Python 内置构造函数的标准行为:

```
>>> int(), float(), bool(), str(), list(), dict(), set()
(0, 0.0, False, '', [], {}, set())
```

在像`Movie`这样的`Checked`子类中，缺少的参数会用字段构造函数返回的默认值创建实例。例如:

```
    >>> Movie(title='Life of Brian')
    Movie(title='Life of Brian', year=0, box_office=0.0)
```

构造函数用于在实例化期间以及在实例上直接设置属性时进行验证:

```
    >>> blockbuster = Movie(title='Avatar', year=2009, box_office='billions')
    Traceback (most recent call last):
      ...
    TypeError: 'billions' is not compatible with box_office:float
    >>> movie.year = 'MCMLXXII'
    Traceback (most recent call last):
      ...
    TypeError: 'MCMLXXII' is not compatible with year:int
```

# 检查子类和静态类型检查

在一个*中。py* 源文件带有`Movie`的`movie`实例，如示例 24-3 中所定义，Mypy 将此赋值标记为类型错误:

```
movie.year = 'MCMLXXII'
```

但是，Mypy 不能检测这个构造函数调用中的类型错误:

```
blockbuster = Movie(title='Avatar', year='MMIX')
```

这是因为`Movie`继承了`Checked.__init__`，该方法的签名必须接受任何关键字参数，以支持任意的用户定义类。

另一方面，如果你用类型提示`list[float]`声明了一个`Checked`子类字段，Mypy 可以用不兼容的内容标记列表的赋值，但是`Checked`将忽略类型参数并将其视为与`list`相同。

现在让我们看看 *checkedlib.py* 的实现。第一类是`Field`描述符，如例 24-4 所示。

##### 例 24-4。init sub/checked lib . py:`Field`描述符类

```
fromcollections.abcimportCallable![1](Images/1.png)fromtypingimportAny,NoReturn,get_type_hintsclassField:def__init__(self,name:str,constructor:Callable)->None:![2](Images/2.png)ifnotcallable(constructor)orconstructoristype(None):![3](Images/3.png)raiseTypeError(f'{name!r} type hint must be callable')self.name=nameself.constructor=constructordef__set__(self,instance:Any,value:Any)->None:ifvalueis...:![4](Images/4.png)value=self.constructor()else:try:value=self.constructor(value)![5](Images/5.png)except(TypeError,ValueError)ase:![6](Images/6.png)type_name=self.constructor.__name__msg=f'{value!r} is not compatible with {self.name}:{type_name}'raiseTypeError(msg)fromeinstance.__dict__[self.name]=value![7](Images/7.png)
```

![1](Images/1.png)

回想一下，从 Python 3.9 开始，注释的`Callable`类型是`collections.abc`中的 ABC，而不是已经废弃的`typing.Callable`。

![2](Images/2.png)

这是一个最小的`Callable`类型提示；`constructor`的参数类型和返回类型都是隐式的`Any`。

![3](Images/3.png)

对于运行时检查，我们使用内置的`callable`。 ^([7](ch24.xhtml#idm46582368512208)) 对`type(None)`的测试是必要的，因为 Python 在一个类型中读取`None`作为`NoneType`、`None`的类(因此是可调用的)，但是一个无用的构造函数，只返回`None`。

![4](Images/4.png)

如果`Checked.__init__`将`value`设置为`...`(`Ellipsis`内置对象)，我们就不带参数调用`constructor`。

![5](Images/5.png)

否则，用给定的`value`调用`constructor`。

![6](Images/6.png)

如果`constructor`引发了这些异常中的任何一个，我们将引发`TypeError`并给出一条有用的消息，包括字段和构造函数的名称；如`'MMIX' is not compatible with year:int`。

![7](Images/7.png)

如果没有出现异常，`value`被存储在`instance.__dict__`中。

在`__set__`中，我们需要捕捉`TypeError`和`ValueError`，因为内置构造函数可能会根据参数引发其中任何一个。比如`float(None)`养`TypeError`，但是`float('A')`养`ValueError`。另一方面，`float('8')`不产生错误并返回`8.0`。我在此声明，这是这个玩具例子的一个特性，而不是一个 bug。

###### 小费

在“LineItem Take # 4:存储属性的自动命名”](ch23.xhtml#auto_storage_sec)中，我们看到了方便的`__set_name__`描述符的特殊方法。我们在`Field`类中不需要它，因为描述符没有在客户机源代码中实例化；用户声明的类型是构造函数，正如我们在`Movie`类中看到的那样([示例 24-3 )。相反，`Field`描述符实例是由`Checked.__init_subclass__`方法在运行时创建的，我们将在示例 24-5 中看到。

现在我们来关注一下`Checked`类。我把它分成两份清单。例 24-5 显示了类的顶部，它包括了这个例子中最重要的方法。其余方法在例 24-6 中。

##### 例 24-5。init sub/checked lib . py:`Checked`类中最重要的方法

```
classChecked:@classmethoddef_fields(cls)->dict[str,type]:![1](Images/1.png)returnget_type_hints(cls)def__init_subclass__(subclass)->None:![2](Images/2.png)super().__init_subclass__()![3](Images/3.png)forname,constructorinsubclass._fields().items():![4](Images/4.png)setattr(subclass,name,Field(name,constructor))![5](Images/5.png)def__init__(self,**kwargs:Any)->None:fornameinself._fields():![6](Images/6.png)value=kwargs.pop(name,...)![7](Images/7.png)setattr(self,name,value)![8](Images/8.png)ifkwargs:![9](Images/9.png)self.__flag_unknown_attrs(*kwargs)![10](Images/10.png)
```

![1](Images/1.png)

我编写了这个类方法来隐藏对`typing.get_type_hints`的调用，不让其他类知道。如果我只需要支持 Python ≥ 3.10，我会调用`inspect.get_annotations`来代替。查看[“运行时注释的问题”](ch15.xhtml#problems_annot_runtime_sec)了解这些函数的问题。

![2](Images/2.png)

`__init_subclass__`在当前类的子类被定义时被调用。它把这个新子类作为它的第一个参数——这就是为什么我把这个参数命名为`subclass`而不是通常的`cls`。关于这个的更多信息，请参见“_ _ init _ subclass _ _ 不是典型的类方法”。

![3](Images/3.png)

`super().__init_subclass__()`并不是绝对必要的，但是应该被调用来与其他可能在同一个继承图中实现`.__init_subclass__()`的类友好相处。参见[“多重继承和方法解析顺序”](ch14.xhtml#mro_section)。

![4](Images/4.png)

迭代每个字段`name`和`constructor` …

![5](Images/5.png)

…在`subclass`上创建一个属性，将那个`name`绑定到一个用`name`和`constructor`参数化的`Field`描述符。

![6](Images/6.png)

对于类别字段中的每个`name`……

![7](Images/7.png)

…从`kwargs`中取出相应的`value`并从`kwargs`中取出。使用`...`(`Ellipsis`对象)作为默认值允许我们区分给定值`None`的参数和没有给定值的参数。 ^([8](ch24.xhtml#idm46582368159120))

![8](Images/8.png)

该`setattr`调用触发`Checked.__setattr__`，如例 24-6 所示。

![9](Images/9.png)

如果`kwargs`中还有剩余的条目，它们的名称与任何声明的字段都不匹配，那么`__init__`将失败。

![10](Images/10.png)

该错误由`__flag_unknown_attrs`报告，列在例 24-6 中。它采用一个带有未知属性名称的`*names`参数。我在`*kwargs`中使用了一个星号来作为参数序列传递它的键。

现在让我们看看`Checked`类的其余方法，从示例 24-5 继续。注意，我在`_fields`和`_asdict`方法名前面加上了`_`，原因和`collections.namedtuple` API 一样:减少与用户定义的字段名称冲突的机会。

##### 例 24-6。init sub/checked lib . py:`Checked`类的剩余方法

```
def__setattr__(self,name:str,value:Any)->None:![1](Images/1.png)ifnameinself._fields():![2](Images/2.png)cls=self.__class__descriptor=getattr(cls,name)descriptor.__set__(self,value)![3](Images/3.png)else:![4](Images/4.png)self.__flag_unknown_attrs(name)def__flag_unknown_attrs(self,*names:str)->NoReturn:![5](Images/5.png)plural='s'iflen(names)>1else''extra=', '.join(f'{name!r}'fornameinnames)cls_name=repr(self.__class__.__name__)raiseAttributeError(f'{cls_name} object has no attribute{plural} {extra}')def_asdict(self)->dict[str,Any]:![6](Images/6.png)return{name:getattr(self,name)forname,attrinself.__class__.__dict__.items()ifisinstance(attr,Field)}def__repr__(self)->str:![7](Images/7.png)kwargs=', '.join(f'{key}={value!r}'forkey,valueinself._asdict().items())returnf'{self.__class__.__name__}({kwargs})'
```

![1](Images/1.png)

拦截所有设置实例属性的尝试。这是防止设置未知属性所必需的。

![2](Images/2.png)

如果属性`name`已知，获取相应的`descriptor`。

![3](Images/3.png)

通常我们不需要显式调用描述符`__set__`。在这种情况下，这是必要的，因为`__setattr__`拦截所有在实例上设置属性的尝试，包括在覆盖描述符(如`Field`)存在的情况下。 ^([9](ch24.xhtml#idm46582367837152))

![4](Images/4.png)

否则，属性`name`未知，将由`__flag_unknown_attrs`引发异常。

![5](Images/5.png)

构建一个有用的错误消息，列出所有意外的参数，并引发`AttributeError`。这是`NoReturn`特殊类型的一个罕见例子，包含在[“no return”](ch08.xhtml#noreturn_sec)中。

![6](Images/6.png)

从一个`Movie`对象的属性创建一个`dict`。我将这个方法称为`_as_dict`，但是我遵循了从`collections.namedtuple`中的`_asdict`方法开始的约定。

![7](Images/7.png)

实现一个漂亮的`__repr__`是这个例子中使用`_asdict`的主要原因。

`Checked`示例说明了在实现`__setattr__`以阻止实例化后的任意属性设置时，如何处理覆盖描述符。在这个例子中实现`__setattr__`是否值得是有争议的。如果没有它，设置`movie.director = 'Greta Gerwig'`将会成功，但是`director`属性不会以任何方式被检查，不会出现在`__repr__`中，也不会包含在`_asdict`返回的`dict`中——两者都在示例 24-6 中定义。

在*record _ factory . py*(例 24-2 )中我用`__slots__` class 属性解决了这个问题。然而，这种更简单的解决方案在这种情况下是不可行的，如下所述。

## 为什么 __init_subclass__ 无法配置 __slots__

`__slots__`属性只有在它是传递给`type.__new__`的类名称空间中的条目之一时才有效。将`__slots__`添加到现有的类中没有任何效果。Python 只有在类构建好之后才调用`__init_subclass__`——到那时再配置`__slots__`就太晚了。一个类装饰器也不能配置`__slots__`，因为它的应用甚至比`__init_subclass__`还要晚。我们将在“何时发生:导入时间与运行时间”中探讨这些计时问题。

为了在运行时配置`__slots__`，您自己的代码必须构建作为`type.__new__`的最后一个参数传递的类名称空间。为此，您可以编写一个类工厂函数，如 *record_factory.py* ，或者您可以选择核心选项并实现一个元类。我们将在“元类 101”中看到如何动态配置`__slots__`。

在 [PEP 487](https://fpy.li/pep487) 使用 Python 3.7 中的`__init_subclass__`简化类创建的定制之前，类似的功能必须使用类装饰器来实现。这是下一节的重点。

# 用类装饰器增强类

一个 类装饰器是一个行为类似于函数装饰器的可调用程序:它获取被装饰的类作为参数，并且应该返回一个类来替换被装饰的类。类装饰者通常在通过属性赋值在类中注入更多的方法之后，返回被装饰的类本身。

选择类装饰器而不是简单的`__init_subclass__`的最常见原因可能是为了避免干扰其他类特性，比如继承和元类。 ^([10](ch24.xhtml#idm46582367752592))

在本节中，我们将研究 *checkeddeco.py* ，它提供与 *checkedlib.py* 相同的服务，但是使用了类装饰器。像往常一样，我们将从查看一个使用示例开始，该示例摘自 *checkeddeco.py* ( 示例 24-7 )中的 doctests。

##### 例 24-7。 checkeddeco.py:创建一个用`@checked`装饰的`Movie`类

```
    >>> @checked
    ... class Movie:
    ...     title: str
    ...     year: int
    ...     box_office: float
    ...
    >>> movie = Movie(title='The Godfather', year=1972, box_office=137)
    >>> movie.title
    'The Godfather'
    >>> movie
    Movie(title='The Godfather', year=1972, box_office=137.0)
```

例 24-7 和例 24-3 唯一的区别就是`Movie`类的声明方式:它是用`@checked`修饰的，而不是子类`Checked`。否则外部行为相同，包括“引入 _ _ init _ subclass _ _”中示例 24-3 后显示的类型验证和默认值赋值。

现在我们来看看 *checkeddeco.py* 的实现。导入和`Field`类与例 24-4 中所列 *checkedlib.py* 中的相同。没有其他类，只有 *checkeddeco.py* 中的函数。

先前在`__init_subclass__`中实现的逻辑现在是`checked`函数的一部分——在示例 24-8 中列出的类装饰器。

##### 例 24-8。 checkeddeco.py:类装饰器

```
defchecked(cls:type)->type:![1](Images/1.png)forname,constructorin_fields(cls).items():![2](Images/2.png)setattr(cls,name,Field(name,constructor))![3](Images/3.png)cls._fields=classmethod(_fields)# type: ignore ![4](Images/4.png)instance_methods=(![5](Images/5.png)__init__,__repr__,__setattr__,_asdict,__flag_unknown_attrs,)formethodininstance_methods:![6](Images/6.png)setattr(cls,method.__name__,method)returncls![7](Images/7.png)
```

![1](Images/1.png)

回想一下，类是`type`的实例。这些类型提示强烈暗示这是一个类装饰器:它接受一个类并返回一个类。

![2](Images/2.png)

`_fields`是模块后面定义的顶层函数(在例 24-9 )。

![3](Images/3.png)

用一个`Field`描述符实例替换`_fields`返回的每个属性就是`__init_subclass__`在示例 24-5 中所做的。这里有更多的工作要做…

![4](Images/4.png)

从`_fields`构建一个类方法，并将其添加到修饰类中。因为 Mypy 抱怨说`type`没有`_fields`属性，所以需要`type: ignore`注释。

![5](Images/5.png)

将成为修饰类的实例方法的模块级函数。

![6](Images/6.png)

将每个`instance_methods`添加到`cls`。

![7](Images/7.png)

返回装饰过的`cls`，完成一个类装饰者的基本契约。

*checkeddeco.py* 中的每个顶级函数都有一个下划线前缀，除了`checked`装饰器。这种命名约定有几个原因:

*   `checked`是 *checkeddeco.py* 模块公共接口的一部分，其他函数不是。

*   例 24-9 中的函数会被注入到修饰类中，前导`_`减少了与修饰类的自定义属性和方法发生命名冲突的几率。

其余 *checkeddeco.py* 列于例 24-9 中。那些模块级函数与 *checkedlib.py* 的`Checked`类的对应方法具有相同的代码。在示例 24-5 和 24-6 中进行了说明。

注意`_fields`功能在 *checkeddeco.py* 中有双重功能。在`checked` decorator 的第一行中作为常规函数使用，同时也会作为被修饰类的类方法注入。

##### 例 24-9。 checkeddeco.py:要注入装饰类中的方法

```
def _fields(cls: type) -> dict[str, type]:
    return get_type_hints(cls)

def __init__(self: Any, **kwargs: Any) -> None:
    for name in self._fields():
        value = kwargs.pop(name, ...)
        setattr(self, name, value)
    if kwargs:
        self.__flag_unknown_attrs(*kwargs)

def __setattr__(self: Any, name: str, value: Any) -> None:
    if name in self._fields():
        cls = self.__class__
        descriptor = getattr(cls, name)
        descriptor.__set__(self, value)
    else:
        self.__flag_unknown_attrs(name)

def __flag_unknown_attrs(self: Any, *names: str) -> NoReturn:
    plural = 's' if len(names) > 1 else ''
    extra = ', '.join(f'{name!r}' for name in names)
    cls_name = repr(self.__class__.__name__)
    raise AttributeError(f'{cls_name} has no attribute{plural} {extra}')

def _asdict(self: Any) -> dict[str, Any]:
    return {
        name: getattr(self, name)
        for name, attr in self.__class__.__dict__.items()
        if isinstance(attr, Field)
    }

def __repr__(self: Any) -> str:
    kwargs = ', '.join(
        f'{key}={value!r}' for key, value in self._asdict().items()
    )
    return f'{self.__class__.__name__}({kwargs})'
```

模块实现了一个简单但有用的类装饰器。Python 的`@dataclass`做得更多。它支持许多配置选项，向修饰类添加更多方法，处理或警告与修饰类中用户定义方法的冲突，甚至遍历`__mro__`来收集在修饰类的超类中声明的用户定义属性。Python 3.9 中`dataclasses`包的[源代码](https://fpy.li/24-10)长达 1200 多行。

对于元编程类，我们必须知道在构造类的过程中 Python 解释器何时评估每个代码块。这将在下面讨论。

# 何时会发生什么:导入时间与运行时间

Python 程序员 谈论“导入时间”和“运行时间”，但是这两个术语没有严格定义，它们之间存在灰色地带。

在导入时，解释器:

1.  解析一个*的源代码。py* 模块从上到下一次通过。这是一个`SyntaxError`可能发生的时候。

2.  编译要执行的字节码。

3.  执行已编译模块的顶级代码。

如果有最新的*。pyc* 文件在本地`__pycache__`可用，解析和编译被跳过，因为字节码已经准备好运行。

虽然解析和编译肯定是“导入时间”活动，但在那个时候可能会发生其他事情，因为 Python 中的几乎每个语句都是可执行的，因为它们可能会运行用户代码，并且可能会改变用户程序的状态。

特别是，`import`语句不仅仅是一个声明，它实际上运行一个模块第一次被导入时的所有顶层代码。同一模块的进一步导入将使用缓存，然后唯一的效果将是将导入的对象绑定到客户机模块中的名称。顶层代码可以做任何事情，包括“运行时”的典型动作，比如写入日志或连接到数据库。 ^([12](ch24.xhtml#idm46582367216544)) 这就是为什么“导入时间”和“运行时”之间的界限是模糊的:`import`语句可以触发各种“运行时”行为。相反，“导入时间”也可能发生在运行时内部，因为`import`语句和内置的`__import__()`可以在任何常规函数内部使用。

这是相当抽象和微妙的，所以让我们做一些实验，看看会发生什么。

## 评估时间实验

考虑一个 *evaldemo.py* 脚本，它使用了一个类装饰器、一个描述符和一个基于`__init_subclass__`的类构建器，所有这些都定义在一个 *builderlib.py* 模块中。这些模块有几个`print`调用来显示幕后发生的事情。否则，它们不会执行任何有用的操作。这些实验的目的是观察这些`print`呼叫发生的顺序。

###### 警告

在一个类中同时应用一个类装饰器和一个带有`__init_subclass__`的类构造器可能是过度工程化或绝望的表现。这种不寻常的组合在这些实验中很有用，它显示了类装饰器和`__init_subclass__`可以应用到一个类的变化的时间。

我们先来看看 *builderlib.py* ，分成两部分:例 24-10 和例 24-11 。

##### 例 24-10。 builderlib.py:模块顶部

```
print('@ builderlib module start')classBuilder:![1](Images/1.png)print('@ Builder body')def__init_subclass__(cls):![2](Images/2.png)print(f'@ Builder.__init_subclass__({cls!r})')definner_0(self):![3](Images/3.png)print(f'@ SuperA.__init_subclass__:inner_0({self!r})')cls.method_a=inner_0def__init__(self):super().__init__()print(f'@ Builder.__init__({self!r})')defdeco(cls):![4](Images/4.png)print(f'@ deco({cls!r})')definner_1(self):![5](Images/5.png)print(f'@ deco:inner_1({self!r})')cls.method_b=inner_1returncls![6](Images/6.png)
```

![1](Images/1.png)

这是一个类生成器来实现…

![2](Images/2.png)

…一种`__init_subclass__`方法。

![3](Images/3.png)

在下面的赋值中定义一个要添加到子类的函数。

![4](Images/4.png)

班级装潢师。

![5](Images/5.png)

要添加到装饰类中的函数。

![6](Images/6.png)

返回作为参数接收的类。

继续例 24-11 中的*builder lib . py*…

##### 例 24-11。 builderlib.py:模块底部

```
classDescriptor:![1](Images/1.png)print('@ Descriptor body')def__init__(self):![2](Images/2.png)print(f'@ Descriptor.__init__({self!r})')def__set_name__(self,owner,name):![3](Images/3.png)args=(self,owner,name)print(f'@ Descriptor.__set_name__{args!r}')def__set__(self,instance,value):![4](Images/4.png)args=(self,instance,value)print(f'@ Descriptor.__set__{args!r}')def__repr__(self):return'<Descriptor instance>'print('@ builderlib module end')
```

![1](Images/1.png)

一个描述符类来演示何时…

![2](Images/2.png)

…创建一个描述符实例，当…

![3](Images/3.png)

… `__set_name__`将在`owner`类构建期间被调用。

![4](Images/4.png)

像其他方法一样，这个`__set__`除了显示它的参数之外什么也不做。

如果您在 Python 控制台中导入 *builderlib.py* ，您会得到以下结果:

```
>>> import builderlib
@ builderlib module start
@ Builder body
@ Descriptor body
@ builderlib module end
```

注意， *builderlib.py* 打印的行以`@`为前缀。

现在我们转到 *evaldemo.py* ，它会触发 *builderlib.py* 中的特殊方法(例 24-12 )。

##### 例 24-12。 evaldemo.py:用 *builderlib.py* 进行实验的脚本

```
#!/usr/bin/env python3frombuilderlibimportBuilder,deco,Descriptorprint('# evaldemo module start')@deco![1](Images/1.png)classKlass(Builder):![2](Images/2.png)print('# Klass body')attr=Descriptor()![3](Images/3.png)def__init__(self):super().__init__()print(f'# Klass.__init__({self!r})')def__repr__(self):return'<Klass instance>'defmain():![4](Images/4.png)obj=Klass()obj.method_a()obj.method_b()obj.attr=999if__name__=='__main__':main()print('# evaldemo module end')
```

![1](Images/1.png)

申请装修。

![2](Images/2.png)

子类`Builder`来触发其`__init_subclass__`。

![3](Images/3.png)

实例化描述符。

![4](Images/4.png)

只有当模块作为主程序运行时，才会调用这个函数。

*evaldemo.py* 中的`print`调用显示一个`#`前缀。如果再次打开控制台并导入 *evaldemo.py* ，例 24-13 就是输出。

##### 例 24-13。控制台实验用 *evaldemo.py*

```
>>> importevaldemo@ builderlib module start ![1](Images/1.png)@ Builder body @ Descriptor body @ builderlib module end # evaldemo module start # Klass body ![2](Images/2.png)@ Descriptor.__init__(<Descriptor instance>) ![3](Images/3.png)@ Descriptor.__set_name__(<Descriptor instance>,
 <class 'evaldemo.Klass'>, 'attr') ![4](Images/4.png)@ Builder.__init_subclass__(<class 'evaldemo.Klass'>) ![5](Images/5.png)@ deco(<class 'evaldemo.Klass'>) ![6](Images/6.png)# evaldemo module end
```

![1](Images/1.png)

上面四行是`from builderlib import…`的结果。如果您在之前的实验后没有关闭控制台，它们将不会出现，因为 *builderlib.py* 已经加载。

![2](Images/2.png)

这表明 Python 开始读取`Klass`的主体。此时，类对象还不存在。

![3](Images/3.png)

描述符实例被创建并绑定到名称空间中的`attr`，Python 将把它传递给默认的类对象构造函数:`type.__new__`。

![4](Images/4.png)

此时，Python 的内置`type.__new__`已经创建了`Klass`对象，并在提供该方法的描述符类的每个描述符实例上调用`__set_name__`，将`Klass`作为`owner`参数传递。

![5](Images/5.png)

`type.__new__`然后在`Klass`的超类上调用`__init_subclass__`，将`Klass`作为单个参数传递。

![6](Images/6.png)

当`type.__new__`返回类对象时，Python 应用装饰器。在这个例子中，`deco`返回的类被绑定到模块名称空间中的`Klass`。

`type.__new__`的实现是用 c 写的，我刚才描述的行为在 Python 的[“数据模型”](https://fpy.li/dtmodel)参考的[“创建类对象”](https://fpy.li/24-11)部分有记载。

请注意， *evaldemo.py* ( 示例 24-12 )的`main()`函数没有在控制台会话(示例 24-13 )中执行，因此没有创建`Klass`的实例。我们看到的所有动作都是由“导入时间”操作触发的:导入`builderlib`和定义`Klass`。

如果您将 *evaldemo.py* 作为脚本运行，您将看到与示例 24-13 相同的输出，只是在结尾前多了几行。多余的行是运行`main()` ( 例 24-14 )的结果。

##### 例 24-14。作为程序运行 *evaldemo.py*

```
$ ./evaldemo.py
[... 9 lines omitted ...]
@ deco(<class '__main__.Klass'>)  ![1](Images/1.png)
@ Builder.__init__(<Klass instance>)  ![2](Images/2.png)
# Klass.__init__(<Klass instance>)
@ SuperA.__init_subclass__:inner_0(<Klass instance>)  ![3](Images/3.png)
@ deco:inner_1(<Klass instance>)  ![4](Images/4.png)
@ Descriptor.__set__(<Descriptor instance>, <Klass instance>, 999)  ![5](Images/5.png)
# evaldemo module end
```

![1](Images/1.png)

前 10 行——包括这一行——与示例 24-13 中所示的相同。

![2](Images/2.png)

由`Klass.__init__`中的`super().__init__()`触发。

![3](Images/3.png)

由`main`中的`obj.method_a()`触发；`method_a`被`SuperA.__init_subclass__`注射。

![4](Images/4.png)

由`main`中的`obj.method_b()`触发；`method_b`被`deco`注射。

![5](Images/5.png)

由`main`中的`obj.attr = 999`触发。

带有`__init_subclass__`的基类和类装饰器是强大的工具，但它们仅限于使用`type.__new__`在覆盖下构建的类。在极少数情况下，当您需要调整传递给`type.__new__`的参数时，您需要一个元类。这是本章和这本书的最终目的。

# 元类 101

> [元类]是比 99%的用户应该担心的更深层次的魔法。如果你想知道你是否需要他们，你不需要(真正需要他们的人肯定知道他们需要他们，并且不需要关于为什么的解释)。
> 
> Tim Peters，Timsort 算法的发明者和多产的 Python 贡献者 ^([13](ch24.xhtml#idm46582366318608))

一个 元类是一个类工厂。与例 24-2 中的`record_factory`相比，元类被写成一个类。换句话说，元类是一个类，它的实例是类。图 24-1 描述了一个使用 Mills & Gizmos 符号的元类:一个 mill 生产另一个 mill。

![MGN diagrams with metaclass and class.](Images/flpy_2401.png)

###### 图 24-1。元类是构建类的类。

考虑 Python 对象模型:类是对象，因此每个类都必须是某个其他类的实例。默认情况下，Python 类是`type`的实例。换句话说，`type`是大多数内置和用户自定义类的元类:

```
>>> str.__class__
<class 'type'>
>>> from bulkfood_v5 import LineItem
>>> LineItem.__class__
<class 'type'>
>>> type.__class__
<class 'type'>
```

为了避免无限倒退，`type`的类是`type`，如最后一行所示。

注意，我并不是说`str`或`LineItem`是`type`的子类。我说的是`str`和`LineItem`是`type`的实例。它们都是`object`的子类。图 24-2 可能会帮助你面对这个奇怪的现实。

![UML class diagrams with `object` and `type` relationships.](Images/flpy_2402.png)

###### 图 24-2。两张图都是真的。左边的强调`str`、`type`、`LineItem`是 object 的子类。右边的说明`str`、`object`、`LineItem`是实例`type`，因为都是类。

###### 注意

类`object`和`type`有唯一的关系:`object`是`type`的实例，`type`是`object`的子类。这种关系是“神奇的”:它不能用 Python 来表达，因为在定义另一个类之前，任何一个类都必须存在。`type`本身就是一个实例的事实也很神奇。

接下来的片段显示了`collections.Iterable`的类是`abc.ABCMeta`。注意`Iterable`是一个抽象类，但是`ABCMeta`是一个具体类——毕竟`Iterable`是`ABCMeta`的一个实例:

```
>>> from collections.abc import Iterable
>>> Iterable.__class__
<class 'abc.ABCMeta'>
>>> import abc
>>> from abc import ABCMeta
>>> ABCMeta.__class__
<class 'type'>
```

最终，`ABCMeta`的类也是`type`。每个类都是`type`的实例，直接或间接，但只有元类也是`type`的子类。这是理解元类最重要的关系:元类，比如`ABCMeta`，继承了`type`构造类的能力。图 24-3 说明了这种至关重要的关系。

![UML class diagrams with `Iterable` and `ABCMeta` relationships.](Images/flpy_2403.png)

###### 图 24-3。 `Iterable`是`object`的子类，是`ABCMeta`的实例。`object`和`ABCMeta`都是 type 的实例，但是这里的关键关系是`ABCMeta`也是`type`的子类，因为`ABCMeta`是元类。在这个图中，`Iterable`是唯一的抽象类。

这里重要的一点是，元类是`type`的子类，这使得它们像类工厂一样工作。一个元类可以通过实现特殊的方法来定制它的实例，如下面几节所示。

## 元类如何定制一个类

为了使用元类，理解`__new__`如何在任何类上工作是很关键的。这在[“使用 __new__”的灵活对象创建](ch22.xhtml#flexible_new_sec)中讨论过。

当一个元类将要创建一个新的实例(即一个类)时，同样的机制发生在“元”级别。请考虑以下声明:

```
class Klass(SuperKlass, metaclass=MetaKlass):
    x = 42
    def __init__(self, y):
        self.y = y
```

为了处理那个`class`语句，Python 用这些参数调用`MetaKlass.__new__`:

`meta_cls`

元类本身(`MetaKlass`)，因为`__new__`作为类方法工作。

`cls_name`

琴弦`Klass`。

`bases`

单元素元组`(SuperKlass,)`，多重继承情况下元素较多。

`cls_dict`

像这样的映射:

```
{x: 42, `__init__`: <function __init__ at 0x1009c4040>}
```

当您实现`MetaKlass.__new__`时，您可以在将这些参数传递给`super().__new__`之前检查并更改它们，最终`super().__new__`将调用`type.__new__`来创建新的类对象。

在`super().__new__`返回之后，您还可以对新创建的类进行进一步的处理，然后将其返回给 Python。Python 然后调用`SuperKlass.__init_subclass__`，传递您创建的类，然后对它应用一个类装饰器(如果有的话)。最后，Python 将类对象绑定到它在周围名称空间中的名称——如果`class`语句是顶级语句，通常是模块的全局名称空间。

元类`__new__`中最常见的处理是添加或替换`cls_dict`中的项目，这是表示正在构建的类的名称空间的映射。例如，在调用`super().__new__`之前，你可以通过给`cls_dict`添加函数，在正在构建的类中注入方法。然而，请注意，添加方法也可以在类构建之后完成，这就是为什么我们能够使用`__init_subclass__`或类装饰器来完成。

在`type.__new__`运行之前，您必须添加到`cls_dict`的一个属性是`__slots__`，正如“为什么 __init_subclass__ 不能配置 _ _ slots _ _”中所讨论的。元类的`__new__`方法是配置`__slots__`的理想地方。下一节将展示如何做到这一点。

## 一个很好的元类例子

这里介绍的 `MetaBunch`元类是第三版 [*Python 概要*第四章最后一个例子的变体。由 Alex Martelli、Anna Ravenscroft 和 Steve Holden 编写的用于运行 Python 2.7 和 3.5 的程序。](https://fpy.li/pynut3)[14](ch24.xhtml#idm46582366098400) 假设 Python 3.6 或更高版本，我能够进一步简化代码。

首先，让我们看看`Bunch`基类提供了什么:

```
 >>> class Point(Bunch):
 ...     x = 0.0
 ...     y = 0.0
 ...     color = 'gray'
 ...
 >>> Point(x=1.2, y=3, color='green')
 Point(x=1.2, y=3, color='green')
 >>> p = Point()
 >>> p.x, p.y, p.color
 (0.0, 0.0, 'gray')
 >>> p
 Point()
```

记住`Checked`根据类变量类型提示为子类中的`Field`描述符指定名称，因为它们没有值，所以实际上不会成为类的属性。

`Bunch`另一方面，子类使用带有值的实际类属性，然后这些值成为实例属性的默认值。生成的`__repr__`省略了等于默认值的属性的参数。

`MetaBunch`—`Bunch`的元类——根据用户类中声明的类属性为新类生成`__slots__`。这阻止了未声明属性的实例化和以后的赋值:

```
 >>> Point(x=1, y=2, z=3)
 Traceback (most recent call last):
 ...
 AttributeError: No slots left for: 'z'
 >>> p = Point(x=21)
 >>> p.y = 42
 >>> p
 Point(x=21, y=42)
 >>> p.flavor = 'banana'
 Traceback (most recent call last):
 ...
 AttributeError: 'Point' object has no attribute 'flavor'
```

现在让我们深入研究示例 24-15 中`MetaBunch`的优雅代码。

##### 例 24-15。meta bunch/from 3.6/bunch . py:`MetaBunch`元类和`Bunch`类

```
classMetaBunch(type):![1](Images/1.png)def__new__(meta_cls,cls_name,bases,cls_dict):![2](Images/2.png)defaults={}![3](Images/3.png)def__init__(self,**kwargs):![4](Images/4.png)forname,defaultindefaults.items():![5](Images/5.png)setattr(self,name,kwargs.pop(name,default))ifkwargs:![6](Images/6.png)extra=', '.join(kwargs)raiseAttributeError(f'No slots left for: {extra!r}')def__repr__(self):![7](Images/7.png)rep=', '.join(f'{name}={value!r}'forname,defaultindefaults.items()if(value:=getattr(self,name))!=default)returnf'{cls_name}({rep})'new_dict=dict(__slots__=[],__init__=__init__,__repr__=__repr__)![8](Images/8.png)forname,valueincls_dict.items():![9](Images/9.png)ifname.startswith('__')andname.endswith('__'):![10](Images/10.png)ifnameinnew_dict:raiseAttributeError(f"Can't set {name!r} in {cls_name!r}")new_dict[name]=valueelse:![11](Images/11.png)new_dict['__slots__'].append(name)defaults[name]=valuereturnsuper().__new__(meta_cls,cls_name,bases,new_dict)![12](Images/12.png)classBunch(metaclass=MetaBunch):![13](Images/13.png)pass
```

![1](Images/1.png)

要创建一个新的元类，从`type`继承。

![2](Images/2.png)

`__new__`作为一个类方法工作，但是该类是一个元类，所以我喜欢将第一个参数命名为`meta_cls` ( `mcs`是一个常见的替代)。剩下的三个参数与直接调用`type()`创建类的三参数签名相同。

![3](Images/3.png)

`defaults`将保存属性名及其默认值的映射。

![4](Images/4.png)

这将被注入到新类中。

![5](Images/5.png)

读取`defaults`并用从`kwargs`弹出的值或默认值设置相应的实例属性。

![6](Images/6.png)

如果`kwargs`中还有任何物品，这意味着没有我们可以放置它们的位置了。我们相信*快速失败*是最佳实践，所以我们不想默默忽略额外的项目。一个快速有效的解决方案是从`kwargs`弹出一个项目，并尝试将其设置在实例上，故意触发一个`AttributeError`。

![7](Images/7.png)

`__repr__`返回一个类似构造函数调用的字符串，例如`Point(x=3)`，省略了带有默认值的关键字参数。

![8](Images/8.png)

初始化新类的命名空间。

![9](Images/9.png)

迭代用户类的命名空间。

![10](Images/10.png)

如果找到一个 dunder `name`，将该项复制到新的类名称空间，除非它已经存在。这可以防止用户覆盖 Python 设置的`__init__`、`__repr__`和其他属性，比如`__qualname__`和`__module__`。

![11](Images/11.png)

如果不是一个数据`name`，追加到`__slots__`并将它的`value`保存在`defaults`中。

![12](Images/12.png)

构建并返回新类。

![13](Images/13.png)

提供一个基类，用户就不需要看到`MetaBunch`。

`MetaBunch`工作是因为它能够在调用`super().__new__`构建最终类之前配置`__slots__`。通常在元编程时，理解动作的顺序是关键。让我们做另一个评估时间实验，现在用一个元类。

## 元类评估时间实验

这个是“评估时间实验”的变体，添加了一个元类。 *builderlib.py* 模块和之前一样，但是主脚本现在是 *evaldemo_meta.py* ，列在示例 24-16 中。

##### 例 24-16。 evaldemo_meta.py:尝试元类

```
#!/usr/bin/env python3frombuilderlibimportBuilder,deco,DescriptorfrommetalibimportMetaKlass![1](Images/1.png)print('# evaldemo_meta module start')@decoclassKlass(Builder,metaclass=MetaKlass):![2](Images/2.png)print('# Klass body')attr=Descriptor()def__init__(self):super().__init__()print(f'# Klass.__init__({self!r})')def__repr__(self):return'<Klass instance>'defmain():obj=Klass()obj.method_a()obj.method_b()obj.method_c()![3](Images/3.png)obj.attr=999if__name__=='__main__':main()print('# evaldemo_meta module end')
```

![1](Images/1.png)

从 *metalib.py* 导入`MetaKlass`，我们将在示例 24-18 中看到。

![2](Images/2.png)

将`Klass`声明为`Builder`的子类和`MetaKlass`的实例。

![3](Images/3.png)

这个方法是由`MetaKlass.__new__`注入的，我们会看到。

###### 警告

为了科学起见，例 24-16 无视一切理由，在`Klass`上应用了三种不同的元编程技术:装饰器、使用`__init_subclass__`的基类和自定义元类。如果你在生产代码中这样做，请不要怪我。同样，目标是观察这三种技术在类构造过程中的干扰顺序。

和前面的评估时间实验一样，这个例子除了显示执行流的消息之外什么也不做。例 24-17 显示了 *metalib.py* 顶部的代码——其余部分在例 24-18 中。

##### 例 24-17。metalib . py:`NosyDict`类

```
print('% metalib module start')

import collections

class NosyDict(collections.UserDict):
    def __setitem__(self, key, value):
        args = (self, key, value)
        print(f'% NosyDict.__setitem__{args!r}')
        super().__setitem__(key, value)

    def __repr__(self):
        return '<NosyDict instance>'
```

我编写了`NosyDict`类来覆盖`__setitem__`以显示每个设置的`key`和`value`。元类将使用一个`NosyDict`实例来保存正在构建的类的名称空间，揭示更多 Python 的内部工作方式。

*metalib.py* 的主要吸引力在于例 24-18 中的元类。它实现了`__prepare__`特殊方法，这是一个 Python 只在元类上调用的类方法。方法提供了最早的机会来影响创建新类的过程。

###### 小费

在编写元类时，我发现对特殊的方法参数采用这种命名约定很有用:

*   对于实例方法，使用`cls`而不是`self`，因为实例是一个类。

*   对类方法使用`meta_cls`而不是`cls`，因为该类是元类。回想一下，即使没有`@classmethod`装饰器，`__new__`的行为也像一个类方法。

##### 例 24-18。metalib . py:`MetaKlass`

```
classMetaKlass(type):print('% MetaKlass body')@classmethod![1](Images/1.png)def__prepare__(meta_cls,cls_name,bases):![2](Images/2.png)args=(meta_cls,cls_name,bases)print(f'% MetaKlass.__prepare__{args!r}')returnNosyDict()![3](Images/3.png)def__new__(meta_cls,cls_name,bases,cls_dict):![4](Images/4.png)args=(meta_cls,cls_name,bases,cls_dict)print(f'% MetaKlass.__new__{args!r}')definner_2(self):print(f'% MetaKlass.__new__:inner_2({self!r})')cls=super().__new__(meta_cls,cls_name,bases,cls_dict.data)![5](Images/5.png)cls.method_c=inner_2![6](Images/6.png)returncls![7](Images/7.png)def__repr__(cls):![8](Images/8.png)cls_name=cls.__name__returnf"<class {cls_name!r} built by MetaKlass>"print('% metalib module end')
```

![1](Images/1.png)

`__prepare__`应该声明为类方法。它不是一个实例方法，因为当 Python 调用 `__prepare__`时，正在构造的类还不存在。

![2](Images/2.png)

Python 调用元类上的`__prepare__`来获得一个映射，以保存正在构造的类的名称空间。

![3](Images/3.png)

返回用作名称空间的`NosyDict`实例。

![4](Images/4.png)

`cls_dict`是由`__prepare__`返回的`NosyDict`实例。

![5](Images/5.png)

`type.__new__`需要一个实的`dict`作为最后一个实参，所以我给它赋予了`NosyDict`的`data`属性，继承自`UserDict`。

![6](Images/6.png)

在新创建的类中注入一个方法。

![7](Images/7.png)

像往常一样，`__new__`必须返回刚刚创建的对象——在本例中，是新的类。

![8](Images/8.png)

在元类上定义`__repr__`允许定制类对象的`repr()`。

在 Python 3.6 之前，`__prepare__`的主要用例是提供一个`OrderedDict`来保存正在构建的类的属性，这样元类`__new__`就可以按照这些属性在用户类定义的源代码中出现的顺序来处理它们。既然`dict`保留了插入顺序，就很少需要`__prepare__`。在“使用 __prepare__”的元类 Hack中，您会看到它的一种创造性用法。

在 Python 控制台中导入 *metalib.py* 不是很刺激。注意使用`%`作为该模块输出行的前缀:

```
>>> import metalib
% metalib module start
% MetaKlass body
% metalib module end
```

如果您导入 *evaldemo_meta.py* ，会发生很多事情，正如您在示例 24-19 中看到的。

##### 例 24-19。控制台实验用 *evaldemo_meta.py*

```
>>> importevaldemo_meta@ builderlib module start @ Builder body @ Descriptor body @ builderlib module end % metalib module start % MetaKlass body % metalib module end # evaldemo_meta module start ![1](Images/1.png)% MetaKlass.__prepare__(<class 'metalib.MetaKlass'>, 'Klass', ![2](Images/2.png) (<class 'builderlib.Builder'>,)) % NosyDict.__setitem__(<NosyDict instance>, '__module__', 'evaldemo_meta') ![3](Images/3.png)% NosyDict.__setitem__(<NosyDict instance>, '__qualname__', 'Klass') # Klass body @ Descriptor.__init__(<Descriptor instance>) ![4](Images/4.png)% NosyDict.__setitem__(<NosyDict instance>, 'attr', <Descriptor instance>) ![5](Images/5.png)% NosyDict.__setitem__(<NosyDict instance>, '__init__',
 <function Klass.__init__ at …>) ![6](Images/6.png)% NosyDict.__setitem__(<NosyDict instance>, '__repr__',
 <function Klass.__repr__ at …>) % NosyDict.__setitem__(<NosyDict instance>, '__classcell__', <cell at …: empty>) % MetaKlass.__new__(<class 'metalib.MetaKlass'>, 'Klass',
 (<class 'builderlib.Builder'>,), <NosyDict instance>) ![7](Images/7.png)@ Descriptor.__set_name__(<Descriptor instance>,
 <class 'Klass' built by MetaKlass>, 'attr') ![8](Images/8.png)@ Builder.__init_subclass__(<class 'Klass' built by MetaKlass>) @ deco(<class 'Klass' built by MetaKlass>) # evaldemo_meta module end
```

![1](Images/1.png)

这之前的几行是导入 *builderlib.py* 和 *metalib.py* 的结果。

![2](Images/2.png)

Python 调用`__prepare__`开始处理`class`语句。

![3](Images/3.png)

在解析类体之前，Python 将`__module__`和`__qualname__`条目添加到正在构造的类的名称空间中。

![4](Images/4.png)

描述符实例已创建…

![5](Images/5.png)

…并绑定到类名称空间中的`attr`。

![6](Images/6.png)

`__init__`和`__repr__`方法被定义并添加到名称空间中。

![7](Images/7.png)

一旦 Python 处理完类体，它就调用`MetaKlass.__new__`。

![8](Images/8.png)

在元类的`__new__`方法返回新构造的类之后，依次调用`__set_name__`、`__init_subclass__`和装饰器。

如果你运行 *evaldemo_meta.py* 作为脚本，`main()`被调用，还有几件事情发生 ( 例 24-20 )。

##### 例 24-20。作为程序运行 *evaldemo_meta.py*

```
$ ./evaldemo_meta.py
[... 20 lines omitted ...]
@ deco(<class 'Klass' built by MetaKlass>)  ![1](Images/1.png)
@ Builder.__init__(<Klass instance>)
# Klass.__init__(<Klass instance>)
@ SuperA.__init_subclass__:inner_0(<Klass instance>)
@ deco:inner_1(<Klass instance>)
% MetaKlass.__new__:inner_2(<Klass instance>)  ![2](Images/2.png)
@ Descriptor.__set__(<Descriptor instance>, <Klass instance>, 999)
# evaldemo_meta module end
```

![1](Images/1.png)

包括这一行在内的前 21 行与示例 24-19 中显示的相同。

![2](Images/2.png)

由`main`中的`obj.method_c()`触发；`method_c`被`MetaKlass.__new__`注射。

现在让我们回到用`Field`描述符实现运行时类型验证的`Checked`类的想法，看看如何用元类实现它。

# 检查的元类解决方案

我 不想鼓励过早的优化和过度的工程化，所以这里有一个虚构的场景来证明用`__slots__`重写 *checkedlib.py* ，这需要应用一个元类。随意略过。

我们接下来要研究的*元类/checkedlib.py* 模块是对 *initsub/checkedlib.py* 的替代。嵌入其中的 doctests 是相同的，同样的还有用于 *pytest* 的 *checkedlib_test.py* 文件。

*checkedlib.py* 中的复杂性对用户来说是抽象的。以下是使用该包的脚本的源代码:

```
from checkedlib import Checked

class Movie(Checked):
    title: str
    year: int
    box_office: float

if __name__ == '__main__':
    movie = Movie(title='The Godfather', year=1972, box_office=137)
    print(movie)
    print(movie.title)
```

这个简洁的`Movie`类定义利用了三个`Field`验证描述符的实例、一个`__slots__`配置、五个从`Checked`继承的方法和一个元类来把它们放在一起。`checkedlib`唯一可见的部分是`Checked`基类。

考虑图 24-4 。Mills & Gizmos 符号通过使类和实例之间的关系更加可见来补充 UML 类图。

例如，使用新的 *checkedlib.py* 的`Movie`类是`CheckedMeta`的实例，也是`Checked`的子类。另外，`Movie`的`title`、`year`和`box_office`类属性是`Field`的三个独立实例。每个`Movie`实例都有自己的`_title`、`_year`和`_box_office`属性，用来存储相应字段的值。

现在让我们研究代码，从`Field`类开始，如示例 24-21 所示。

描述符类现在有点不同。在前面的例子中，每个`Field`描述符实例使用同名的属性将其值存储在托管实例中。例如，在`Movie`类中，`title`描述符将字段值存储在托管实例的`title`属性中。这使得`Field`没有必要提供`__get__`方法。

但是像`Movie`这样的类使用`__slots__`时，不能有同名的类属性和实例属性。每个描述符实例都是一个类属性，现在我们需要单独的每个实例的存储属性。代码使用以单个`_`为前缀的描述符名称。因此`Field`实例有单独的`name`和`storage_name`属性，我们实现`Field.__get__`。

![UML+MGN class diagram for `CheckedMeta`, `Movie` etc.](Images/flpy_2404.png)

###### 图 24-4。用 MGN 标注的 UML 类图:`CheckedMeta`元工厂构建`Movie`工厂。`Field` mill 构建`title`、`year`和`box_office`描述符，它们是`Movie`的类属性。字段的每个实例的数据存储在`Movie`的`_title`、`_year`和`_box_office`实例属性中。注意`checkedlib`的封装边界。`Movie`的开发者不需要搜索 *checkedlib.py* 里面的所有机器。

示例 24-21 显示了`Field`的源代码，标注仅描述了该版本中的变更。

##### 例 24-21。元类/checkedlib.py:带有`storage_name`和`__get__`的`Field`描述符

```
classField:def__init__(self,name:str,constructor:Callable)->None:ifnotcallable(constructor)orconstructoristype(None):raiseTypeError(f'{name!r} type hint must be callable')self.name=nameself.storage_name='_'+name![1](Images/1.png)self.constructor=constructordef__get__(self,instance,owner=None):ifinstanceisNone:![2](Images/2.png)returnselfreturngetattr(instance,self.storage_name)![3](Images/3.png)def__set__(self,instance:Any,value:Any)->None:ifvalueis...:value=self.constructor()else:try:value=self.constructor(value)except(TypeError,ValueError)ase:type_name=self.constructor.__name__msg=f'{value!r} is not compatible with {self.name}:{type_name}'raiseTypeError(msg)fromesetattr(instance,self.storage_name,value)![4](Images/4.png)
```

![1](Images/1.png)

根据`name`参数计算`storage_name`。

![2](Images/2.png)

如果`__get__`将`None`作为`instance`参数，那么描述符是从托管类本身读取的，而不是从托管实例读取的。所以我们返回描述符。

![3](Images/3.png)

否则，返回存储在名为`storage_name`的属性中的值。

![4](Images/4.png)

`__set__`现在使用`setattr`来设置或更新被管理的属性。

例 24-22 显示了驱动这个例子的元类的代码。

##### 例 24-22。元类/checked lib . py:`CheckedMeta`元类

```
classCheckedMeta(type):def__new__(meta_cls,cls_name,bases,cls_dict):![1](Images/1.png)if'__slots__'notincls_dict:![2](Images/2.png)slots=[]type_hints=cls_dict.get('__annotations__',{})![3](Images/3.png)forname,constructorintype_hints.items():![4](Images/4.png)field=Field(name,constructor)![5](Images/5.png)cls_dict[name]=field![6](Images/6.png)slots.append(field.storage_name)![7](Images/7.png)cls_dict['__slots__']=slots![8](Images/8.png)returnsuper().__new__(meta_cls,cls_name,bases,cls_dict)![9](Images/9.png)
```

![1](Images/1.png)

`__new__`是`CheckedMeta`中唯一实现的方法。

![2](Images/2.png)

只有当它的`cls_dict`不包括`__slots__`时才增强这个类。如果`__slots__`已经存在，假设它是`Checked`基类而不是用户定义的子类，并按原样构建该类。

![3](Images/3.png)

在前面的例子中，为了得到类型提示，我们使用了`typing.get_type_hints`，但是这需要一个现有的类作为第一个参数。此时，我们正在配置的类还不存在，所以我们需要直接从`cls_dict`中检索`__annotations__`——正在构建的类的名称空间，Python 将它作为最后一个参数传递给元类`__new__`。

![4](Images/4.png)

迭代`type_hints`到…

![5](Images/5.png)

…为每个带注释的属性构建一个`Field`…

![6](Images/6.png)

…用`Field`实例覆盖`cls_dict`中的相应条目…

![7](Images/7.png)

…并在列表中添加字段的`storage_name`,我们将使用它…

![8](Images/8.png)

…填充`cls_dict`中的`__slots__`条目—正在构建的类的名称空间。

![9](Images/9.png)

最后我们叫`super().__new__`。

*元类/checkedlib.py* 的最后一部分是`Checked`基类，这个库的用户将继承它来增强他们的类，就像`Movie`。

此版本`Checked`的代码与 *initsub/checkedlib.py* 中的`Checked`相同(列于例 24-5 和例 24-6 )，有三处变化:

1.  增加了一个空的`__slots__`来通知`CheckedMeta.__new__`这个类不需要特殊处理。

2.  移除了`__init_subclass__`。它的工作现在由`CheckedMeta.__new__`完成。

3.  移除了`__setattr__`。它变得多余，因为将`__slots__`添加到用户定义的类可以防止设置未声明的属性。

示例 24-23 是`Checked`最终版本的完整列表。

##### 例 24-23。元类/checked lib . py:`Checked`基类

```
class Checked(metaclass=CheckedMeta):
    __slots__ = ()  # skip CheckedMeta.__new__ processing

    @classmethod
    def _fields(cls) -> dict[str, type]:
        return get_type_hints(cls)

    def __init__(self, **kwargs: Any) -> None:
        for name in self._fields():
            value = kwargs.pop(name, ...)
            setattr(self, name, value)
        if kwargs:
            self.__flag_unknown_attrs(*kwargs)

    def __flag_unknown_attrs(self, *names: str) -> NoReturn:
        plural = 's' if len(names) > 1 else ''
        extra = ', '.join(f'{name!r}' for name in names)
        cls_name = repr(self.__class__.__name__)
        raise AttributeError(f'{cls_name} object has no attribute{plural} {extra}')

    def _asdict(self) -> dict[str, Any]:
        return {
            name: getattr(self, name)
            for name, attr in self.__class__.__dict__.items()
            if isinstance(attr, Field)
        }

    def __repr__(self) -> str:
        kwargs = ', '.join(
            f'{key}={value!r}' for key, value in self._asdict().items()
        )
        return f'{self.__class__.__name__}({kwargs})'
```

这就结束了带有经验证的描述符的类构建器的第三次呈现。

下一节将讨论一些与元类相关的一般性问题。

# 真实世界中的元类

元类 很强大，但是很棘手。在决定实现元类之前，请考虑以下几点。

## 现代特性简化或取代了元类

随着时间的推移，新的语言特性使得元类的一些常见用例变得多余:

Class decorators

比元类更容易理解，并且不太可能引起基类和元类的冲突。

`__set_name__`

不需要自定义元类逻辑来自动设置描述符的名称。 ^([15](ch24.xhtml#idm46582364050896))

`__init_subclass__`

提供了一种定制类创建的方法，这种方法对最终用户是透明的，甚至比装饰器更简单，但是可能会在复杂的类层次结构中引入冲突。

Built-in `dict` preserving key insertion order

消除了使用`__prepare__`的首要原因:提供一个`OrderedDict`来存储正在构造的类的名称空间。Python 只在元类上调用`__prepare__`，所以如果你需要按照类名称空间在源代码中出现的顺序来处理它，你必须在 Python 3.6 之前使用元类。

截至 2021 年，每一个积极维护的 CPython 版本都支持刚才列出的所有特性。

我一直提倡这些特性，因为我在我们的职业中看到了太多不必要的复杂性，而元类是通向复杂性的大门。

## 元类是稳定的语言特性

元类是在 2002 年 Python 2.2 中引入的，还有所谓的“新型类”、描述符和属性。

值得注意的是，Alex Martelli 在 2002 年 7 月首次发布的`MetaBunch`示例在 Python 3.9 中仍然有效——唯一的变化是指定要使用的元类的方式，这在 Python 3 中是通过语法`class Bunch(metaclass=MetaBunch):`完成的。

我在“现代特性简化或替换元类”中提到的所有添加都没有破坏使用元类的现有代码。但是使用元类的遗留代码通常可以通过利用这些特性来简化，特别是如果您可以放弃对 3.6 之前的 Python 版本的支持——这些版本不再保留。

## 一个类只能有一个元类

如果您的类声明涉及两个或更多元类，您将看到这个令人困惑的错误消息:

```
TypeError: metaclass conflict: the metaclass of a derived class
must be a (non-strict) subclass of the metaclasses of all its bases
```

即使没有多重继承，这种情况也可能发生。例如，像这样的声明可以触发`TypeError`:

```
class Record(abc.ABC, metaclass=PersistentMeta):
    pass
```

我们看到`abc.ABC`是`abc.ABCMeta`元类的一个实例。如果`Persistent`元类本身不是`abc.ABCMeta`的子类，那么就会出现元类冲突。

有两种方法可以处理这个错误:

*   找到一些其他的方法来做你需要做的事情，同时避免至少一个相关的元类。

*   使用多重继承编写自己的`PersistentABCMeta`元类作为`abc.ABCMeta`和`PersistentMeta`的子类，并将其作为`Record`的唯一元类。 ^([16](ch24.xhtml#idm46582363814688))

###### 小费

我可以想象用两个基本元类实现元类来满足最后期限的解决方案。根据我的经验，元类编程总是比预期花费更长的时间，这使得这种方法在严格的截止日期之前很危险。如果你这样做，并在最后期限前完成，代码可能会包含一些细微的错误。即使没有已知的错误，您也应该将这种方法视为技术债务，因为它很难理解和维护。

## 元类应该是实现细节

除了`type`，整个 Python 3.9 标准库中只有 6 个元类。更著名的元类可能是`abc.ABCMeta`、`typing.NamedTupleMeta`和`enum.EnumMeta`。它们都不打算在用户代码中显式出现。我们可以考虑它们的实现细节。

虽然你可以用元类做一些非常古怪的元编程，但是最好注意最小惊讶原则，这样大多数用户就可以把元类当作实现细节。 ^([17](ch24.xhtml#idm46582363807680))

近年来，Python 标准库中的一些元类被其他机制所取代，而没有破坏其包的公共 API。让这样的 API 经得起未来考验的最简单的方法是提供一个常规类，用户可以将它子类化以访问元类提供的功能，正如我们在示例中所做的那样。

作为对类元编程的总结，我将和你分享我在研究这一章时发现的最酷的元类的小例子。

# 使用 __prepare__ 的元类攻击

当 我为第二版更新这一章时，我需要找到简单但有启发性的例子来替换从 Python 3.6 开始不再需要元类的 *bulkfood* `LineItem`代码。

joo s . o . Bueno 给了我一个最简单也是最有趣的元类想法，他在巴西 Python 社区中更为人所知的名字是 JS。他的想法的一个应用是创建一个自动生成数字常量的类:

```
    >>> class Flavor(AutoConst):
    ...     banana
    ...     coconut
    ...     vanilla
    ...
    >>> Flavor.vanilla
    2
    >>> Flavor.banana, Flavor.coconut
    (0, 1)
```

是的，代码的工作方式如图所示！那实际上是 *autoconst_demo.py* 中的一个 doctest。

下面是用户友好的`AutoConst`基类及其背后的元类，在 *autoconst.py* 中实现:

```
class AutoConstMeta(type):
    def __prepare__(name, bases, **kwargs):
        return WilyDict()

class AutoConst(metaclass=AutoConstMeta):
    pass
```

就是这样。

明明诀窍在`WilyDict`。

当 Python 处理用户类的名称空间并读取`banana`时，它会在`__prepare__`提供的映射中查找该名称:`WilyDict`的一个实例。`WilyDict`实现了`__missing__`，涵盖在[【遗漏 __ 方法】](ch03.xhtml#missing_method)中。`WilyDict`实例最初没有`'banana'`键，所以`__missing__`方法被触发。它用键`'banana'`和值`0`动态生成一个项目，并返回该值。Python 对此很满意，然后尝试检索`'coconut'`。`WilyDict`立即添加带有值`1`的条目，并返回它。同样的情况发生在`'vanilla'`上，然后映射到`2`。

我们之前见过`__prepare__`和`__missing__`。真正的创新是 JS 如何把它们放在一起。

下面是`WilyDict`的源代码，同样来自 *autoconst.py* :

```
class WilyDict(dict):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.__next_value = 0

    def __missing__(self, key):
        if key.startswith('__') and key.endswith('__'):
            raise KeyError(key)
        self[key] = value = self.__next_value
        self.__next_value += 1
        return value
```

在做实验的时候，我发现 Python 在正在构建的类的名称空间中查找`__name__`，导致`WilyDict`增加一个`__name__`条目，并递增`__next_value`。所以我在`__missing__`中添加了那个`if`语句，为看起来像 dunder 属性的键增加了`KeyError`。

*autoconst.py* 包既要求又说明了对 Python 动态类构建机制的掌握。

我很高兴给`AutoConstMeta`和`AutoConst`增加了更多的功能，但是我不会分享我的实验，我会让你在玩 JS 巧妙的黑客游戏中得到乐趣。

以下是一些想法:

*   如果有值，就可以检索常量名。例如，`Flavor[2]`可能会返回`'vanilla'`。您可以通过在`AutoConstMeta`中实现`__getitem__`来实现这一点。从 Python 3.9 开始，可以在`AutoConst`本身实现 [`__class_getitem__`](https://fpy.li/24-16) 。

*   通过在元类上实现`__iter__`，支持类的迭代。我会让`__iter__`产生常量对`(name, value)`。

*   实施新的`Enum`变体。这将是一项艰巨的任务，因为`enum`包充满了技巧，包括包含数百行代码的`EnumMeta`元类和一个重要的`__prepare__`方法。

尽情享受吧！

###### 注意

Python 3.9 中添加了`__class_getitem__`特殊方法来支持泛型类型，作为 [PEP 585 的一部分——标准集合中的类型提示泛型](https://fpy.li/pep585)。感谢`__class_getitem__`，Python 的核心开发人员不必为内置类型编写新的元类来实现`__getitem__`，这样我们就可以编写类似`list[int]`的泛型类型提示。这是一个狭窄的特性，但是代表了元类的一个更广泛的用例:实现操作符和其他特殊方法在类级别工作，比如使类本身可迭代，就像`Enum`子类一样。

# 包扎

元类，如 以及类装饰符和`__init_subclass__`对以下方面很有用:

*   子类注册

*   子类结构验证

*   一次对许多方法应用装饰器

*   对象序列化

*   对象关系映射

*   基于对象的持久性

*   在类级别实现特殊方法

*   实现其他语言中的类特性，例如 [traits](https://fpy.li/24-17) 和[面向方面编程](https://fpy.li/24-18)

在某些情况下，类元编程还可以通过在导入时执行任务来帮助解决性能问题，否则这些任务会在运行时重复执行。

最后，让我们回忆一下亚历克斯·马尔泰利在他的文章[“水鸟和 ABC”](ch13.xhtml#waterfowl_essay)中给出的最后建议:

> 并且，*不要*在产品代码中定义自定义 ABC(或元类)……如果你有这样做的冲动，我敢打赌，这很可能是“所有问题看起来都像钉子”的一种情况——对于刚刚得到一把闪亮的新锤子的人来说——你(和你代码的未来维护者)会更乐意坚持简单明了的代码，避开这样的深度。

我相信 Martelli 的建议不仅适用于 ABC 和元类，还适用于类层次结构、运算符重载、函数装饰器、描述符、类装饰器以及使用`__init_subclass__`的类构造器。

这些强大的工具主要用于支持库和框架开发。应用自然应该*使用那些工具，就像 Python 标准库或外部包所提供的那样。但是在应用程序代码中实现它们通常是不成熟的抽象。*

> 好的框架是提取出来的，而不是发明出来的。 ^([18](ch24.xhtml#idm46582363498656))
> 
> David Heinemeier Hansson，Ruby on Rails 的创造者

# 章节摘要

本章从类对象中的属性概述开始，比如`__qualname__`和`__subclasses__()`方法。接下来，我们看到了如何在运行时使用内置的`type`来构造类。

引入了`__init_subclass__`特殊方法，第一次迭代的`Checked`基类被设计为用`Field`实例替换用户定义子类中的属性类型提示，这些实例应用构造函数在运行时强制这些属性的类型。

同样的想法用一个`@checked`类装饰器实现，它向用户定义的类添加特性，类似于`__init_subclass__`所允许的。我们看到`__init_subclass__`和类装饰器都不能动态配置`__slots__`，因为它们只在类被创建后才运行。

通过实验阐明了“导入时间”和“运行时间”的概念，实验显示了当涉及模块、描述符、类装饰符和`__init_subclass__`时 Python 代码的执行顺序。

我们对元类的介绍从对作为元类的`type`的总体解释开始，以及用户定义的元类如何实现`__new__`来定制它构建的类。然后我们看到了我们的第一个定制元类，使用`__slots__`的经典`MetaBunch`例子。接下来，另一个评估时间实验演示了元类的`__prepare__`和`__new__`方法是如何比`__init_subclass__`和类装饰器更早被调用的，这为更深层次的类定制提供了机会。

展示了带有`Field`描述符和自定义`__slots__`配置的`Checked`类构建器的第三次迭代，随后是关于实践中元类使用的一些一般考虑。

最后，我们看到了 joo s . o . Bueno 发明的`AutoConst` hack，它基于一个元类的巧妙想法，用`__prepare__`返回一个实现`__missing__`的映射。在不到 20 行代码中， *autoconst.py* 展示了结合 Python 元编程技术的威力

我还没有找到一种语言能像 Python 一样，对初学者来说容易，对专业人员来说实用，对黑客来说令人兴奋。谢谢吉多·范·罗苏姆和所有为此做出贡献的人。

# 进一步阅读

Caleb hatting h——本书的技术评论员——编写了 [*autoslot*](https://fpy.li/24-20) 包，通过检查`__init__`的字节码并找到`self`属性的所有赋值，提供了一个元类来自动在用户定义的类中创建`__slots__`属性。这很有用，也是一个很好的学习例子:只有 *autoslot.py* 中的 74 行代码，包括解释最难部分的 20 行注释。

Python 文档中这一章的基本参考是[“3 . 3 . 3。定制类创建](https://fpy.li/24-21)在*的“数据模型”一章中，Python 语言参考*，它涵盖了`__init_subclass__`和元类。“内置函数”页面中的 [`type`类文档](https://fpy.li/24-22)，以及[4.13。Python 标准库*中“内置类型”章节的特殊属性*](https://fpy.li/24-1)也是必读书。

在*Python 标准库*中， [`types`模块文档](https://fpy.li/24-24)涵盖了 Python 3.3 中增加的两个简化类元编程的函数:`types.new_class`和`types.prepare_class`。

Collin Winter 编写的[PEP 3129-Class decorator](https://fpy.li/24-25)中形式化了类装饰器，参考实现由 Jack Diederich 编写。同样由 Jack Diederich 主持的 PyCon 2009 演讲“类装饰者:彻底简单”([视频](https://fpy.li/24-26))快速介绍了这一特性。除了`@dataclass`，Python 标准库中一个有趣的——也简单得多的——类装饰器的例子是 [`functools.total_ordering`](https://fpy.li/24-27) ,它生成用于对象比较的特殊方法。

对于元类，Python 文档中的主要参考是[PEP 3115—Python 3000 中的元类](https://fpy.li/pep3115)，其中引入了`__prepare__`特殊方法。

[*Python 概括地说*](https://fpy.li/pynut3) ，第 3 版。，由 Alex Martelli、Anna Ravenscroft 和 Steve Holden 撰写，具有权威性，但它是在[PEP 487——类创建的更简单定制](https://fpy.li/pep487)问世之前撰写的。那本书中主要的元类示例——`MetaBunch`——仍然有效，因为它不能用更简单的机制来编写。布雷特·斯拉特金的 [*有效 Python*](https://fpy.li/effectpy) ，第 2 版。(Addison-Wesley)有几个最新的类构建技术的例子，包括元类。

为了了解 Python 中类元编程的起源，我推荐吉多·范·罗苏姆 2003 年的论文[“Python 2.2 中的统一类型和类”](https://fpy.li/24-28)。该文本也适用于现代 Python，因为它涵盖了当时所谓的“新型”类语义 Python 3 中的默认语义——包括描述符和元类。Guido 引用的参考文献之一是 Ira R. Forman 和 Scott H. Danforth (Addison-Wesley)所著的《让元类发挥作用:面向对象编程的新维度》( T4 ),他在 Amazon.com(T6)给了这本书五颗星，并添加了以下评论:

> **这本书为 Python 2.2 中的元类设计做出了贡献**
> 
> 可惜这是绝版了；我一直认为它是我所知道的最好的教程，是关于协作多重继承这个困难的主题的，由 Python 通过`super()`函数提供支持。 ^([19](ch24.xhtml#idm46582363449648))

如果您热衷于元编程，您可能希望 Python 具有终极的元编程特性:语法宏，就像 Lisp 语言家族以及最近由 Elixir 和 Rust 提供的那样。与 C 语言中的原始代码替换宏相比，语法宏功能更强大，更不容易出错。它们是特殊的函数，在编译步骤之前使用自定义语法将源代码重写为标准代码，使开发人员能够在不改变编译器的情况下引入新的语言结构。像操作符重载一样，语法宏也可能被滥用。但是只要社区理解并管理不好的方面，他们就支持强大且用户友好的抽象，比如 DSL(特定领域语言)。2020 年 9 月，Python 核心开发人员 Mark Shannon 发布了[PEP 638——语法宏](https://fpy.li/pep638),提倡这一点。在最初出版一年后，PEP 638 仍处于草案阶段，没有关于它的持续讨论。显然，这不是 Python 核心开发人员的首要任务。我希望看到 PEP 638 进一步讨论并最终获得批准。语法宏将允许 Python 社区在对核心语言进行永久性修改之前，试验一些有争议的新特性，如 walrus 操作符( [PEP 572](https://fpy.li/pep572) )、模式匹配( [PEP 634](https://fpy.li/pep634) )和评估类型提示的替代规则(PEP[563](https://fpy.li/pep563)和 [649](https://fpy.li/pep649) )。同时，您可以通过 [MacroPy](https://fpy.li/24-29) 包体验一下语法宏。

^([1](ch24.xhtml#idm46582370208288-marker)) 引自第二版*的“表达式”【编程风格的要素】*。(麦格劳-希尔)，第 10 页。

^([2](ch24.xhtml#idm46582370203888-marker)) 这并不意味着 PEP 487 破坏了使用这些功能的代码。这只是意味着在 Python 3.6 之前使用类装饰器或元类的一些代码现在可以被重构为使用普通类，从而产生更简单、可能更高效的代码。

感谢我的朋友 J. S. O .布埃诺为这个例子做出的贡献。

^([4](ch24.xhtml#idm46582369288640-marker)) 我没有给参数添加类型提示，因为实际类型是`Any`。我放置返回类型提示，因为否则 Mypy 不会在方法内部检查。

对于任何对象来说都是如此，除了当它的类覆盖了继承自`object`的`__str__`或`__repr__`方法时。

^([6](ch24.xhtml#idm46582368978384-marker)) 这个解决方案避免使用`None`作为缺省值。避免空值是一个好主意。总的来说，它们很难避免，但在某些情况下却很容易避免。在 Python 和 SQL 中，我更喜欢用空字符串而不是`None`或`NULL`来表示文本字段中缺失的数据。学习 Go 强化了这个想法:在 Go 中，原始类型的变量和结构字段默认用“零值”初始化。好奇的话可以看看在线*围棋* 之旅中的[“零值”。](https://fpy.li/24-6)

^([7](ch24.xhtml#idm46582368512208-marker)) 我认为`callable`应该做得适合字体提示。截至 2021 年 5 月 6 日，这是一个[未解决的问题](https://fpy.li/24-7)。

^([8](ch24.xhtml#idm46582368159120-marker)) 在[《循环、哨兵、毒丸》](ch19.xhtml#good_poison_pill_tip)中提到，`Ellipsis`对象是一个方便、安全的哨兵值。它已经存在很长时间了，但是最近人们发现了它的更多用途，正如我们在类型提示和 NumPy 中看到的。

^([9](ch24.xhtml#idm46582367837152-marker)) 在[“覆盖描述符”](ch23.xhtml#overriding_descriptor_sec)中解释了覆盖描述符的微妙概念。

^([10](ch24.xhtml#idm46582367752592-marker)) 这个基本原理出现在[PEP 557-数据类](https://fpy.li/24-9)的摘要中，用来解释为什么它被实现为类装饰器。

^([11](ch24.xhtml#idm46582367217808-marker)) 对比 Java 中的`import`语句，它只是一个声明，让编译器知道需要某些包。

^([12](ch24.xhtml#idm46582367216544-marker)) 我并不是说仅仅因为导入了一个模块就打开一个数据库连接是一个好主意，只是指出这是可以做到的。

^([13](ch24.xhtml#idm46582366318608-marker)) 给 comp.lang.python 的消息，主题:[“c . l . p .中的唇枪舌剑”](https://fpy.li/24-12)。这是 2002 年 12 月 23 日同一信息的另一部分，引自[前言](preface01.xhtml#preface_sec)。TimBot 那天受到了启发。

作者们友好地允许我使用他们的例子。`MetaBunch`第一次出现在 Martelli 于 2002 年 7 月 7 日在 comp.lang.python 组中发布的一条消息中，主题行[“一个不错的元类示例(was Re:structs in python)”](https://fpy.li/24-13)，紧接着讨论了 Python 中类似记录的数据结构。Martelli 为 Python 2.2 编写的原始代码在做了一处修改后仍然可以运行:要在 Python 3 中使用元类，必须在类声明中使用元类关键字参数，例如`Bunch(metaclass=MetaBunch)`，而不是添加`__metaclass__`类级属性的旧约定。

^([15](ch24.xhtml#idm46582364050896-marker)) 在 *Fluent Python* 的第一版中，更高级版本的`LineItem`类使用元类只是为了设置属性的存储名称。参见第一版代码库中 [bulkfood 的元类中的代码](https://fpy.li/24-14)。

如果你刚刚被元类多重继承的含义弄晕了，那么这对你有好处。我也会远离这个解决方案。

^([17](ch24.xhtml#idm46582363807680-marker)) 在我决定研究 Django 的模型字段是如何实现的之前，我以编写 Django 代码为生。直到那时，我才了解了描述符和元类。

^([18](ch24.xhtml#idm46582363498656-marker)) 这句话被广泛引用。我在 DHH 2005 年的博客文章中发现了一个早期的直接引用。

我买了一本二手书，觉得读起来很有挑战性。

^([20](ch24.xhtml#idm46582363434976-marker)) 参见第 xvii 页。全文可在[Berkeley.edu](https://fpy.li/24-30)获得。

大卫·格勒恩特(基础书籍)的《机器之美:优雅和技术的核心》以一个有趣的关于工程作品中的优雅和美学的讨论开始，从桥梁到软件。后面的章节并不伟大，但是开篇值这个价。